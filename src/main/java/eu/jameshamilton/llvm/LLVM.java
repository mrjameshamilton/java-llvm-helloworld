// Generated by jextract

package eu.jameshamilton.llvm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class LLVM extends LLVM_1 {

    LLVM() {
        // Should not be called directly
    }

    private static class LLVMAddAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMAddAttributeAtIndex$descriptor() {
        return LLVMAddAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMAddAttributeAtIndex$handle() {
        return LLVMAddAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMAddAttributeAtIndex$address() {
        return LLVMAddAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static void LLVMAddAttributeAtIndex(MemorySegment F, int Idx, MemorySegment A) {
        var mh$ = LLVMAddAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddAttributeAtIndex", F, Idx, A);
            }
            mh$.invokeExact(F, Idx, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAttributeCountAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAttributeCountAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAttributeCountAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetAttributeCountAtIndex$descriptor() {
        return LLVMGetAttributeCountAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAttributeCountAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx)
     * }
     */
    public static MethodHandle LLVMGetAttributeCountAtIndex$handle() {
        return LLVMGetAttributeCountAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAttributeCountAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx)
     * }
     */
    public static MemorySegment LLVMGetAttributeCountAtIndex$address() {
        return LLVMGetAttributeCountAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetAttributeCountAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx)
     * }
     */
    public static int LLVMGetAttributeCountAtIndex(MemorySegment F, int Idx) {
        var mh$ = LLVMGetAttributeCountAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAttributeCountAtIndex", F, Idx);
            }
            return (int)mh$.invokeExact(F, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAttributesAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAttributesAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetAttributesAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static FunctionDescriptor LLVMGetAttributesAtIndex$descriptor() {
        return LLVMGetAttributesAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetAttributesAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static MethodHandle LLVMGetAttributesAtIndex$handle() {
        return LLVMGetAttributesAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetAttributesAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static MemorySegment LLVMGetAttributesAtIndex$address() {
        return LLVMGetAttributesAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetAttributesAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static void LLVMGetAttributesAtIndex(MemorySegment F, int Idx, MemorySegment Attrs) {
        var mh$ = LLVMGetAttributesAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAttributesAtIndex", F, Idx, Attrs);
            }
            mh$.invokeExact(F, Idx, Attrs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetEnumAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetEnumAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMGetEnumAttributeAtIndex$descriptor() {
        return LLVMGetEnumAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMGetEnumAttributeAtIndex$handle() {
        return LLVMGetEnumAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetEnumAttributeAtIndex$address() {
        return LLVMGetEnumAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetEnumAttributeAtIndex(MemorySegment F, int Idx, int KindID) {
        var mh$ = LLVMGetEnumAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetEnumAttributeAtIndex", F, Idx, KindID);
            }
            return (MemorySegment)mh$.invokeExact(F, Idx, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetStringAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetStringAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static FunctionDescriptor LLVMGetStringAttributeAtIndex$descriptor() {
        return LLVMGetStringAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MethodHandle LLVMGetStringAttributeAtIndex$handle() {
        return LLVMGetStringAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMGetStringAttributeAtIndex$address() {
        return LLVMGetStringAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMGetStringAttributeAtIndex(MemorySegment F, int Idx, MemorySegment K, int KLen) {
        var mh$ = LLVMGetStringAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetStringAttributeAtIndex", F, Idx, K, KLen);
            }
            return (MemorySegment)mh$.invokeExact(F, Idx, K, KLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveEnumAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveEnumAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMRemoveEnumAttributeAtIndex$descriptor() {
        return LLVMRemoveEnumAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMRemoveEnumAttributeAtIndex$handle() {
        return LLVMRemoveEnumAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMRemoveEnumAttributeAtIndex$address() {
        return LLVMRemoveEnumAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static void LLVMRemoveEnumAttributeAtIndex(MemorySegment F, int Idx, int KindID) {
        var mh$ = LLVMRemoveEnumAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveEnumAttributeAtIndex", F, Idx, KindID);
            }
            mh$.invokeExact(F, Idx, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveStringAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveStringAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static FunctionDescriptor LLVMRemoveStringAttributeAtIndex$descriptor() {
        return LLVMRemoveStringAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MethodHandle LLVMRemoveStringAttributeAtIndex$handle() {
        return LLVMRemoveStringAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMRemoveStringAttributeAtIndex$address() {
        return LLVMRemoveStringAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static void LLVMRemoveStringAttributeAtIndex(MemorySegment F, int Idx, MemorySegment K, int KLen) {
        var mh$ = LLVMRemoveStringAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveStringAttributeAtIndex", F, Idx, K, KLen);
            }
            mh$.invokeExact(F, Idx, K, KLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddTargetDependentFunctionAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddTargetDependentFunctionAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A, const char *V)
     * }
     */
    public static FunctionDescriptor LLVMAddTargetDependentFunctionAttr$descriptor() {
        return LLVMAddTargetDependentFunctionAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A, const char *V)
     * }
     */
    public static MethodHandle LLVMAddTargetDependentFunctionAttr$handle() {
        return LLVMAddTargetDependentFunctionAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A, const char *V)
     * }
     */
    public static MemorySegment LLVMAddTargetDependentFunctionAttr$address() {
        return LLVMAddTargetDependentFunctionAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A, const char *V)
     * }
     */
    public static void LLVMAddTargetDependentFunctionAttr(MemorySegment Fn, MemorySegment A, MemorySegment V) {
        var mh$ = LLVMAddTargetDependentFunctionAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddTargetDependentFunctionAttr", Fn, A, V);
            }
            mh$.invokeExact(Fn, A, V);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCountParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCountParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParams(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMCountParams$descriptor() {
        return LLVMCountParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParams(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMCountParams$handle() {
        return LLVMCountParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParams(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMCountParams$address() {
        return LLVMCountParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCountParams(LLVMValueRef Fn)
     * }
     */
    public static int LLVMCountParams(MemorySegment Fn) {
        var mh$ = LLVMCountParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCountParams", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params)
     * }
     */
    public static FunctionDescriptor LLVMGetParams$descriptor() {
        return LLVMGetParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params)
     * }
     */
    public static MethodHandle LLVMGetParams$handle() {
        return LLVMGetParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params)
     * }
     */
    public static MemorySegment LLVMGetParams$address() {
        return LLVMGetParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params)
     * }
     */
    public static void LLVMGetParams(MemorySegment Fn, MemorySegment Params) {
        var mh$ = LLVMGetParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParams", Fn, Params);
            }
            mh$.invokeExact(Fn, Params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetParam$descriptor() {
        return LLVMGetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetParam$handle() {
        return LLVMGetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetParam$address() {
        return LLVMGetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetParam(MemorySegment Fn, int Index) {
        var mh$ = LLVMGetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParam", Fn, Index);
            }
            return (MemorySegment)mh$.invokeExact(Fn, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParamParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParamParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetParamParent$descriptor() {
        return LLVMGetParamParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetParamParent$handle() {
        return LLVMGetParamParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetParamParent$address() {
        return LLVMGetParamParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetParamParent(MemorySegment Inst) {
        var mh$ = LLVMGetParamParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParamParent", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstParam$descriptor() {
        return LLVMGetFirstParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetFirstParam$handle() {
        return LLVMGetFirstParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFirstParam$address() {
        return LLVMGetFirstParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFirstParam(MemorySegment Fn) {
        var mh$ = LLVMGetFirstParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstParam", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetLastParam$descriptor() {
        return LLVMGetLastParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetLastParam$handle() {
        return LLVMGetLastParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetLastParam$address() {
        return LLVMGetLastParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetLastParam(MemorySegment Fn) {
        var mh$ = LLVMGetLastParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastParam", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg)
     * }
     */
    public static FunctionDescriptor LLVMGetNextParam$descriptor() {
        return LLVMGetNextParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg)
     * }
     */
    public static MethodHandle LLVMGetNextParam$handle() {
        return LLVMGetNextParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg)
     * }
     */
    public static MemorySegment LLVMGetNextParam$address() {
        return LLVMGetNextParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg)
     * }
     */
    public static MemorySegment LLVMGetNextParam(MemorySegment Arg) {
        var mh$ = LLVMGetNextParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextParam", Arg);
            }
            return (MemorySegment)mh$.invokeExact(Arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousParam$descriptor() {
        return LLVMGetPreviousParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg)
     * }
     */
    public static MethodHandle LLVMGetPreviousParam$handle() {
        return LLVMGetPreviousParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg)
     * }
     */
    public static MemorySegment LLVMGetPreviousParam$address() {
        return LLVMGetPreviousParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg)
     * }
     */
    public static MemorySegment LLVMGetPreviousParam(MemorySegment Arg) {
        var mh$ = LLVMGetPreviousParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousParam", Arg);
            }
            return (MemorySegment)mh$.invokeExact(Arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetParamAlignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetParamAlignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned int Align)
     * }
     */
    public static FunctionDescriptor LLVMSetParamAlignment$descriptor() {
        return LLVMSetParamAlignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned int Align)
     * }
     */
    public static MethodHandle LLVMSetParamAlignment$handle() {
        return LLVMSetParamAlignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned int Align)
     * }
     */
    public static MemorySegment LLVMSetParamAlignment$address() {
        return LLVMSetParamAlignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned int Align)
     * }
     */
    public static void LLVMSetParamAlignment(MemorySegment Arg, int Align) {
        var mh$ = LLVMSetParamAlignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetParamAlignment", Arg, Align);
            }
            mh$.invokeExact(Arg, Align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty, unsigned int AddrSpace, LLVMValueRef Resolver)
     * }
     */
    public static FunctionDescriptor LLVMAddGlobalIFunc$descriptor() {
        return LLVMAddGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty, unsigned int AddrSpace, LLVMValueRef Resolver)
     * }
     */
    public static MethodHandle LLVMAddGlobalIFunc$handle() {
        return LLVMAddGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty, unsigned int AddrSpace, LLVMValueRef Resolver)
     * }
     */
    public static MemorySegment LLVMAddGlobalIFunc$address() {
        return LLVMAddGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty, unsigned int AddrSpace, LLVMValueRef Resolver)
     * }
     */
    public static MemorySegment LLVMAddGlobalIFunc(MemorySegment M, MemorySegment Name, long NameLen, MemorySegment Ty, int AddrSpace, MemorySegment Resolver) {
        var mh$ = LLVMAddGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddGlobalIFunc", M, Name, NameLen, Ty, AddrSpace, Resolver);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, NameLen, Ty, AddrSpace, Resolver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedGlobalIFunc$descriptor() {
        return LLVMGetNamedGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MethodHandle LLVMGetNamedGlobalIFunc$handle() {
        return LLVMGetNamedGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobalIFunc$address() {
        return LLVMGetNamedGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobalIFunc(MemorySegment M, MemorySegment Name, long NameLen) {
        var mh$ = LLVMGetNamedGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedGlobalIFunc", M, Name, NameLen);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, NameLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstGlobalIFunc$descriptor() {
        return LLVMGetFirstGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetFirstGlobalIFunc$handle() {
        return LLVMGetFirstGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstGlobalIFunc$address() {
        return LLVMGetFirstGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstGlobalIFunc(MemorySegment M) {
        var mh$ = LLVMGetFirstGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstGlobalIFunc", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetLastGlobalIFunc$descriptor() {
        return LLVMGetLastGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetLastGlobalIFunc$handle() {
        return LLVMGetLastGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastGlobalIFunc$address() {
        return LLVMGetLastGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastGlobalIFunc(MemorySegment M) {
        var mh$ = LLVMGetLastGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastGlobalIFunc", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMGetNextGlobalIFunc$descriptor() {
        return LLVMGetNextGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMGetNextGlobalIFunc$handle() {
        return LLVMGetNextGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetNextGlobalIFunc$address() {
        return LLVMGetNextGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetNextGlobalIFunc(MemorySegment IFunc) {
        var mh$ = LLVMGetNextGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextGlobalIFunc", IFunc);
            }
            return (MemorySegment)mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousGlobalIFunc$descriptor() {
        return LLVMGetPreviousGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMGetPreviousGlobalIFunc$handle() {
        return LLVMGetPreviousGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetPreviousGlobalIFunc$address() {
        return LLVMGetPreviousGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetPreviousGlobalIFunc(MemorySegment IFunc) {
        var mh$ = LLVMGetPreviousGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousGlobalIFunc", IFunc);
            }
            return (MemorySegment)mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetGlobalIFuncResolver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetGlobalIFuncResolver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetGlobalIFuncResolver(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMGetGlobalIFuncResolver$descriptor() {
        return LLVMGetGlobalIFuncResolver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetGlobalIFuncResolver(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMGetGlobalIFuncResolver$handle() {
        return LLVMGetGlobalIFuncResolver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetGlobalIFuncResolver(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetGlobalIFuncResolver$address() {
        return LLVMGetGlobalIFuncResolver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetGlobalIFuncResolver(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetGlobalIFuncResolver(MemorySegment IFunc) {
        var mh$ = LLVMGetGlobalIFuncResolver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetGlobalIFuncResolver", IFunc);
            }
            return (MemorySegment)mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetGlobalIFuncResolver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetGlobalIFuncResolver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetGlobalIFuncResolver(LLVMValueRef IFunc, LLVMValueRef Resolver)
     * }
     */
    public static FunctionDescriptor LLVMSetGlobalIFuncResolver$descriptor() {
        return LLVMSetGlobalIFuncResolver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetGlobalIFuncResolver(LLVMValueRef IFunc, LLVMValueRef Resolver)
     * }
     */
    public static MethodHandle LLVMSetGlobalIFuncResolver$handle() {
        return LLVMSetGlobalIFuncResolver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetGlobalIFuncResolver(LLVMValueRef IFunc, LLVMValueRef Resolver)
     * }
     */
    public static MemorySegment LLVMSetGlobalIFuncResolver$address() {
        return LLVMSetGlobalIFuncResolver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetGlobalIFuncResolver(LLVMValueRef IFunc, LLVMValueRef Resolver)
     * }
     */
    public static void LLVMSetGlobalIFuncResolver(MemorySegment IFunc, MemorySegment Resolver) {
        var mh$ = LLVMSetGlobalIFuncResolver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetGlobalIFuncResolver", IFunc, Resolver);
            }
            mh$.invokeExact(IFunc, Resolver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMEraseGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMEraseGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMEraseGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMEraseGlobalIFunc$descriptor() {
        return LLVMEraseGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMEraseGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMEraseGlobalIFunc$handle() {
        return LLVMEraseGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMEraseGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMEraseGlobalIFunc$address() {
        return LLVMEraseGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMEraseGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static void LLVMEraseGlobalIFunc(MemorySegment IFunc) {
        var mh$ = LLVMEraseGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMEraseGlobalIFunc", IFunc);
            }
            mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMRemoveGlobalIFunc$descriptor() {
        return LLVMRemoveGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMRemoveGlobalIFunc$handle() {
        return LLVMRemoveGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMRemoveGlobalIFunc$address() {
        return LLVMRemoveGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static void LLVMRemoveGlobalIFunc(MemorySegment IFunc) {
        var mh$ = LLVMRemoveGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveGlobalIFunc", IFunc);
            }
            mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDStringInContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDStringInContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDStringInContext2(LLVMContextRef C, const char *Str, size_t SLen)
     * }
     */
    public static FunctionDescriptor LLVMMDStringInContext2$descriptor() {
        return LLVMMDStringInContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDStringInContext2(LLVMContextRef C, const char *Str, size_t SLen)
     * }
     */
    public static MethodHandle LLVMMDStringInContext2$handle() {
        return LLVMMDStringInContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDStringInContext2(LLVMContextRef C, const char *Str, size_t SLen)
     * }
     */
    public static MemorySegment LLVMMDStringInContext2$address() {
        return LLVMMDStringInContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDStringInContext2(LLVMContextRef C, const char *Str, size_t SLen)
     * }
     */
    public static MemorySegment LLVMMDStringInContext2(MemorySegment C, MemorySegment Str, long SLen) {
        var mh$ = LLVMMDStringInContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDStringInContext2", C, Str, SLen);
            }
            return (MemorySegment)mh$.invokeExact(C, Str, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDNodeInContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDNodeInContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDNodeInContext2(LLVMContextRef C, LLVMMetadataRef *MDs, size_t Count)
     * }
     */
    public static FunctionDescriptor LLVMMDNodeInContext2$descriptor() {
        return LLVMMDNodeInContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDNodeInContext2(LLVMContextRef C, LLVMMetadataRef *MDs, size_t Count)
     * }
     */
    public static MethodHandle LLVMMDNodeInContext2$handle() {
        return LLVMMDNodeInContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDNodeInContext2(LLVMContextRef C, LLVMMetadataRef *MDs, size_t Count)
     * }
     */
    public static MemorySegment LLVMMDNodeInContext2$address() {
        return LLVMMDNodeInContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDNodeInContext2(LLVMContextRef C, LLVMMetadataRef *MDs, size_t Count)
     * }
     */
    public static MemorySegment LLVMMDNodeInContext2(MemorySegment C, MemorySegment MDs, long Count) {
        var mh$ = LLVMMDNodeInContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDNodeInContext2", C, MDs, Count);
            }
            return (MemorySegment)mh$.invokeExact(C, MDs, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMetadataAsValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMetadataAsValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD)
     * }
     */
    public static FunctionDescriptor LLVMMetadataAsValue$descriptor() {
        return LLVMMetadataAsValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD)
     * }
     */
    public static MethodHandle LLVMMetadataAsValue$handle() {
        return LLVMMetadataAsValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD)
     * }
     */
    public static MemorySegment LLVMMetadataAsValue$address() {
        return LLVMMetadataAsValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD)
     * }
     */
    public static MemorySegment LLVMMetadataAsValue(MemorySegment C, MemorySegment MD) {
        var mh$ = LLVMMetadataAsValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMetadataAsValue", C, MD);
            }
            return (MemorySegment)mh$.invokeExact(C, MD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMValueAsMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMValueAsMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMValueAsMetadata$descriptor() {
        return LLVMValueAsMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMValueAsMetadata$handle() {
        return LLVMValueAsMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueAsMetadata$address() {
        return LLVMValueAsMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueAsMetadata(MemorySegment Val) {
        var mh$ = LLVMValueAsMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMValueAsMetadata", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMDString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMDString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetMDString(LLVMValueRef V, unsigned int *Length)
     * }
     */
    public static FunctionDescriptor LLVMGetMDString$descriptor() {
        return LLVMGetMDString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetMDString(LLVMValueRef V, unsigned int *Length)
     * }
     */
    public static MethodHandle LLVMGetMDString$handle() {
        return LLVMGetMDString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetMDString(LLVMValueRef V, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetMDString$address() {
        return LLVMGetMDString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetMDString(LLVMValueRef V, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetMDString(MemorySegment V, MemorySegment Length) {
        var mh$ = LLVMGetMDString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMDString", V, Length);
            }
            return (MemorySegment)mh$.invokeExact(V, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMDNodeNumOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMDNodeNumOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDNodeNumOperands(LLVMValueRef V)
     * }
     */
    public static FunctionDescriptor LLVMGetMDNodeNumOperands$descriptor() {
        return LLVMGetMDNodeNumOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDNodeNumOperands(LLVMValueRef V)
     * }
     */
    public static MethodHandle LLVMGetMDNodeNumOperands$handle() {
        return LLVMGetMDNodeNumOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDNodeNumOperands(LLVMValueRef V)
     * }
     */
    public static MemorySegment LLVMGetMDNodeNumOperands$address() {
        return LLVMGetMDNodeNumOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetMDNodeNumOperands(LLVMValueRef V)
     * }
     */
    public static int LLVMGetMDNodeNumOperands(MemorySegment V) {
        var mh$ = LLVMGetMDNodeNumOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMDNodeNumOperands", V);
            }
            return (int)mh$.invokeExact(V);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMDNodeOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMDNodeOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)
     * }
     */
    public static FunctionDescriptor LLVMGetMDNodeOperands$descriptor() {
        return LLVMGetMDNodeOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)
     * }
     */
    public static MethodHandle LLVMGetMDNodeOperands$handle() {
        return LLVMGetMDNodeOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)
     * }
     */
    public static MemorySegment LLVMGetMDNodeOperands$address() {
        return LLVMGetMDNodeOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)
     * }
     */
    public static void LLVMGetMDNodeOperands(MemorySegment V, MemorySegment Dest) {
        var mh$ = LLVMGetMDNodeOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMDNodeOperands", V, Dest);
            }
            mh$.invokeExact(V, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMReplaceMDNodeOperandWith {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMReplaceMDNodeOperandWith");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMReplaceMDNodeOperandWith(LLVMValueRef V, unsigned int Index, LLVMMetadataRef Replacement)
     * }
     */
    public static FunctionDescriptor LLVMReplaceMDNodeOperandWith$descriptor() {
        return LLVMReplaceMDNodeOperandWith.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMReplaceMDNodeOperandWith(LLVMValueRef V, unsigned int Index, LLVMMetadataRef Replacement)
     * }
     */
    public static MethodHandle LLVMReplaceMDNodeOperandWith$handle() {
        return LLVMReplaceMDNodeOperandWith.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMReplaceMDNodeOperandWith(LLVMValueRef V, unsigned int Index, LLVMMetadataRef Replacement)
     * }
     */
    public static MemorySegment LLVMReplaceMDNodeOperandWith$address() {
        return LLVMReplaceMDNodeOperandWith.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMReplaceMDNodeOperandWith(LLVMValueRef V, unsigned int Index, LLVMMetadataRef Replacement)
     * }
     */
    public static void LLVMReplaceMDNodeOperandWith(MemorySegment V, int Index, MemorySegment Replacement) {
        var mh$ = LLVMReplaceMDNodeOperandWith.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMReplaceMDNodeOperandWith", V, Index, Replacement);
            }
            mh$.invokeExact(V, Index, Replacement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDStringInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDStringInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str, unsigned int SLen)
     * }
     */
    public static FunctionDescriptor LLVMMDStringInContext$descriptor() {
        return LLVMMDStringInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str, unsigned int SLen)
     * }
     */
    public static MethodHandle LLVMMDStringInContext$handle() {
        return LLVMMDStringInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMMDStringInContext$address() {
        return LLVMMDStringInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMMDStringInContext(MemorySegment C, MemorySegment Str, int SLen) {
        var mh$ = LLVMMDStringInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDStringInContext", C, Str, SLen);
            }
            return (MemorySegment)mh$.invokeExact(C, Str, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDString(const char *Str, unsigned int SLen)
     * }
     */
    public static FunctionDescriptor LLVMMDString$descriptor() {
        return LLVMMDString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDString(const char *Str, unsigned int SLen)
     * }
     */
    public static MethodHandle LLVMMDString$handle() {
        return LLVMMDString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDString(const char *Str, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMMDString$address() {
        return LLVMMDString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDString(const char *Str, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMMDString(MemorySegment Str, int SLen) {
        var mh$ = LLVMMDString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDString", Str, SLen);
            }
            return (MemorySegment)mh$.invokeExact(Str, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDNodeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDNodeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static FunctionDescriptor LLVMMDNodeInContext$descriptor() {
        return LLVMMDNodeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MethodHandle LLVMMDNodeInContext$handle() {
        return LLVMMDNodeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMMDNodeInContext$address() {
        return LLVMMDNodeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMMDNodeInContext(MemorySegment C, MemorySegment Vals, int Count) {
        var mh$ = LLVMMDNodeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDNodeInContext", C, Vals, Count);
            }
            return (MemorySegment)mh$.invokeExact(C, Vals, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static FunctionDescriptor LLVMMDNode$descriptor() {
        return LLVMMDNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MethodHandle LLVMMDNode$handle() {
        return LLVMMDNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMMDNode$address() {
        return LLVMMDNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMMDNode(MemorySegment Vals, int Count) {
        var mh$ = LLVMMDNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDNode", Vals, Count);
            }
            return (MemorySegment)mh$.invokeExact(Vals, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateOperandBundle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateOperandBundle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMCreateOperandBundle(const char *Tag, size_t TagLen, LLVMValueRef *Args, unsigned int NumArgs)
     * }
     */
    public static FunctionDescriptor LLVMCreateOperandBundle$descriptor() {
        return LLVMCreateOperandBundle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMCreateOperandBundle(const char *Tag, size_t TagLen, LLVMValueRef *Args, unsigned int NumArgs)
     * }
     */
    public static MethodHandle LLVMCreateOperandBundle$handle() {
        return LLVMCreateOperandBundle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMCreateOperandBundle(const char *Tag, size_t TagLen, LLVMValueRef *Args, unsigned int NumArgs)
     * }
     */
    public static MemorySegment LLVMCreateOperandBundle$address() {
        return LLVMCreateOperandBundle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMCreateOperandBundle(const char *Tag, size_t TagLen, LLVMValueRef *Args, unsigned int NumArgs)
     * }
     */
    public static MemorySegment LLVMCreateOperandBundle(MemorySegment Tag, long TagLen, MemorySegment Args, int NumArgs) {
        var mh$ = LLVMCreateOperandBundle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateOperandBundle", Tag, TagLen, Args, NumArgs);
            }
            return (MemorySegment)mh$.invokeExact(Tag, TagLen, Args, NumArgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeOperandBundle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeOperandBundle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeOperandBundle(LLVMOperandBundleRef Bundle)
     * }
     */
    public static FunctionDescriptor LLVMDisposeOperandBundle$descriptor() {
        return LLVMDisposeOperandBundle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeOperandBundle(LLVMOperandBundleRef Bundle)
     * }
     */
    public static MethodHandle LLVMDisposeOperandBundle$handle() {
        return LLVMDisposeOperandBundle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeOperandBundle(LLVMOperandBundleRef Bundle)
     * }
     */
    public static MemorySegment LLVMDisposeOperandBundle$address() {
        return LLVMDisposeOperandBundle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeOperandBundle(LLVMOperandBundleRef Bundle)
     * }
     */
    public static void LLVMDisposeOperandBundle(MemorySegment Bundle) {
        var mh$ = LLVMDisposeOperandBundle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeOperandBundle", Bundle);
            }
            mh$.invokeExact(Bundle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOperandBundleTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOperandBundleTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetOperandBundleTag(LLVMOperandBundleRef Bundle, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMGetOperandBundleTag$descriptor() {
        return LLVMGetOperandBundleTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetOperandBundleTag(LLVMOperandBundleRef Bundle, size_t *Len)
     * }
     */
    public static MethodHandle LLVMGetOperandBundleTag$handle() {
        return LLVMGetOperandBundleTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetOperandBundleTag(LLVMOperandBundleRef Bundle, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleTag$address() {
        return LLVMGetOperandBundleTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetOperandBundleTag(LLVMOperandBundleRef Bundle, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleTag(MemorySegment Bundle, MemorySegment Len) {
        var mh$ = LLVMGetOperandBundleTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOperandBundleTag", Bundle, Len);
            }
            return (MemorySegment)mh$.invokeExact(Bundle, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumOperandBundleArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumOperandBundleArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundleArgs(LLVMOperandBundleRef Bundle)
     * }
     */
    public static FunctionDescriptor LLVMGetNumOperandBundleArgs$descriptor() {
        return LLVMGetNumOperandBundleArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundleArgs(LLVMOperandBundleRef Bundle)
     * }
     */
    public static MethodHandle LLVMGetNumOperandBundleArgs$handle() {
        return LLVMGetNumOperandBundleArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundleArgs(LLVMOperandBundleRef Bundle)
     * }
     */
    public static MemorySegment LLVMGetNumOperandBundleArgs$address() {
        return LLVMGetNumOperandBundleArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundleArgs(LLVMOperandBundleRef Bundle)
     * }
     */
    public static int LLVMGetNumOperandBundleArgs(MemorySegment Bundle) {
        var mh$ = LLVMGetNumOperandBundleArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumOperandBundleArgs", Bundle);
            }
            return (int)mh$.invokeExact(Bundle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOperandBundleArgAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOperandBundleArgAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperandBundleArgAtIndex(LLVMOperandBundleRef Bundle, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetOperandBundleArgAtIndex$descriptor() {
        return LLVMGetOperandBundleArgAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperandBundleArgAtIndex(LLVMOperandBundleRef Bundle, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetOperandBundleArgAtIndex$handle() {
        return LLVMGetOperandBundleArgAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperandBundleArgAtIndex(LLVMOperandBundleRef Bundle, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleArgAtIndex$address() {
        return LLVMGetOperandBundleArgAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperandBundleArgAtIndex(LLVMOperandBundleRef Bundle, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleArgAtIndex(MemorySegment Bundle, int Index) {
        var mh$ = LLVMGetOperandBundleArgAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOperandBundleArgAtIndex", Bundle, Index);
            }
            return (MemorySegment)mh$.invokeExact(Bundle, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBasicBlockAsValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBasicBlockAsValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMBasicBlockAsValue$descriptor() {
        return LLVMBasicBlockAsValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMBasicBlockAsValue$handle() {
        return LLVMBasicBlockAsValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBasicBlockAsValue$address() {
        return LLVMBasicBlockAsValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBasicBlockAsValue(MemorySegment BB) {
        var mh$ = LLVMBasicBlockAsValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBasicBlockAsValue", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMValueIsBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMValueIsBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMValueIsBasicBlock$descriptor() {
        return LLVMValueIsBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMValueIsBasicBlock$handle() {
        return LLVMValueIsBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueIsBasicBlock$address() {
        return LLVMValueIsBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static int LLVMValueIsBasicBlock(MemorySegment Val) {
        var mh$ = LLVMValueIsBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMValueIsBasicBlock", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMValueAsBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMValueAsBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMValueAsBasicBlock$descriptor() {
        return LLVMValueAsBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMValueAsBasicBlock$handle() {
        return LLVMValueAsBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueAsBasicBlock$address() {
        return LLVMValueAsBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueAsBasicBlock(MemorySegment Val) {
        var mh$ = LLVMValueAsBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMValueAsBasicBlock", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBasicBlockName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBasicBlockName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetBasicBlockName$descriptor() {
        return LLVMGetBasicBlockName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetBasicBlockName$handle() {
        return LLVMGetBasicBlockName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockName$address() {
        return LLVMGetBasicBlockName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockName(MemorySegment BB) {
        var mh$ = LLVMGetBasicBlockName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBasicBlockName", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBasicBlockParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBasicBlockParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetBasicBlockParent$descriptor() {
        return LLVMGetBasicBlockParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetBasicBlockParent$handle() {
        return LLVMGetBasicBlockParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockParent$address() {
        return LLVMGetBasicBlockParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockParent(MemorySegment BB) {
        var mh$ = LLVMGetBasicBlockParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBasicBlockParent", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBasicBlockTerminator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBasicBlockTerminator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetBasicBlockTerminator$descriptor() {
        return LLVMGetBasicBlockTerminator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetBasicBlockTerminator$handle() {
        return LLVMGetBasicBlockTerminator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockTerminator$address() {
        return LLVMGetBasicBlockTerminator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockTerminator(MemorySegment BB) {
        var mh$ = LLVMGetBasicBlockTerminator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBasicBlockTerminator", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCountBasicBlocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCountBasicBlocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCountBasicBlocks(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMCountBasicBlocks$descriptor() {
        return LLVMCountBasicBlocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCountBasicBlocks(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMCountBasicBlocks$handle() {
        return LLVMCountBasicBlocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCountBasicBlocks(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMCountBasicBlocks$address() {
        return LLVMCountBasicBlocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCountBasicBlocks(LLVMValueRef Fn)
     * }
     */
    public static int LLVMCountBasicBlocks(MemorySegment Fn) {
        var mh$ = LLVMCountBasicBlocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCountBasicBlocks", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBasicBlocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBasicBlocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks)
     * }
     */
    public static FunctionDescriptor LLVMGetBasicBlocks$descriptor() {
        return LLVMGetBasicBlocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks)
     * }
     */
    public static MethodHandle LLVMGetBasicBlocks$handle() {
        return LLVMGetBasicBlocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks)
     * }
     */
    public static MemorySegment LLVMGetBasicBlocks$address() {
        return LLVMGetBasicBlocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks)
     * }
     */
    public static void LLVMGetBasicBlocks(MemorySegment Fn, MemorySegment BasicBlocks) {
        var mh$ = LLVMGetBasicBlocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBasicBlocks", Fn, BasicBlocks);
            }
            mh$.invokeExact(Fn, BasicBlocks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstBasicBlock$descriptor() {
        return LLVMGetFirstBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetFirstBasicBlock$handle() {
        return LLVMGetFirstBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFirstBasicBlock$address() {
        return LLVMGetFirstBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFirstBasicBlock(MemorySegment Fn) {
        var mh$ = LLVMGetFirstBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstBasicBlock", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetLastBasicBlock$descriptor() {
        return LLVMGetLastBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetLastBasicBlock$handle() {
        return LLVMGetLastBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetLastBasicBlock$address() {
        return LLVMGetLastBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetLastBasicBlock(MemorySegment Fn) {
        var mh$ = LLVMGetLastBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastBasicBlock", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetNextBasicBlock$descriptor() {
        return LLVMGetNextBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetNextBasicBlock$handle() {
        return LLVMGetNextBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetNextBasicBlock$address() {
        return LLVMGetNextBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetNextBasicBlock(MemorySegment BB) {
        var mh$ = LLVMGetNextBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextBasicBlock", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousBasicBlock$descriptor() {
        return LLVMGetPreviousBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetPreviousBasicBlock$handle() {
        return LLVMGetPreviousBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetPreviousBasicBlock$address() {
        return LLVMGetPreviousBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetPreviousBasicBlock(MemorySegment BB) {
        var mh$ = LLVMGetPreviousBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousBasicBlock", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetEntryBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetEntryBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetEntryBasicBlock$descriptor() {
        return LLVMGetEntryBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetEntryBasicBlock$handle() {
        return LLVMGetEntryBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetEntryBasicBlock$address() {
        return LLVMGetEntryBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetEntryBasicBlock(MemorySegment Fn) {
        var mh$ = LLVMGetEntryBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetEntryBasicBlock", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertExistingBasicBlockAfterInsertBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertExistingBasicBlockAfterInsertBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInsertExistingBasicBlockAfterInsertBlock(LLVMBuilderRef Builder, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMInsertExistingBasicBlockAfterInsertBlock$descriptor() {
        return LLVMInsertExistingBasicBlockAfterInsertBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInsertExistingBasicBlockAfterInsertBlock(LLVMBuilderRef Builder, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMInsertExistingBasicBlockAfterInsertBlock$handle() {
        return LLVMInsertExistingBasicBlockAfterInsertBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInsertExistingBasicBlockAfterInsertBlock(LLVMBuilderRef Builder, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMInsertExistingBasicBlockAfterInsertBlock$address() {
        return LLVMInsertExistingBasicBlockAfterInsertBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInsertExistingBasicBlockAfterInsertBlock(LLVMBuilderRef Builder, LLVMBasicBlockRef BB)
     * }
     */
    public static void LLVMInsertExistingBasicBlockAfterInsertBlock(MemorySegment Builder, MemorySegment BB) {
        var mh$ = LLVMInsertExistingBasicBlockAfterInsertBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertExistingBasicBlockAfterInsertBlock", Builder, BB);
            }
            mh$.invokeExact(Builder, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAppendExistingBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAppendExistingBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAppendExistingBasicBlock(LLVMValueRef Fn, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMAppendExistingBasicBlock$descriptor() {
        return LLVMAppendExistingBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAppendExistingBasicBlock(LLVMValueRef Fn, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMAppendExistingBasicBlock$handle() {
        return LLVMAppendExistingBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAppendExistingBasicBlock(LLVMValueRef Fn, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMAppendExistingBasicBlock$address() {
        return LLVMAppendExistingBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAppendExistingBasicBlock(LLVMValueRef Fn, LLVMBasicBlockRef BB)
     * }
     */
    public static void LLVMAppendExistingBasicBlock(MemorySegment Fn, MemorySegment BB) {
        var mh$ = LLVMAppendExistingBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAppendExistingBasicBlock", Fn, BB);
            }
            mh$.invokeExact(Fn, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateBasicBlockInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateBasicBlockInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMCreateBasicBlockInContext(LLVMContextRef C, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMCreateBasicBlockInContext$descriptor() {
        return LLVMCreateBasicBlockInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMCreateBasicBlockInContext(LLVMContextRef C, const char *Name)
     * }
     */
    public static MethodHandle LLVMCreateBasicBlockInContext$handle() {
        return LLVMCreateBasicBlockInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMCreateBasicBlockInContext(LLVMContextRef C, const char *Name)
     * }
     */
    public static MemorySegment LLVMCreateBasicBlockInContext$address() {
        return LLVMCreateBasicBlockInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMCreateBasicBlockInContext(LLVMContextRef C, const char *Name)
     * }
     */
    public static MemorySegment LLVMCreateBasicBlockInContext(MemorySegment C, MemorySegment Name) {
        var mh$ = LLVMCreateBasicBlockInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateBasicBlockInContext", C, Name);
            }
            return (MemorySegment)mh$.invokeExact(C, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAppendBasicBlockInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAppendBasicBlockInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C, LLVMValueRef Fn, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMAppendBasicBlockInContext$descriptor() {
        return LLVMAppendBasicBlockInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C, LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MethodHandle LLVMAppendBasicBlockInContext$handle() {
        return LLVMAppendBasicBlockInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C, LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMAppendBasicBlockInContext$address() {
        return LLVMAppendBasicBlockInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C, LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMAppendBasicBlockInContext(MemorySegment C, MemorySegment Fn, MemorySegment Name) {
        var mh$ = LLVMAppendBasicBlockInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAppendBasicBlockInContext", C, Fn, Name);
            }
            return (MemorySegment)mh$.invokeExact(C, Fn, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAppendBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAppendBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMAppendBasicBlock$descriptor() {
        return LLVMAppendBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MethodHandle LLVMAppendBasicBlock$handle() {
        return LLVMAppendBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMAppendBasicBlock$address() {
        return LLVMAppendBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMAppendBasicBlock(MemorySegment Fn, MemorySegment Name) {
        var mh$ = LLVMAppendBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAppendBasicBlock", Fn, Name);
            }
            return (MemorySegment)mh$.invokeExact(Fn, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertBasicBlockInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertBasicBlockInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C, LLVMBasicBlockRef BB, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMInsertBasicBlockInContext$descriptor() {
        return LLVMInsertBasicBlockInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C, LLVMBasicBlockRef BB, const char *Name)
     * }
     */
    public static MethodHandle LLVMInsertBasicBlockInContext$handle() {
        return LLVMInsertBasicBlockInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C, LLVMBasicBlockRef BB, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertBasicBlockInContext$address() {
        return LLVMInsertBasicBlockInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C, LLVMBasicBlockRef BB, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertBasicBlockInContext(MemorySegment C, MemorySegment BB, MemorySegment Name) {
        var mh$ = LLVMInsertBasicBlockInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertBasicBlockInContext", C, BB, Name);
            }
            return (MemorySegment)mh$.invokeExact(C, BB, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMInsertBasicBlock$descriptor() {
        return LLVMInsertBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB, const char *Name)
     * }
     */
    public static MethodHandle LLVMInsertBasicBlock$handle() {
        return LLVMInsertBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertBasicBlock$address() {
        return LLVMInsertBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertBasicBlock(MemorySegment InsertBeforeBB, MemorySegment Name) {
        var mh$ = LLVMInsertBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertBasicBlock", InsertBeforeBB, Name);
            }
            return (MemorySegment)mh$.invokeExact(InsertBeforeBB, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDeleteBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDeleteBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMDeleteBasicBlock$descriptor() {
        return LLVMDeleteBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMDeleteBasicBlock$handle() {
        return LLVMDeleteBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMDeleteBasicBlock$address() {
        return LLVMDeleteBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static void LLVMDeleteBasicBlock(MemorySegment BB) {
        var mh$ = LLVMDeleteBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDeleteBasicBlock", BB);
            }
            mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveBasicBlockFromParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveBasicBlockFromParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMRemoveBasicBlockFromParent$descriptor() {
        return LLVMRemoveBasicBlockFromParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMRemoveBasicBlockFromParent$handle() {
        return LLVMRemoveBasicBlockFromParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMRemoveBasicBlockFromParent$address() {
        return LLVMRemoveBasicBlockFromParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB)
     * }
     */
    public static void LLVMRemoveBasicBlockFromParent(MemorySegment BB) {
        var mh$ = LLVMRemoveBasicBlockFromParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveBasicBlockFromParent", BB);
            }
            mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMoveBasicBlockBefore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMoveBasicBlockBefore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static FunctionDescriptor LLVMMoveBasicBlockBefore$descriptor() {
        return LLVMMoveBasicBlockBefore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static MethodHandle LLVMMoveBasicBlockBefore$handle() {
        return LLVMMoveBasicBlockBefore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static MemorySegment LLVMMoveBasicBlockBefore$address() {
        return LLVMMoveBasicBlockBefore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static void LLVMMoveBasicBlockBefore(MemorySegment BB, MemorySegment MovePos) {
        var mh$ = LLVMMoveBasicBlockBefore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMoveBasicBlockBefore", BB, MovePos);
            }
            mh$.invokeExact(BB, MovePos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMoveBasicBlockAfter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMoveBasicBlockAfter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static FunctionDescriptor LLVMMoveBasicBlockAfter$descriptor() {
        return LLVMMoveBasicBlockAfter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static MethodHandle LLVMMoveBasicBlockAfter$handle() {
        return LLVMMoveBasicBlockAfter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static MemorySegment LLVMMoveBasicBlockAfter$address() {
        return LLVMMoveBasicBlockAfter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static void LLVMMoveBasicBlockAfter(MemorySegment BB, MemorySegment MovePos) {
        var mh$ = LLVMMoveBasicBlockAfter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMoveBasicBlockAfter", BB, MovePos);
            }
            mh$.invokeExact(BB, MovePos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstInstruction$descriptor() {
        return LLVMGetFirstInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetFirstInstruction$handle() {
        return LLVMGetFirstInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetFirstInstruction$address() {
        return LLVMGetFirstInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetFirstInstruction(MemorySegment BB) {
        var mh$ = LLVMGetFirstInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstInstruction", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetLastInstruction$descriptor() {
        return LLVMGetLastInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetLastInstruction$handle() {
        return LLVMGetLastInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetLastInstruction$address() {
        return LLVMGetLastInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetLastInstruction(MemorySegment BB) {
        var mh$ = LLVMGetLastInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastInstruction", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMHasMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMHasMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LLVMHasMetadata(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMHasMetadata$descriptor() {
        return LLVMHasMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LLVMHasMetadata(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMHasMetadata$handle() {
        return LLVMHasMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LLVMHasMetadata(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMHasMetadata$address() {
        return LLVMHasMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LLVMHasMetadata(LLVMValueRef Val)
     * }
     */
    public static int LLVMHasMetadata(MemorySegment Val) {
        var mh$ = LLVMHasMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMHasMetadata", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMGetMetadata$descriptor() {
        return LLVMGetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMGetMetadata$handle() {
        return LLVMGetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetMetadata$address() {
        return LLVMGetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetMetadata(MemorySegment Val, int KindID) {
        var mh$ = LLVMGetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMetadata", Val, KindID);
            }
            return (MemorySegment)mh$.invokeExact(Val, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetMetadata(LLVMValueRef Val, unsigned int KindID, LLVMValueRef Node)
     * }
     */
    public static FunctionDescriptor LLVMSetMetadata$descriptor() {
        return LLVMSetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetMetadata(LLVMValueRef Val, unsigned int KindID, LLVMValueRef Node)
     * }
     */
    public static MethodHandle LLVMSetMetadata$handle() {
        return LLVMSetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetMetadata(LLVMValueRef Val, unsigned int KindID, LLVMValueRef Node)
     * }
     */
    public static MemorySegment LLVMSetMetadata$address() {
        return LLVMSetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetMetadata(LLVMValueRef Val, unsigned int KindID, LLVMValueRef Node)
     * }
     */
    public static void LLVMSetMetadata(MemorySegment Val, int KindID, MemorySegment Node) {
        var mh$ = LLVMSetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetMetadata", Val, KindID, Node);
            }
            mh$.invokeExact(Val, KindID, Node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInstructionGetAllMetadataOtherThanDebugLoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstructionGetAllMetadataOtherThanDebugLoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMInstructionGetAllMetadataOtherThanDebugLoc(LLVMValueRef Instr, size_t *NumEntries)
     * }
     */
    public static FunctionDescriptor LLVMInstructionGetAllMetadataOtherThanDebugLoc$descriptor() {
        return LLVMInstructionGetAllMetadataOtherThanDebugLoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMInstructionGetAllMetadataOtherThanDebugLoc(LLVMValueRef Instr, size_t *NumEntries)
     * }
     */
    public static MethodHandle LLVMInstructionGetAllMetadataOtherThanDebugLoc$handle() {
        return LLVMInstructionGetAllMetadataOtherThanDebugLoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMInstructionGetAllMetadataOtherThanDebugLoc(LLVMValueRef Instr, size_t *NumEntries)
     * }
     */
    public static MemorySegment LLVMInstructionGetAllMetadataOtherThanDebugLoc$address() {
        return LLVMInstructionGetAllMetadataOtherThanDebugLoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMInstructionGetAllMetadataOtherThanDebugLoc(LLVMValueRef Instr, size_t *NumEntries)
     * }
     */
    public static MemorySegment LLVMInstructionGetAllMetadataOtherThanDebugLoc(MemorySegment Instr, MemorySegment NumEntries) {
        var mh$ = LLVMInstructionGetAllMetadataOtherThanDebugLoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstructionGetAllMetadataOtherThanDebugLoc", Instr, NumEntries);
            }
            return (MemorySegment)mh$.invokeExact(Instr, NumEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInstructionParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInstructionParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetInstructionParent$descriptor() {
        return LLVMGetInstructionParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetInstructionParent$handle() {
        return LLVMGetInstructionParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetInstructionParent$address() {
        return LLVMGetInstructionParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetInstructionParent(MemorySegment Inst) {
        var mh$ = LLVMGetInstructionParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInstructionParent", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetNextInstruction$descriptor() {
        return LLVMGetNextInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetNextInstruction$handle() {
        return LLVMGetNextInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetNextInstruction$address() {
        return LLVMGetNextInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetNextInstruction(MemorySegment Inst) {
        var mh$ = LLVMGetNextInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextInstruction", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousInstruction$descriptor() {
        return LLVMGetPreviousInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetPreviousInstruction$handle() {
        return LLVMGetPreviousInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetPreviousInstruction$address() {
        return LLVMGetPreviousInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetPreviousInstruction(MemorySegment Inst) {
        var mh$ = LLVMGetPreviousInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousInstruction", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInstructionRemoveFromParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstructionRemoveFromParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInstructionRemoveFromParent(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMInstructionRemoveFromParent$descriptor() {
        return LLVMInstructionRemoveFromParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInstructionRemoveFromParent(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMInstructionRemoveFromParent$handle() {
        return LLVMInstructionRemoveFromParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInstructionRemoveFromParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMInstructionRemoveFromParent$address() {
        return LLVMInstructionRemoveFromParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInstructionRemoveFromParent(LLVMValueRef Inst)
     * }
     */
    public static void LLVMInstructionRemoveFromParent(MemorySegment Inst) {
        var mh$ = LLVMInstructionRemoveFromParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstructionRemoveFromParent", Inst);
            }
            mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInstructionEraseFromParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstructionEraseFromParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInstructionEraseFromParent(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMInstructionEraseFromParent$descriptor() {
        return LLVMInstructionEraseFromParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInstructionEraseFromParent(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMInstructionEraseFromParent$handle() {
        return LLVMInstructionEraseFromParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInstructionEraseFromParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMInstructionEraseFromParent$address() {
        return LLVMInstructionEraseFromParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInstructionEraseFromParent(LLVMValueRef Inst)
     * }
     */
    public static void LLVMInstructionEraseFromParent(MemorySegment Inst) {
        var mh$ = LLVMInstructionEraseFromParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstructionEraseFromParent", Inst);
            }
            mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDeleteInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDeleteInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDeleteInstruction(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMDeleteInstruction$descriptor() {
        return LLVMDeleteInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDeleteInstruction(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMDeleteInstruction$handle() {
        return LLVMDeleteInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDeleteInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMDeleteInstruction$address() {
        return LLVMDeleteInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDeleteInstruction(LLVMValueRef Inst)
     * }
     */
    public static void LLVMDeleteInstruction(MemorySegment Inst) {
        var mh$ = LLVMDeleteInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDeleteInstruction", Inst);
            }
            mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInstructionOpcode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInstructionOpcode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetInstructionOpcode$descriptor() {
        return LLVMGetInstructionOpcode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetInstructionOpcode$handle() {
        return LLVMGetInstructionOpcode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetInstructionOpcode$address() {
        return LLVMGetInstructionOpcode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetInstructionOpcode(MemorySegment Inst) {
        var mh$ = LLVMGetInstructionOpcode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInstructionOpcode", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetICmpPredicate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetICmpPredicate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetICmpPredicate$descriptor() {
        return LLVMGetICmpPredicate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetICmpPredicate$handle() {
        return LLVMGetICmpPredicate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetICmpPredicate$address() {
        return LLVMGetICmpPredicate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetICmpPredicate(MemorySegment Inst) {
        var mh$ = LLVMGetICmpPredicate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetICmpPredicate", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFCmpPredicate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFCmpPredicate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetFCmpPredicate$descriptor() {
        return LLVMGetFCmpPredicate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetFCmpPredicate$handle() {
        return LLVMGetFCmpPredicate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetFCmpPredicate$address() {
        return LLVMGetFCmpPredicate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetFCmpPredicate(MemorySegment Inst) {
        var mh$ = LLVMGetFCmpPredicate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFCmpPredicate", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInstructionClone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstructionClone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMInstructionClone$descriptor() {
        return LLVMInstructionClone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMInstructionClone$handle() {
        return LLVMInstructionClone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMInstructionClone$address() {
        return LLVMInstructionClone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMInstructionClone(MemorySegment Inst) {
        var mh$ = LLVMInstructionClone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstructionClone", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsATerminatorInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsATerminatorInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMIsATerminatorInst$descriptor() {
        return LLVMIsATerminatorInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMIsATerminatorInst$handle() {
        return LLVMIsATerminatorInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMIsATerminatorInst$address() {
        return LLVMIsATerminatorInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMIsATerminatorInst(MemorySegment Inst) {
        var mh$ = LLVMIsATerminatorInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsATerminatorInst", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstDbgRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstDbgRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetFirstDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstDbgRecord$descriptor() {
        return LLVMGetFirstDbgRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetFirstDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetFirstDbgRecord$handle() {
        return LLVMGetFirstDbgRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetFirstDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetFirstDbgRecord$address() {
        return LLVMGetFirstDbgRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetFirstDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetFirstDbgRecord(MemorySegment Inst) {
        var mh$ = LLVMGetFirstDbgRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstDbgRecord", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastDbgRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastDbgRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetLastDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetLastDbgRecord$descriptor() {
        return LLVMGetLastDbgRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetLastDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetLastDbgRecord$handle() {
        return LLVMGetLastDbgRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetLastDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetLastDbgRecord$address() {
        return LLVMGetLastDbgRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetLastDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetLastDbgRecord(MemorySegment Inst) {
        var mh$ = LLVMGetLastDbgRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastDbgRecord", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextDbgRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextDbgRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetNextDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static FunctionDescriptor LLVMGetNextDbgRecord$descriptor() {
        return LLVMGetNextDbgRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetNextDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MethodHandle LLVMGetNextDbgRecord$handle() {
        return LLVMGetNextDbgRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetNextDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MemorySegment LLVMGetNextDbgRecord$address() {
        return LLVMGetNextDbgRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetNextDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MemorySegment LLVMGetNextDbgRecord(MemorySegment DbgRecord) {
        var mh$ = LLVMGetNextDbgRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextDbgRecord", DbgRecord);
            }
            return (MemorySegment)mh$.invokeExact(DbgRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousDbgRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousDbgRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetPreviousDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousDbgRecord$descriptor() {
        return LLVMGetPreviousDbgRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetPreviousDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MethodHandle LLVMGetPreviousDbgRecord$handle() {
        return LLVMGetPreviousDbgRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetPreviousDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MemorySegment LLVMGetPreviousDbgRecord$address() {
        return LLVMGetPreviousDbgRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetPreviousDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MemorySegment LLVMGetPreviousDbgRecord(MemorySegment DbgRecord) {
        var mh$ = LLVMGetPreviousDbgRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousDbgRecord", DbgRecord);
            }
            return (MemorySegment)mh$.invokeExact(DbgRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumArgOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumArgOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumArgOperands(LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMGetNumArgOperands$descriptor() {
        return LLVMGetNumArgOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumArgOperands(LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMGetNumArgOperands$handle() {
        return LLVMGetNumArgOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumArgOperands(LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMGetNumArgOperands$address() {
        return LLVMGetNumArgOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumArgOperands(LLVMValueRef Instr)
     * }
     */
    public static int LLVMGetNumArgOperands(MemorySegment Instr) {
        var mh$ = LLVMGetNumArgOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumArgOperands", Instr);
            }
            return (int)mh$.invokeExact(Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetInstructionCallConv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetInstructionCallConv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned int CC)
     * }
     */
    public static FunctionDescriptor LLVMSetInstructionCallConv$descriptor() {
        return LLVMSetInstructionCallConv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned int CC)
     * }
     */
    public static MethodHandle LLVMSetInstructionCallConv$handle() {
        return LLVMSetInstructionCallConv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned int CC)
     * }
     */
    public static MemorySegment LLVMSetInstructionCallConv$address() {
        return LLVMSetInstructionCallConv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned int CC)
     * }
     */
    public static void LLVMSetInstructionCallConv(MemorySegment Instr, int CC) {
        var mh$ = LLVMSetInstructionCallConv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetInstructionCallConv", Instr, CC);
            }
            mh$.invokeExact(Instr, CC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInstructionCallConv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInstructionCallConv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetInstructionCallConv(LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMGetInstructionCallConv$descriptor() {
        return LLVMGetInstructionCallConv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetInstructionCallConv(LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMGetInstructionCallConv$handle() {
        return LLVMGetInstructionCallConv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetInstructionCallConv(LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMGetInstructionCallConv$address() {
        return LLVMGetInstructionCallConv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetInstructionCallConv(LLVMValueRef Instr)
     * }
     */
    public static int LLVMGetInstructionCallConv(MemorySegment Instr) {
        var mh$ = LLVMGetInstructionCallConv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInstructionCallConv", Instr);
            }
            return (int)mh$.invokeExact(Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetInstrParamAlignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetInstrParamAlignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetInstrParamAlignment(LLVMValueRef Instr, LLVMAttributeIndex Idx, unsigned int Align)
     * }
     */
    public static FunctionDescriptor LLVMSetInstrParamAlignment$descriptor() {
        return LLVMSetInstrParamAlignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetInstrParamAlignment(LLVMValueRef Instr, LLVMAttributeIndex Idx, unsigned int Align)
     * }
     */
    public static MethodHandle LLVMSetInstrParamAlignment$handle() {
        return LLVMSetInstrParamAlignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetInstrParamAlignment(LLVMValueRef Instr, LLVMAttributeIndex Idx, unsigned int Align)
     * }
     */
    public static MemorySegment LLVMSetInstrParamAlignment$address() {
        return LLVMSetInstrParamAlignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetInstrParamAlignment(LLVMValueRef Instr, LLVMAttributeIndex Idx, unsigned int Align)
     * }
     */
    public static void LLVMSetInstrParamAlignment(MemorySegment Instr, int Idx, int Align) {
        var mh$ = LLVMSetInstrParamAlignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetInstrParamAlignment", Instr, Idx, Align);
            }
            mh$.invokeExact(Instr, Idx, Align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddCallSiteAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddCallSiteAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMAddCallSiteAttribute$descriptor() {
        return LLVMAddCallSiteAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMAddCallSiteAttribute$handle() {
        return LLVMAddCallSiteAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMAddCallSiteAttribute$address() {
        return LLVMAddCallSiteAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static void LLVMAddCallSiteAttribute(MemorySegment C, int Idx, MemorySegment A) {
        var mh$ = LLVMAddCallSiteAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddCallSiteAttribute", C, Idx, A);
            }
            mh$.invokeExact(C, Idx, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallSiteAttributeCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallSiteAttributeCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetCallSiteAttributeCount$descriptor() {
        return LLVMGetCallSiteAttributeCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx)
     * }
     */
    public static MethodHandle LLVMGetCallSiteAttributeCount$handle() {
        return LLVMGetCallSiteAttributeCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx)
     * }
     */
    public static MemorySegment LLVMGetCallSiteAttributeCount$address() {
        return LLVMGetCallSiteAttributeCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx)
     * }
     */
    public static int LLVMGetCallSiteAttributeCount(MemorySegment C, int Idx) {
        var mh$ = LLVMGetCallSiteAttributeCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallSiteAttributeCount", C, Idx);
            }
            return (int)mh$.invokeExact(C, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallSiteAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallSiteAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static FunctionDescriptor LLVMGetCallSiteAttributes$descriptor() {
        return LLVMGetCallSiteAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static MethodHandle LLVMGetCallSiteAttributes$handle() {
        return LLVMGetCallSiteAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static MemorySegment LLVMGetCallSiteAttributes$address() {
        return LLVMGetCallSiteAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static void LLVMGetCallSiteAttributes(MemorySegment C, int Idx, MemorySegment Attrs) {
        var mh$ = LLVMGetCallSiteAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallSiteAttributes", C, Idx, Attrs);
            }
            mh$.invokeExact(C, Idx, Attrs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallSiteEnumAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallSiteEnumAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMGetCallSiteEnumAttribute$descriptor() {
        return LLVMGetCallSiteEnumAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMGetCallSiteEnumAttribute$handle() {
        return LLVMGetCallSiteEnumAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetCallSiteEnumAttribute$address() {
        return LLVMGetCallSiteEnumAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetCallSiteEnumAttribute(MemorySegment C, int Idx, int KindID) {
        var mh$ = LLVMGetCallSiteEnumAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallSiteEnumAttribute", C, Idx, KindID);
            }
            return (MemorySegment)mh$.invokeExact(C, Idx, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallSiteStringAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallSiteStringAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static FunctionDescriptor LLVMGetCallSiteStringAttribute$descriptor() {
        return LLVMGetCallSiteStringAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MethodHandle LLVMGetCallSiteStringAttribute$handle() {
        return LLVMGetCallSiteStringAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMGetCallSiteStringAttribute$address() {
        return LLVMGetCallSiteStringAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMGetCallSiteStringAttribute(MemorySegment C, int Idx, MemorySegment K, int KLen) {
        var mh$ = LLVMGetCallSiteStringAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallSiteStringAttribute", C, Idx, K, KLen);
            }
            return (MemorySegment)mh$.invokeExact(C, Idx, K, KLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveCallSiteEnumAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveCallSiteEnumAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMRemoveCallSiteEnumAttribute$descriptor() {
        return LLVMRemoveCallSiteEnumAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMRemoveCallSiteEnumAttribute$handle() {
        return LLVMRemoveCallSiteEnumAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMRemoveCallSiteEnumAttribute$address() {
        return LLVMRemoveCallSiteEnumAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static void LLVMRemoveCallSiteEnumAttribute(MemorySegment C, int Idx, int KindID) {
        var mh$ = LLVMRemoveCallSiteEnumAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveCallSiteEnumAttribute", C, Idx, KindID);
            }
            mh$.invokeExact(C, Idx, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveCallSiteStringAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveCallSiteStringAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static FunctionDescriptor LLVMRemoveCallSiteStringAttribute$descriptor() {
        return LLVMRemoveCallSiteStringAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MethodHandle LLVMRemoveCallSiteStringAttribute$handle() {
        return LLVMRemoveCallSiteStringAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMRemoveCallSiteStringAttribute$address() {
        return LLVMRemoveCallSiteStringAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static void LLVMRemoveCallSiteStringAttribute(MemorySegment C, int Idx, MemorySegment K, int KLen) {
        var mh$ = LLVMRemoveCallSiteStringAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveCallSiteStringAttribute", C, Idx, K, KLen);
            }
            mh$.invokeExact(C, Idx, K, KLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCalledFunctionType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCalledFunctionType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetCalledFunctionType(LLVMValueRef C)
     * }
     */
    public static FunctionDescriptor LLVMGetCalledFunctionType$descriptor() {
        return LLVMGetCalledFunctionType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetCalledFunctionType(LLVMValueRef C)
     * }
     */
    public static MethodHandle LLVMGetCalledFunctionType$handle() {
        return LLVMGetCalledFunctionType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetCalledFunctionType(LLVMValueRef C)
     * }
     */
    public static MemorySegment LLVMGetCalledFunctionType$address() {
        return LLVMGetCalledFunctionType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetCalledFunctionType(LLVMValueRef C)
     * }
     */
    public static MemorySegment LLVMGetCalledFunctionType(MemorySegment C) {
        var mh$ = LLVMGetCalledFunctionType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCalledFunctionType", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCalledValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCalledValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMGetCalledValue$descriptor() {
        return LLVMGetCalledValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMGetCalledValue$handle() {
        return LLVMGetCalledValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMGetCalledValue$address() {
        return LLVMGetCalledValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMGetCalledValue(MemorySegment Instr) {
        var mh$ = LLVMGetCalledValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCalledValue", Instr);
            }
            return (MemorySegment)mh$.invokeExact(Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumOperandBundles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumOperandBundles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundles(LLVMValueRef C)
     * }
     */
    public static FunctionDescriptor LLVMGetNumOperandBundles$descriptor() {
        return LLVMGetNumOperandBundles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundles(LLVMValueRef C)
     * }
     */
    public static MethodHandle LLVMGetNumOperandBundles$handle() {
        return LLVMGetNumOperandBundles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundles(LLVMValueRef C)
     * }
     */
    public static MemorySegment LLVMGetNumOperandBundles$address() {
        return LLVMGetNumOperandBundles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundles(LLVMValueRef C)
     * }
     */
    public static int LLVMGetNumOperandBundles(MemorySegment C) {
        var mh$ = LLVMGetNumOperandBundles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumOperandBundles", C);
            }
            return (int)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOperandBundleAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOperandBundleAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMGetOperandBundleAtIndex(LLVMValueRef C, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetOperandBundleAtIndex$descriptor() {
        return LLVMGetOperandBundleAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMGetOperandBundleAtIndex(LLVMValueRef C, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetOperandBundleAtIndex$handle() {
        return LLVMGetOperandBundleAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMGetOperandBundleAtIndex(LLVMValueRef C, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleAtIndex$address() {
        return LLVMGetOperandBundleAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMGetOperandBundleAtIndex(LLVMValueRef C, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleAtIndex(MemorySegment C, int Index) {
        var mh$ = LLVMGetOperandBundleAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOperandBundleAtIndex", C, Index);
            }
            return (MemorySegment)mh$.invokeExact(C, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsTailCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsTailCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTailCall(LLVMValueRef CallInst)
     * }
     */
    public static FunctionDescriptor LLVMIsTailCall$descriptor() {
        return LLVMIsTailCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTailCall(LLVMValueRef CallInst)
     * }
     */
    public static MethodHandle LLVMIsTailCall$handle() {
        return LLVMIsTailCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTailCall(LLVMValueRef CallInst)
     * }
     */
    public static MemorySegment LLVMIsTailCall$address() {
        return LLVMIsTailCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsTailCall(LLVMValueRef CallInst)
     * }
     */
    public static int LLVMIsTailCall(MemorySegment CallInst) {
        var mh$ = LLVMIsTailCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsTailCall", CallInst);
            }
            return (int)mh$.invokeExact(CallInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTailCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTailCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall)
     * }
     */
    public static FunctionDescriptor LLVMSetTailCall$descriptor() {
        return LLVMSetTailCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall)
     * }
     */
    public static MethodHandle LLVMSetTailCall$handle() {
        return LLVMSetTailCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall)
     * }
     */
    public static MemorySegment LLVMSetTailCall$address() {
        return LLVMSetTailCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall)
     * }
     */
    public static void LLVMSetTailCall(MemorySegment CallInst, int IsTailCall) {
        var mh$ = LLVMSetTailCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTailCall", CallInst, IsTailCall);
            }
            mh$.invokeExact(CallInst, IsTailCall);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTailCallKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTailCallKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTailCallKind LLVMGetTailCallKind(LLVMValueRef CallInst)
     * }
     */
    public static FunctionDescriptor LLVMGetTailCallKind$descriptor() {
        return LLVMGetTailCallKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTailCallKind LLVMGetTailCallKind(LLVMValueRef CallInst)
     * }
     */
    public static MethodHandle LLVMGetTailCallKind$handle() {
        return LLVMGetTailCallKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTailCallKind LLVMGetTailCallKind(LLVMValueRef CallInst)
     * }
     */
    public static MemorySegment LLVMGetTailCallKind$address() {
        return LLVMGetTailCallKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTailCallKind LLVMGetTailCallKind(LLVMValueRef CallInst)
     * }
     */
    public static int LLVMGetTailCallKind(MemorySegment CallInst) {
        var mh$ = LLVMGetTailCallKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTailCallKind", CallInst);
            }
            return (int)mh$.invokeExact(CallInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTailCallKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTailCallKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTailCallKind(LLVMValueRef CallInst, LLVMTailCallKind kind)
     * }
     */
    public static FunctionDescriptor LLVMSetTailCallKind$descriptor() {
        return LLVMSetTailCallKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTailCallKind(LLVMValueRef CallInst, LLVMTailCallKind kind)
     * }
     */
    public static MethodHandle LLVMSetTailCallKind$handle() {
        return LLVMSetTailCallKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTailCallKind(LLVMValueRef CallInst, LLVMTailCallKind kind)
     * }
     */
    public static MemorySegment LLVMSetTailCallKind$address() {
        return LLVMSetTailCallKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTailCallKind(LLVMValueRef CallInst, LLVMTailCallKind kind)
     * }
     */
    public static void LLVMSetTailCallKind(MemorySegment CallInst, int kind) {
        var mh$ = LLVMSetTailCallKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTailCallKind", CallInst, kind);
            }
            mh$.invokeExact(CallInst, kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNormalDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNormalDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNormalDest$descriptor() {
        return LLVMGetNormalDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MethodHandle LLVMGetNormalDest$handle() {
        return LLVMGetNormalDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MemorySegment LLVMGetNormalDest$address() {
        return LLVMGetNormalDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MemorySegment LLVMGetNormalDest(MemorySegment InvokeInst) {
        var mh$ = LLVMGetNormalDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNormalDest", InvokeInst);
            }
            return (MemorySegment)mh$.invokeExact(InvokeInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetUnwindDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetUnwindDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst)
     * }
     */
    public static FunctionDescriptor LLVMGetUnwindDest$descriptor() {
        return LLVMGetUnwindDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MethodHandle LLVMGetUnwindDest$handle() {
        return LLVMGetUnwindDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MemorySegment LLVMGetUnwindDest$address() {
        return LLVMGetUnwindDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MemorySegment LLVMGetUnwindDest(MemorySegment InvokeInst) {
        var mh$ = LLVMGetUnwindDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetUnwindDest", InvokeInst);
            }
            return (MemorySegment)mh$.invokeExact(InvokeInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetNormalDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetNormalDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static FunctionDescriptor LLVMSetNormalDest$descriptor() {
        return LLVMSetNormalDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static MethodHandle LLVMSetNormalDest$handle() {
        return LLVMSetNormalDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static MemorySegment LLVMSetNormalDest$address() {
        return LLVMSetNormalDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static void LLVMSetNormalDest(MemorySegment InvokeInst, MemorySegment B) {
        var mh$ = LLVMSetNormalDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetNormalDest", InvokeInst, B);
            }
            mh$.invokeExact(InvokeInst, B);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetUnwindDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetUnwindDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static FunctionDescriptor LLVMSetUnwindDest$descriptor() {
        return LLVMSetUnwindDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static MethodHandle LLVMSetUnwindDest$handle() {
        return LLVMSetUnwindDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static MemorySegment LLVMSetUnwindDest$address() {
        return LLVMSetUnwindDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static void LLVMSetUnwindDest(MemorySegment InvokeInst, MemorySegment B) {
        var mh$ = LLVMSetUnwindDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetUnwindDest", InvokeInst, B);
            }
            mh$.invokeExact(InvokeInst, B);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallBrDefaultDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallBrDefaultDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrDefaultDest(LLVMValueRef CallBr)
     * }
     */
    public static FunctionDescriptor LLVMGetCallBrDefaultDest$descriptor() {
        return LLVMGetCallBrDefaultDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrDefaultDest(LLVMValueRef CallBr)
     * }
     */
    public static MethodHandle LLVMGetCallBrDefaultDest$handle() {
        return LLVMGetCallBrDefaultDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrDefaultDest(LLVMValueRef CallBr)
     * }
     */
    public static MemorySegment LLVMGetCallBrDefaultDest$address() {
        return LLVMGetCallBrDefaultDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrDefaultDest(LLVMValueRef CallBr)
     * }
     */
    public static MemorySegment LLVMGetCallBrDefaultDest(MemorySegment CallBr) {
        var mh$ = LLVMGetCallBrDefaultDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallBrDefaultDest", CallBr);
            }
            return (MemorySegment)mh$.invokeExact(CallBr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallBrNumIndirectDests {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallBrNumIndirectDests");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallBrNumIndirectDests(LLVMValueRef CallBr)
     * }
     */
    public static FunctionDescriptor LLVMGetCallBrNumIndirectDests$descriptor() {
        return LLVMGetCallBrNumIndirectDests.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallBrNumIndirectDests(LLVMValueRef CallBr)
     * }
     */
    public static MethodHandle LLVMGetCallBrNumIndirectDests$handle() {
        return LLVMGetCallBrNumIndirectDests.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallBrNumIndirectDests(LLVMValueRef CallBr)
     * }
     */
    public static MemorySegment LLVMGetCallBrNumIndirectDests$address() {
        return LLVMGetCallBrNumIndirectDests.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetCallBrNumIndirectDests(LLVMValueRef CallBr)
     * }
     */
    public static int LLVMGetCallBrNumIndirectDests(MemorySegment CallBr) {
        var mh$ = LLVMGetCallBrNumIndirectDests.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallBrNumIndirectDests", CallBr);
            }
            return (int)mh$.invokeExact(CallBr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallBrIndirectDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallBrIndirectDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrIndirectDest(LLVMValueRef CallBr, unsigned int Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetCallBrIndirectDest$descriptor() {
        return LLVMGetCallBrIndirectDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrIndirectDest(LLVMValueRef CallBr, unsigned int Idx)
     * }
     */
    public static MethodHandle LLVMGetCallBrIndirectDest$handle() {
        return LLVMGetCallBrIndirectDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrIndirectDest(LLVMValueRef CallBr, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetCallBrIndirectDest$address() {
        return LLVMGetCallBrIndirectDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrIndirectDest(LLVMValueRef CallBr, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetCallBrIndirectDest(MemorySegment CallBr, int Idx) {
        var mh$ = LLVMGetCallBrIndirectDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallBrIndirectDest", CallBr, Idx);
            }
            return (MemorySegment)mh$.invokeExact(CallBr, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumSuccessors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumSuccessors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumSuccessors(LLVMValueRef Term)
     * }
     */
    public static FunctionDescriptor LLVMGetNumSuccessors$descriptor() {
        return LLVMGetNumSuccessors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumSuccessors(LLVMValueRef Term)
     * }
     */
    public static MethodHandle LLVMGetNumSuccessors$handle() {
        return LLVMGetNumSuccessors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumSuccessors(LLVMValueRef Term)
     * }
     */
    public static MemorySegment LLVMGetNumSuccessors$address() {
        return LLVMGetNumSuccessors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumSuccessors(LLVMValueRef Term)
     * }
     */
    public static int LLVMGetNumSuccessors(MemorySegment Term) {
        var mh$ = LLVMGetNumSuccessors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumSuccessors", Term);
            }
            return (int)mh$.invokeExact(Term);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetSuccessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetSuccessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned int i)
     * }
     */
    public static FunctionDescriptor LLVMGetSuccessor$descriptor() {
        return LLVMGetSuccessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned int i)
     * }
     */
    public static MethodHandle LLVMGetSuccessor$handle() {
        return LLVMGetSuccessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned int i)
     * }
     */
    public static MemorySegment LLVMGetSuccessor$address() {
        return LLVMGetSuccessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned int i)
     * }
     */
    public static MemorySegment LLVMGetSuccessor(MemorySegment Term, int i) {
        var mh$ = LLVMGetSuccessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetSuccessor", Term, i);
            }
            return (MemorySegment)mh$.invokeExact(Term, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetSuccessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetSuccessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetSuccessor(LLVMValueRef Term, unsigned int i, LLVMBasicBlockRef block)
     * }
     */
    public static FunctionDescriptor LLVMSetSuccessor$descriptor() {
        return LLVMSetSuccessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetSuccessor(LLVMValueRef Term, unsigned int i, LLVMBasicBlockRef block)
     * }
     */
    public static MethodHandle LLVMSetSuccessor$handle() {
        return LLVMSetSuccessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetSuccessor(LLVMValueRef Term, unsigned int i, LLVMBasicBlockRef block)
     * }
     */
    public static MemorySegment LLVMSetSuccessor$address() {
        return LLVMSetSuccessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetSuccessor(LLVMValueRef Term, unsigned int i, LLVMBasicBlockRef block)
     * }
     */
    public static void LLVMSetSuccessor(MemorySegment Term, int i, MemorySegment block) {
        var mh$ = LLVMSetSuccessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetSuccessor", Term, i, block);
            }
            mh$.invokeExact(Term, i, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsConditional {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsConditional");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConditional(LLVMValueRef Branch)
     * }
     */
    public static FunctionDescriptor LLVMIsConditional$descriptor() {
        return LLVMIsConditional.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConditional(LLVMValueRef Branch)
     * }
     */
    public static MethodHandle LLVMIsConditional$handle() {
        return LLVMIsConditional.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConditional(LLVMValueRef Branch)
     * }
     */
    public static MemorySegment LLVMIsConditional$address() {
        return LLVMIsConditional.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsConditional(LLVMValueRef Branch)
     * }
     */
    public static int LLVMIsConditional(MemorySegment Branch) {
        var mh$ = LLVMIsConditional.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsConditional", Branch);
            }
            return (int)mh$.invokeExact(Branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCondition(LLVMValueRef Branch)
     * }
     */
    public static FunctionDescriptor LLVMGetCondition$descriptor() {
        return LLVMGetCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCondition(LLVMValueRef Branch)
     * }
     */
    public static MethodHandle LLVMGetCondition$handle() {
        return LLVMGetCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCondition(LLVMValueRef Branch)
     * }
     */
    public static MemorySegment LLVMGetCondition$address() {
        return LLVMGetCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCondition(LLVMValueRef Branch)
     * }
     */
    public static MemorySegment LLVMGetCondition(MemorySegment Branch) {
        var mh$ = LLVMGetCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCondition", Branch);
            }
            return (MemorySegment)mh$.invokeExact(Branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond)
     * }
     */
    public static FunctionDescriptor LLVMSetCondition$descriptor() {
        return LLVMSetCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond)
     * }
     */
    public static MethodHandle LLVMSetCondition$handle() {
        return LLVMSetCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond)
     * }
     */
    public static MemorySegment LLVMSetCondition$address() {
        return LLVMSetCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond)
     * }
     */
    public static void LLVMSetCondition(MemorySegment Branch, MemorySegment Cond) {
        var mh$ = LLVMSetCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCondition", Branch, Cond);
            }
            mh$.invokeExact(Branch, Cond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetSwitchDefaultDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetSwitchDefaultDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr)
     * }
     */
    public static FunctionDescriptor LLVMGetSwitchDefaultDest$descriptor() {
        return LLVMGetSwitchDefaultDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr)
     * }
     */
    public static MethodHandle LLVMGetSwitchDefaultDest$handle() {
        return LLVMGetSwitchDefaultDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr)
     * }
     */
    public static MemorySegment LLVMGetSwitchDefaultDest$address() {
        return LLVMGetSwitchDefaultDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr)
     * }
     */
    public static MemorySegment LLVMGetSwitchDefaultDest(MemorySegment SwitchInstr) {
        var mh$ = LLVMGetSwitchDefaultDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetSwitchDefaultDest", SwitchInstr);
            }
            return (MemorySegment)mh$.invokeExact(SwitchInstr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAllocatedType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAllocatedType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca)
     * }
     */
    public static FunctionDescriptor LLVMGetAllocatedType$descriptor() {
        return LLVMGetAllocatedType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca)
     * }
     */
    public static MethodHandle LLVMGetAllocatedType$handle() {
        return LLVMGetAllocatedType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca)
     * }
     */
    public static MemorySegment LLVMGetAllocatedType$address() {
        return LLVMGetAllocatedType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca)
     * }
     */
    public static MemorySegment LLVMGetAllocatedType(MemorySegment Alloca) {
        var mh$ = LLVMGetAllocatedType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAllocatedType", Alloca);
            }
            return (MemorySegment)mh$.invokeExact(Alloca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsInBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsInBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsInBounds(LLVMValueRef GEP)
     * }
     */
    public static FunctionDescriptor LLVMIsInBounds$descriptor() {
        return LLVMIsInBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsInBounds(LLVMValueRef GEP)
     * }
     */
    public static MethodHandle LLVMIsInBounds$handle() {
        return LLVMIsInBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsInBounds(LLVMValueRef GEP)
     * }
     */
    public static MemorySegment LLVMIsInBounds$address() {
        return LLVMIsInBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsInBounds(LLVMValueRef GEP)
     * }
     */
    public static int LLVMIsInBounds(MemorySegment GEP) {
        var mh$ = LLVMIsInBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsInBounds", GEP);
            }
            return (int)mh$.invokeExact(GEP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetIsInBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetIsInBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds)
     * }
     */
    public static FunctionDescriptor LLVMSetIsInBounds$descriptor() {
        return LLVMSetIsInBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds)
     * }
     */
    public static MethodHandle LLVMSetIsInBounds$handle() {
        return LLVMSetIsInBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds)
     * }
     */
    public static MemorySegment LLVMSetIsInBounds$address() {
        return LLVMSetIsInBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds)
     * }
     */
    public static void LLVMSetIsInBounds(MemorySegment GEP, int InBounds) {
        var mh$ = LLVMSetIsInBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetIsInBounds", GEP, InBounds);
            }
            mh$.invokeExact(GEP, InBounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetGEPSourceElementType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetGEPSourceElementType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetGEPSourceElementType(LLVMValueRef GEP)
     * }
     */
    public static FunctionDescriptor LLVMGetGEPSourceElementType$descriptor() {
        return LLVMGetGEPSourceElementType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetGEPSourceElementType(LLVMValueRef GEP)
     * }
     */
    public static MethodHandle LLVMGetGEPSourceElementType$handle() {
        return LLVMGetGEPSourceElementType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetGEPSourceElementType(LLVMValueRef GEP)
     * }
     */
    public static MemorySegment LLVMGetGEPSourceElementType$address() {
        return LLVMGetGEPSourceElementType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetGEPSourceElementType(LLVMValueRef GEP)
     * }
     */
    public static MemorySegment LLVMGetGEPSourceElementType(MemorySegment GEP) {
        var mh$ = LLVMGetGEPSourceElementType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetGEPSourceElementType", GEP);
            }
            return (MemorySegment)mh$.invokeExact(GEP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGEPGetNoWrapFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGEPGetNoWrapFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMGEPNoWrapFlags LLVMGEPGetNoWrapFlags(LLVMValueRef GEP)
     * }
     */
    public static FunctionDescriptor LLVMGEPGetNoWrapFlags$descriptor() {
        return LLVMGEPGetNoWrapFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMGEPNoWrapFlags LLVMGEPGetNoWrapFlags(LLVMValueRef GEP)
     * }
     */
    public static MethodHandle LLVMGEPGetNoWrapFlags$handle() {
        return LLVMGEPGetNoWrapFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMGEPNoWrapFlags LLVMGEPGetNoWrapFlags(LLVMValueRef GEP)
     * }
     */
    public static MemorySegment LLVMGEPGetNoWrapFlags$address() {
        return LLVMGEPGetNoWrapFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMGEPNoWrapFlags LLVMGEPGetNoWrapFlags(LLVMValueRef GEP)
     * }
     */
    public static int LLVMGEPGetNoWrapFlags(MemorySegment GEP) {
        var mh$ = LLVMGEPGetNoWrapFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGEPGetNoWrapFlags", GEP);
            }
            return (int)mh$.invokeExact(GEP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGEPSetNoWrapFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGEPSetNoWrapFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGEPSetNoWrapFlags(LLVMValueRef GEP, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static FunctionDescriptor LLVMGEPSetNoWrapFlags$descriptor() {
        return LLVMGEPSetNoWrapFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGEPSetNoWrapFlags(LLVMValueRef GEP, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MethodHandle LLVMGEPSetNoWrapFlags$handle() {
        return LLVMGEPSetNoWrapFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGEPSetNoWrapFlags(LLVMValueRef GEP, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MemorySegment LLVMGEPSetNoWrapFlags$address() {
        return LLVMGEPSetNoWrapFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGEPSetNoWrapFlags(LLVMValueRef GEP, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static void LLVMGEPSetNoWrapFlags(MemorySegment GEP, int NoWrapFlags) {
        var mh$ = LLVMGEPSetNoWrapFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGEPSetNoWrapFlags", GEP, NoWrapFlags);
            }
            mh$.invokeExact(GEP, NoWrapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddIncoming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddIncoming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues, LLVMBasicBlockRef *IncomingBlocks, unsigned int Count)
     * }
     */
    public static FunctionDescriptor LLVMAddIncoming$descriptor() {
        return LLVMAddIncoming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues, LLVMBasicBlockRef *IncomingBlocks, unsigned int Count)
     * }
     */
    public static MethodHandle LLVMAddIncoming$handle() {
        return LLVMAddIncoming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues, LLVMBasicBlockRef *IncomingBlocks, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMAddIncoming$address() {
        return LLVMAddIncoming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues, LLVMBasicBlockRef *IncomingBlocks, unsigned int Count)
     * }
     */
    public static void LLVMAddIncoming(MemorySegment PhiNode, MemorySegment IncomingValues, MemorySegment IncomingBlocks, int Count) {
        var mh$ = LLVMAddIncoming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddIncoming", PhiNode, IncomingValues, IncomingBlocks, Count);
            }
            mh$.invokeExact(PhiNode, IncomingValues, IncomingBlocks, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCountIncoming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCountIncoming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCountIncoming(LLVMValueRef PhiNode)
     * }
     */
    public static FunctionDescriptor LLVMCountIncoming$descriptor() {
        return LLVMCountIncoming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCountIncoming(LLVMValueRef PhiNode)
     * }
     */
    public static MethodHandle LLVMCountIncoming$handle() {
        return LLVMCountIncoming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCountIncoming(LLVMValueRef PhiNode)
     * }
     */
    public static MemorySegment LLVMCountIncoming$address() {
        return LLVMCountIncoming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCountIncoming(LLVMValueRef PhiNode)
     * }
     */
    public static int LLVMCountIncoming(MemorySegment PhiNode) {
        var mh$ = LLVMCountIncoming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCountIncoming", PhiNode);
            }
            return (int)mh$.invokeExact(PhiNode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIncomingValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIncomingValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetIncomingValue$descriptor() {
        return LLVMGetIncomingValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetIncomingValue$handle() {
        return LLVMGetIncomingValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetIncomingValue$address() {
        return LLVMGetIncomingValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetIncomingValue(MemorySegment PhiNode, int Index) {
        var mh$ = LLVMGetIncomingValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIncomingValue", PhiNode, Index);
            }
            return (MemorySegment)mh$.invokeExact(PhiNode, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIncomingBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIncomingBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetIncomingBlock$descriptor() {
        return LLVMGetIncomingBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetIncomingBlock$handle() {
        return LLVMGetIncomingBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetIncomingBlock$address() {
        return LLVMGetIncomingBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetIncomingBlock(MemorySegment PhiNode, int Index) {
        var mh$ = LLVMGetIncomingBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIncomingBlock", PhiNode, Index);
            }
            return (MemorySegment)mh$.invokeExact(PhiNode, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumIndices(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetNumIndices$descriptor() {
        return LLVMGetNumIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumIndices(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetNumIndices$handle() {
        return LLVMGetNumIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumIndices(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetNumIndices$address() {
        return LLVMGetNumIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumIndices(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetNumIndices(MemorySegment Inst) {
        var mh$ = LLVMGetNumIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumIndices", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const unsigned int *LLVMGetIndices(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetIndices$descriptor() {
        return LLVMGetIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const unsigned int *LLVMGetIndices(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetIndices$handle() {
        return LLVMGetIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const unsigned int *LLVMGetIndices(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetIndices$address() {
        return LLVMGetIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const unsigned int *LLVMGetIndices(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetIndices(MemorySegment Inst) {
        var mh$ = LLVMGetIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIndices", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateBuilderInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateBuilderInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMCreateBuilderInContext$descriptor() {
        return LLVMCreateBuilderInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMCreateBuilderInContext$handle() {
        return LLVMCreateBuilderInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMCreateBuilderInContext$address() {
        return LLVMCreateBuilderInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMCreateBuilderInContext(MemorySegment C) {
        var mh$ = LLVMCreateBuilderInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateBuilderInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateBuilder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateBuilder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilder()
     * }
     */
    public static FunctionDescriptor LLVMCreateBuilder$descriptor() {
        return LLVMCreateBuilder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilder()
     * }
     */
    public static MethodHandle LLVMCreateBuilder$handle() {
        return LLVMCreateBuilder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilder()
     * }
     */
    public static MemorySegment LLVMCreateBuilder$address() {
        return LLVMCreateBuilder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilder()
     * }
     */
    public static MemorySegment LLVMCreateBuilder() {
        var mh$ = LLVMCreateBuilder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateBuilder");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilder$descriptor() {
        return LLVMPositionBuilder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMPositionBuilder$handle() {
        return LLVMPositionBuilder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMPositionBuilder$address() {
        return LLVMPositionBuilder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr)
     * }
     */
    public static void LLVMPositionBuilder(MemorySegment Builder, MemorySegment Block, MemorySegment Instr) {
        var mh$ = LLVMPositionBuilder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilder", Builder, Block, Instr);
            }
            mh$.invokeExact(Builder, Block, Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilderBeforeDbgRecords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilderBeforeDbgRecords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeDbgRecords(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilderBeforeDbgRecords$descriptor() {
        return LLVMPositionBuilderBeforeDbgRecords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeDbgRecords(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMPositionBuilderBeforeDbgRecords$handle() {
        return LLVMPositionBuilderBeforeDbgRecords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeDbgRecords(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMPositionBuilderBeforeDbgRecords$address() {
        return LLVMPositionBuilderBeforeDbgRecords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeDbgRecords(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Inst)
     * }
     */
    public static void LLVMPositionBuilderBeforeDbgRecords(MemorySegment Builder, MemorySegment Block, MemorySegment Inst) {
        var mh$ = LLVMPositionBuilderBeforeDbgRecords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilderBeforeDbgRecords", Builder, Block, Inst);
            }
            mh$.invokeExact(Builder, Block, Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilderBefore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilderBefore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilderBefore$descriptor() {
        return LLVMPositionBuilderBefore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMPositionBuilderBefore$handle() {
        return LLVMPositionBuilderBefore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMPositionBuilderBefore$address() {
        return LLVMPositionBuilderBefore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static void LLVMPositionBuilderBefore(MemorySegment Builder, MemorySegment Instr) {
        var mh$ = LLVMPositionBuilderBefore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilderBefore", Builder, Instr);
            }
            mh$.invokeExact(Builder, Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilderBeforeInstrAndDbgRecords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilderBeforeInstrAndDbgRecords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilderBeforeInstrAndDbgRecords$descriptor() {
        return LLVMPositionBuilderBeforeInstrAndDbgRecords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMPositionBuilderBeforeInstrAndDbgRecords$handle() {
        return LLVMPositionBuilderBeforeInstrAndDbgRecords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMPositionBuilderBeforeInstrAndDbgRecords$address() {
        return LLVMPositionBuilderBeforeInstrAndDbgRecords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static void LLVMPositionBuilderBeforeInstrAndDbgRecords(MemorySegment Builder, MemorySegment Instr) {
        var mh$ = LLVMPositionBuilderBeforeInstrAndDbgRecords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilderBeforeInstrAndDbgRecords", Builder, Instr);
            }
            mh$.invokeExact(Builder, Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilderAtEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilderAtEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilderAtEnd$descriptor() {
        return LLVMPositionBuilderAtEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block)
     * }
     */
    public static MethodHandle LLVMPositionBuilderAtEnd$handle() {
        return LLVMPositionBuilderAtEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block)
     * }
     */
    public static MemorySegment LLVMPositionBuilderAtEnd$address() {
        return LLVMPositionBuilderAtEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block)
     * }
     */
    public static void LLVMPositionBuilderAtEnd(MemorySegment Builder, MemorySegment Block) {
        var mh$ = LLVMPositionBuilderAtEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilderAtEnd", Builder, Block);
            }
            mh$.invokeExact(Builder, Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInsertBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInsertBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMGetInsertBlock$descriptor() {
        return LLVMGetInsertBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMGetInsertBlock$handle() {
        return LLVMGetInsertBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetInsertBlock$address() {
        return LLVMGetInsertBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetInsertBlock(MemorySegment Builder) {
        var mh$ = LLVMGetInsertBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInsertBlock", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMClearInsertionPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMClearInsertionPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMClearInsertionPosition(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMClearInsertionPosition$descriptor() {
        return LLVMClearInsertionPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMClearInsertionPosition(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMClearInsertionPosition$handle() {
        return LLVMClearInsertionPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMClearInsertionPosition(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMClearInsertionPosition$address() {
        return LLVMClearInsertionPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMClearInsertionPosition(LLVMBuilderRef Builder)
     * }
     */
    public static void LLVMClearInsertionPosition(MemorySegment Builder) {
        var mh$ = LLVMClearInsertionPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMClearInsertionPosition", Builder);
            }
            mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertIntoBuilder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertIntoBuilder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMInsertIntoBuilder$descriptor() {
        return LLVMInsertIntoBuilder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMInsertIntoBuilder$handle() {
        return LLVMInsertIntoBuilder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMInsertIntoBuilder$address() {
        return LLVMInsertIntoBuilder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static void LLVMInsertIntoBuilder(MemorySegment Builder, MemorySegment Instr) {
        var mh$ = LLVMInsertIntoBuilder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertIntoBuilder", Builder, Instr);
            }
            mh$.invokeExact(Builder, Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertIntoBuilderWithName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertIntoBuilderWithName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMInsertIntoBuilderWithName$descriptor() {
        return LLVMInsertIntoBuilderWithName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr, const char *Name)
     * }
     */
    public static MethodHandle LLVMInsertIntoBuilderWithName$handle() {
        return LLVMInsertIntoBuilderWithName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertIntoBuilderWithName$address() {
        return LLVMInsertIntoBuilderWithName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr, const char *Name)
     * }
     */
    public static void LLVMInsertIntoBuilderWithName(MemorySegment Builder, MemorySegment Instr, MemorySegment Name) {
        var mh$ = LLVMInsertIntoBuilderWithName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertIntoBuilderWithName", Builder, Instr, Name);
            }
            mh$.invokeExact(Builder, Instr, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeBuilder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeBuilder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeBuilder(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMDisposeBuilder$descriptor() {
        return LLVMDisposeBuilder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeBuilder(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMDisposeBuilder$handle() {
        return LLVMDisposeBuilder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeBuilder(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMDisposeBuilder$address() {
        return LLVMDisposeBuilder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeBuilder(LLVMBuilderRef Builder)
     * }
     */
    public static void LLVMDisposeBuilder(MemorySegment Builder) {
        var mh$ = LLVMDisposeBuilder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeBuilder", Builder);
            }
            mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCurrentDebugLocation2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCurrentDebugLocation2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetCurrentDebugLocation2(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMGetCurrentDebugLocation2$descriptor() {
        return LLVMGetCurrentDebugLocation2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetCurrentDebugLocation2(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMGetCurrentDebugLocation2$handle() {
        return LLVMGetCurrentDebugLocation2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetCurrentDebugLocation2(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetCurrentDebugLocation2$address() {
        return LLVMGetCurrentDebugLocation2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetCurrentDebugLocation2(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetCurrentDebugLocation2(MemorySegment Builder) {
        var mh$ = LLVMGetCurrentDebugLocation2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCurrentDebugLocation2", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCurrentDebugLocation2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCurrentDebugLocation2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation2(LLVMBuilderRef Builder, LLVMMetadataRef Loc)
     * }
     */
    public static FunctionDescriptor LLVMSetCurrentDebugLocation2$descriptor() {
        return LLVMSetCurrentDebugLocation2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation2(LLVMBuilderRef Builder, LLVMMetadataRef Loc)
     * }
     */
    public static MethodHandle LLVMSetCurrentDebugLocation2$handle() {
        return LLVMSetCurrentDebugLocation2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation2(LLVMBuilderRef Builder, LLVMMetadataRef Loc)
     * }
     */
    public static MemorySegment LLVMSetCurrentDebugLocation2$address() {
        return LLVMSetCurrentDebugLocation2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation2(LLVMBuilderRef Builder, LLVMMetadataRef Loc)
     * }
     */
    public static void LLVMSetCurrentDebugLocation2(MemorySegment Builder, MemorySegment Loc) {
        var mh$ = LLVMSetCurrentDebugLocation2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCurrentDebugLocation2", Builder, Loc);
            }
            mh$.invokeExact(Builder, Loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetInstDebugLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetInstDebugLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMSetInstDebugLocation$descriptor() {
        return LLVMSetInstDebugLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMSetInstDebugLocation$handle() {
        return LLVMSetInstDebugLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMSetInstDebugLocation$address() {
        return LLVMSetInstDebugLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static void LLVMSetInstDebugLocation(MemorySegment Builder, MemorySegment Inst) {
        var mh$ = LLVMSetInstDebugLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetInstDebugLocation", Builder, Inst);
            }
            mh$.invokeExact(Builder, Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddMetadataToInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddMetadataToInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddMetadataToInst(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMAddMetadataToInst$descriptor() {
        return LLVMAddMetadataToInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddMetadataToInst(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMAddMetadataToInst$handle() {
        return LLVMAddMetadataToInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddMetadataToInst(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMAddMetadataToInst$address() {
        return LLVMAddMetadataToInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddMetadataToInst(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static void LLVMAddMetadataToInst(MemorySegment Builder, MemorySegment Inst) {
        var mh$ = LLVMAddMetadataToInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddMetadataToInst", Builder, Inst);
            }
            mh$.invokeExact(Builder, Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuilderGetDefaultFPMathTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuilderGetDefaultFPMathTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMBuilderGetDefaultFPMathTag(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMBuilderGetDefaultFPMathTag$descriptor() {
        return LLVMBuilderGetDefaultFPMathTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMBuilderGetDefaultFPMathTag(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMBuilderGetDefaultFPMathTag$handle() {
        return LLVMBuilderGetDefaultFPMathTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMBuilderGetDefaultFPMathTag(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMBuilderGetDefaultFPMathTag$address() {
        return LLVMBuilderGetDefaultFPMathTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMBuilderGetDefaultFPMathTag(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMBuilderGetDefaultFPMathTag(MemorySegment Builder) {
        var mh$ = LLVMBuilderGetDefaultFPMathTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuilderGetDefaultFPMathTag", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuilderSetDefaultFPMathTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuilderSetDefaultFPMathTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMBuilderSetDefaultFPMathTag(LLVMBuilderRef Builder, LLVMMetadataRef FPMathTag)
     * }
     */
    public static FunctionDescriptor LLVMBuilderSetDefaultFPMathTag$descriptor() {
        return LLVMBuilderSetDefaultFPMathTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMBuilderSetDefaultFPMathTag(LLVMBuilderRef Builder, LLVMMetadataRef FPMathTag)
     * }
     */
    public static MethodHandle LLVMBuilderSetDefaultFPMathTag$handle() {
        return LLVMBuilderSetDefaultFPMathTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMBuilderSetDefaultFPMathTag(LLVMBuilderRef Builder, LLVMMetadataRef FPMathTag)
     * }
     */
    public static MemorySegment LLVMBuilderSetDefaultFPMathTag$address() {
        return LLVMBuilderSetDefaultFPMathTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMBuilderSetDefaultFPMathTag(LLVMBuilderRef Builder, LLVMMetadataRef FPMathTag)
     * }
     */
    public static void LLVMBuilderSetDefaultFPMathTag(MemorySegment Builder, MemorySegment FPMathTag) {
        var mh$ = LLVMBuilderSetDefaultFPMathTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuilderSetDefaultFPMathTag", Builder, FPMathTag);
            }
            mh$.invokeExact(Builder, FPMathTag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBuilderContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBuilderContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetBuilderContext(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMGetBuilderContext$descriptor() {
        return LLVMGetBuilderContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetBuilderContext(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMGetBuilderContext$handle() {
        return LLVMGetBuilderContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetBuilderContext(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetBuilderContext$address() {
        return LLVMGetBuilderContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetBuilderContext(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetBuilderContext(MemorySegment Builder) {
        var mh$ = LLVMGetBuilderContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBuilderContext", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCurrentDebugLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCurrentDebugLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L)
     * }
     */
    public static FunctionDescriptor LLVMSetCurrentDebugLocation$descriptor() {
        return LLVMSetCurrentDebugLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L)
     * }
     */
    public static MethodHandle LLVMSetCurrentDebugLocation$handle() {
        return LLVMSetCurrentDebugLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L)
     * }
     */
    public static MemorySegment LLVMSetCurrentDebugLocation$address() {
        return LLVMSetCurrentDebugLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L)
     * }
     */
    public static void LLVMSetCurrentDebugLocation(MemorySegment Builder, MemorySegment L) {
        var mh$ = LLVMSetCurrentDebugLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCurrentDebugLocation", Builder, L);
            }
            mh$.invokeExact(Builder, L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCurrentDebugLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCurrentDebugLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMGetCurrentDebugLocation$descriptor() {
        return LLVMGetCurrentDebugLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMGetCurrentDebugLocation$handle() {
        return LLVMGetCurrentDebugLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetCurrentDebugLocation$address() {
        return LLVMGetCurrentDebugLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetCurrentDebugLocation(MemorySegment Builder) {
        var mh$ = LLVMGetCurrentDebugLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCurrentDebugLocation", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildRetVoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildRetVoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)
     * }
     */
    public static FunctionDescriptor LLVMBuildRetVoid$descriptor() {
        return LLVMBuildRetVoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)
     * }
     */
    public static MethodHandle LLVMBuildRetVoid$handle() {
        return LLVMBuildRetVoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)
     * }
     */
    public static MemorySegment LLVMBuildRetVoid$address() {
        return LLVMBuildRetVoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)
     * }
     */
    public static MemorySegment LLVMBuildRetVoid(MemorySegment x0) {
        var mh$ = LLVMBuildRetVoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildRetVoid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildRet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildRet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V)
     * }
     */
    public static FunctionDescriptor LLVMBuildRet$descriptor() {
        return LLVMBuildRet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V)
     * }
     */
    public static MethodHandle LLVMBuildRet$handle() {
        return LLVMBuildRet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V)
     * }
     */
    public static MemorySegment LLVMBuildRet$address() {
        return LLVMBuildRet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V)
     * }
     */
    public static MemorySegment LLVMBuildRet(MemorySegment x0, MemorySegment V) {
        var mh$ = LLVMBuildRet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildRet", x0, V);
            }
            return (MemorySegment)mh$.invokeExact(x0, V);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAggregateRet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAggregateRet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals, unsigned int N)
     * }
     */
    public static FunctionDescriptor LLVMBuildAggregateRet$descriptor() {
        return LLVMBuildAggregateRet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals, unsigned int N)
     * }
     */
    public static MethodHandle LLVMBuildAggregateRet$handle() {
        return LLVMBuildAggregateRet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals, unsigned int N)
     * }
     */
    public static MemorySegment LLVMBuildAggregateRet$address() {
        return LLVMBuildAggregateRet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals, unsigned int N)
     * }
     */
    public static MemorySegment LLVMBuildAggregateRet(MemorySegment x0, MemorySegment RetVals, int N) {
        var mh$ = LLVMBuildAggregateRet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAggregateRet", x0, RetVals, N);
            }
            return (MemorySegment)mh$.invokeExact(x0, RetVals, N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildBr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildBr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest)
     * }
     */
    public static FunctionDescriptor LLVMBuildBr$descriptor() {
        return LLVMBuildBr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest)
     * }
     */
    public static MethodHandle LLVMBuildBr$handle() {
        return LLVMBuildBr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMBuildBr$address() {
        return LLVMBuildBr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMBuildBr(MemorySegment x0, MemorySegment Dest) {
        var mh$ = LLVMBuildBr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildBr", x0, Dest);
            }
            return (MemorySegment)mh$.invokeExact(x0, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCondBr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCondBr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else)
     * }
     */
    public static FunctionDescriptor LLVMBuildCondBr$descriptor() {
        return LLVMBuildCondBr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else)
     * }
     */
    public static MethodHandle LLVMBuildCondBr$handle() {
        return LLVMBuildCondBr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else)
     * }
     */
    public static MemorySegment LLVMBuildCondBr$address() {
        return LLVMBuildCondBr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else)
     * }
     */
    public static MemorySegment LLVMBuildCondBr(MemorySegment x0, MemorySegment If, MemorySegment Then, MemorySegment Else) {
        var mh$ = LLVMBuildCondBr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCondBr", x0, If, Then, Else);
            }
            return (MemorySegment)mh$.invokeExact(x0, If, Then, Else);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSwitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSwitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V, LLVMBasicBlockRef Else, unsigned int NumCases)
     * }
     */
    public static FunctionDescriptor LLVMBuildSwitch$descriptor() {
        return LLVMBuildSwitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V, LLVMBasicBlockRef Else, unsigned int NumCases)
     * }
     */
    public static MethodHandle LLVMBuildSwitch$handle() {
        return LLVMBuildSwitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V, LLVMBasicBlockRef Else, unsigned int NumCases)
     * }
     */
    public static MemorySegment LLVMBuildSwitch$address() {
        return LLVMBuildSwitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V, LLVMBasicBlockRef Else, unsigned int NumCases)
     * }
     */
    public static MemorySegment LLVMBuildSwitch(MemorySegment x0, MemorySegment V, MemorySegment Else, int NumCases) {
        var mh$ = LLVMBuildSwitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSwitch", x0, V, Else, NumCases);
            }
            return (MemorySegment)mh$.invokeExact(x0, V, Else, NumCases);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIndirectBr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIndirectBr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr, unsigned int NumDests)
     * }
     */
    public static FunctionDescriptor LLVMBuildIndirectBr$descriptor() {
        return LLVMBuildIndirectBr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr, unsigned int NumDests)
     * }
     */
    public static MethodHandle LLVMBuildIndirectBr$handle() {
        return LLVMBuildIndirectBr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr, unsigned int NumDests)
     * }
     */
    public static MemorySegment LLVMBuildIndirectBr$address() {
        return LLVMBuildIndirectBr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr, unsigned int NumDests)
     * }
     */
    public static MemorySegment LLVMBuildIndirectBr(MemorySegment B, MemorySegment Addr, int NumDests) {
        var mh$ = LLVMBuildIndirectBr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIndirectBr", B, Addr, NumDests);
            }
            return (MemorySegment)mh$.invokeExact(B, Addr, NumDests);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCallBr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCallBr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallBr(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMBasicBlockRef DefaultDest, LLVMBasicBlockRef *IndirectDests, unsigned int NumIndirectDests, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCallBr$descriptor() {
        return LLVMBuildCallBr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallBr(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMBasicBlockRef DefaultDest, LLVMBasicBlockRef *IndirectDests, unsigned int NumIndirectDests, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCallBr$handle() {
        return LLVMBuildCallBr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallBr(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMBasicBlockRef DefaultDest, LLVMBasicBlockRef *IndirectDests, unsigned int NumIndirectDests, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCallBr$address() {
        return LLVMBuildCallBr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallBr(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMBasicBlockRef DefaultDest, LLVMBasicBlockRef *IndirectDests, unsigned int NumIndirectDests, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCallBr(MemorySegment B, MemorySegment Ty, MemorySegment Fn, MemorySegment DefaultDest, MemorySegment IndirectDests, int NumIndirectDests, MemorySegment Args, int NumArgs, MemorySegment Bundles, int NumBundles, MemorySegment Name) {
        var mh$ = LLVMBuildCallBr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCallBr", B, Ty, Fn, DefaultDest, IndirectDests, NumIndirectDests, Args, NumArgs, Bundles, NumBundles, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Fn, DefaultDest, IndirectDests, NumIndirectDests, Args, NumArgs, Bundles, NumBundles, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInvoke2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInvoke2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvoke2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInvoke2$descriptor() {
        return LLVMBuildInvoke2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvoke2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInvoke2$handle() {
        return LLVMBuildInvoke2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvoke2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInvoke2$address() {
        return LLVMBuildInvoke2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvoke2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInvoke2(MemorySegment x0, MemorySegment Ty, MemorySegment Fn, MemorySegment Args, int NumArgs, MemorySegment Then, MemorySegment Catch, MemorySegment Name) {
        var mh$ = LLVMBuildInvoke2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInvoke2", x0, Ty, Fn, Args, NumArgs, Then, Catch, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Fn, Args, NumArgs, Then, Catch, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInvokeWithOperandBundles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInvokeWithOperandBundles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvokeWithOperandBundles(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInvokeWithOperandBundles$descriptor() {
        return LLVMBuildInvokeWithOperandBundles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvokeWithOperandBundles(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInvokeWithOperandBundles$handle() {
        return LLVMBuildInvokeWithOperandBundles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvokeWithOperandBundles(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInvokeWithOperandBundles$address() {
        return LLVMBuildInvokeWithOperandBundles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvokeWithOperandBundles(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInvokeWithOperandBundles(MemorySegment x0, MemorySegment Ty, MemorySegment Fn, MemorySegment Args, int NumArgs, MemorySegment Then, MemorySegment Catch, MemorySegment Bundles, int NumBundles, MemorySegment Name) {
        var mh$ = LLVMBuildInvokeWithOperandBundles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInvokeWithOperandBundles", x0, Ty, Fn, Args, NumArgs, Then, Catch, Bundles, NumBundles, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Fn, Args, NumArgs, Then, Catch, Bundles, NumBundles, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildUnreachable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildUnreachable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)
     * }
     */
    public static FunctionDescriptor LLVMBuildUnreachable$descriptor() {
        return LLVMBuildUnreachable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)
     * }
     */
    public static MethodHandle LLVMBuildUnreachable$handle() {
        return LLVMBuildUnreachable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)
     * }
     */
    public static MemorySegment LLVMBuildUnreachable$address() {
        return LLVMBuildUnreachable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)
     * }
     */
    public static MemorySegment LLVMBuildUnreachable(MemorySegment x0) {
        var mh$ = LLVMBuildUnreachable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildUnreachable", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildResume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildResume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn)
     * }
     */
    public static FunctionDescriptor LLVMBuildResume$descriptor() {
        return LLVMBuildResume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn)
     * }
     */
    public static MethodHandle LLVMBuildResume$handle() {
        return LLVMBuildResume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn)
     * }
     */
    public static MemorySegment LLVMBuildResume$address() {
        return LLVMBuildResume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn)
     * }
     */
    public static MemorySegment LLVMBuildResume(MemorySegment B, MemorySegment Exn) {
        var mh$ = LLVMBuildResume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildResume", B, Exn);
            }
            return (MemorySegment)mh$.invokeExact(B, Exn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildLandingPad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildLandingPad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, unsigned int NumClauses, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildLandingPad$descriptor() {
        return LLVMBuildLandingPad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, unsigned int NumClauses, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildLandingPad$handle() {
        return LLVMBuildLandingPad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, unsigned int NumClauses, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLandingPad$address() {
        return LLVMBuildLandingPad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, unsigned int NumClauses, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLandingPad(MemorySegment B, MemorySegment Ty, MemorySegment PersFn, int NumClauses, MemorySegment Name) {
        var mh$ = LLVMBuildLandingPad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildLandingPad", B, Ty, PersFn, NumClauses, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, PersFn, NumClauses, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCleanupRet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCleanupRet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMBuildCleanupRet$descriptor() {
        return LLVMBuildCleanupRet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMBuildCleanupRet$handle() {
        return LLVMBuildCleanupRet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBuildCleanupRet$address() {
        return LLVMBuildCleanupRet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBuildCleanupRet(MemorySegment B, MemorySegment CatchPad, MemorySegment BB) {
        var mh$ = LLVMBuildCleanupRet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCleanupRet", B, CatchPad, BB);
            }
            return (MemorySegment)mh$.invokeExact(B, CatchPad, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCatchRet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCatchRet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMBuildCatchRet$descriptor() {
        return LLVMBuildCatchRet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMBuildCatchRet$handle() {
        return LLVMBuildCatchRet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBuildCatchRet$address() {
        return LLVMBuildCatchRet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBuildCatchRet(MemorySegment B, MemorySegment CatchPad, MemorySegment BB) {
        var mh$ = LLVMBuildCatchRet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCatchRet", B, CatchPad, BB);
            }
            return (MemorySegment)mh$.invokeExact(B, CatchPad, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCatchPad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCatchPad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCatchPad$descriptor() {
        return LLVMBuildCatchPad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCatchPad$handle() {
        return LLVMBuildCatchPad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCatchPad$address() {
        return LLVMBuildCatchPad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCatchPad(MemorySegment B, MemorySegment ParentPad, MemorySegment Args, int NumArgs, MemorySegment Name) {
        var mh$ = LLVMBuildCatchPad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCatchPad", B, ParentPad, Args, NumArgs, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ParentPad, Args, NumArgs, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCleanupPad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCleanupPad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCleanupPad$descriptor() {
        return LLVMBuildCleanupPad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCleanupPad$handle() {
        return LLVMBuildCleanupPad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCleanupPad$address() {
        return LLVMBuildCleanupPad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCleanupPad(MemorySegment B, MemorySegment ParentPad, MemorySegment Args, int NumArgs, MemorySegment Name) {
        var mh$ = LLVMBuildCleanupPad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCleanupPad", B, ParentPad, Args, NumArgs, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ParentPad, Args, NumArgs, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCatchSwitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCatchSwitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchSwitch(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, unsigned int NumHandlers, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCatchSwitch$descriptor() {
        return LLVMBuildCatchSwitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchSwitch(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, unsigned int NumHandlers, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCatchSwitch$handle() {
        return LLVMBuildCatchSwitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchSwitch(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, unsigned int NumHandlers, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCatchSwitch$address() {
        return LLVMBuildCatchSwitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchSwitch(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, unsigned int NumHandlers, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCatchSwitch(MemorySegment B, MemorySegment ParentPad, MemorySegment UnwindBB, int NumHandlers, MemorySegment Name) {
        var mh$ = LLVMBuildCatchSwitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCatchSwitch", B, ParentPad, UnwindBB, NumHandlers, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ParentPad, UnwindBB, NumHandlers, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddCase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddCase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest)
     * }
     */
    public static FunctionDescriptor LLVMAddCase$descriptor() {
        return LLVMAddCase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest)
     * }
     */
    public static MethodHandle LLVMAddCase$handle() {
        return LLVMAddCase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMAddCase$address() {
        return LLVMAddCase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest)
     * }
     */
    public static void LLVMAddCase(MemorySegment Switch, MemorySegment OnVal, MemorySegment Dest) {
        var mh$ = LLVMAddCase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddCase", Switch, OnVal, Dest);
            }
            mh$.invokeExact(Switch, OnVal, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddDestination {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddDestination");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest)
     * }
     */
    public static FunctionDescriptor LLVMAddDestination$descriptor() {
        return LLVMAddDestination.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest)
     * }
     */
    public static MethodHandle LLVMAddDestination$handle() {
        return LLVMAddDestination.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMAddDestination$address() {
        return LLVMAddDestination.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest)
     * }
     */
    public static void LLVMAddDestination(MemorySegment IndirectBr, MemorySegment Dest) {
        var mh$ = LLVMAddDestination.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddDestination", IndirectBr, Dest);
            }
            mh$.invokeExact(IndirectBr, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumClauses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumClauses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumClauses(LLVMValueRef LandingPad)
     * }
     */
    public static FunctionDescriptor LLVMGetNumClauses$descriptor() {
        return LLVMGetNumClauses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumClauses(LLVMValueRef LandingPad)
     * }
     */
    public static MethodHandle LLVMGetNumClauses$handle() {
        return LLVMGetNumClauses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumClauses(LLVMValueRef LandingPad)
     * }
     */
    public static MemorySegment LLVMGetNumClauses$address() {
        return LLVMGetNumClauses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumClauses(LLVMValueRef LandingPad)
     * }
     */
    public static int LLVMGetNumClauses(MemorySegment LandingPad) {
        var mh$ = LLVMGetNumClauses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumClauses", LandingPad);
            }
            return (int)mh$.invokeExact(LandingPad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetClause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetClause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned int Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetClause$descriptor() {
        return LLVMGetClause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned int Idx)
     * }
     */
    public static MethodHandle LLVMGetClause$handle() {
        return LLVMGetClause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetClause$address() {
        return LLVMGetClause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetClause(MemorySegment LandingPad, int Idx) {
        var mh$ = LLVMGetClause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetClause", LandingPad, Idx);
            }
            return (MemorySegment)mh$.invokeExact(LandingPad, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddClause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddClause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal)
     * }
     */
    public static FunctionDescriptor LLVMAddClause$descriptor() {
        return LLVMAddClause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal)
     * }
     */
    public static MethodHandle LLVMAddClause$handle() {
        return LLVMAddClause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal)
     * }
     */
    public static MemorySegment LLVMAddClause$address() {
        return LLVMAddClause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal)
     * }
     */
    public static void LLVMAddClause(MemorySegment LandingPad, MemorySegment ClauseVal) {
        var mh$ = LLVMAddClause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddClause", LandingPad, ClauseVal);
            }
            mh$.invokeExact(LandingPad, ClauseVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsCleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsCleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad)
     * }
     */
    public static FunctionDescriptor LLVMIsCleanup$descriptor() {
        return LLVMIsCleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad)
     * }
     */
    public static MethodHandle LLVMIsCleanup$handle() {
        return LLVMIsCleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad)
     * }
     */
    public static MemorySegment LLVMIsCleanup$address() {
        return LLVMIsCleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad)
     * }
     */
    public static int LLVMIsCleanup(MemorySegment LandingPad) {
        var mh$ = LLVMIsCleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsCleanup", LandingPad);
            }
            return (int)mh$.invokeExact(LandingPad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val)
     * }
     */
    public static FunctionDescriptor LLVMSetCleanup$descriptor() {
        return LLVMSetCleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val)
     * }
     */
    public static MethodHandle LLVMSetCleanup$handle() {
        return LLVMSetCleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val)
     * }
     */
    public static MemorySegment LLVMSetCleanup$address() {
        return LLVMSetCleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val)
     * }
     */
    public static void LLVMSetCleanup(MemorySegment LandingPad, int Val) {
        var mh$ = LLVMSetCleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCleanup", LandingPad, Val);
            }
            mh$.invokeExact(LandingPad, Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddHandler(LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest)
     * }
     */
    public static FunctionDescriptor LLVMAddHandler$descriptor() {
        return LLVMAddHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddHandler(LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest)
     * }
     */
    public static MethodHandle LLVMAddHandler$handle() {
        return LLVMAddHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddHandler(LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMAddHandler$address() {
        return LLVMAddHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddHandler(LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest)
     * }
     */
    public static void LLVMAddHandler(MemorySegment CatchSwitch, MemorySegment Dest) {
        var mh$ = LLVMAddHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddHandler", CatchSwitch, Dest);
            }
            mh$.invokeExact(CatchSwitch, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumHandlers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumHandlers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumHandlers(LLVMValueRef CatchSwitch)
     * }
     */
    public static FunctionDescriptor LLVMGetNumHandlers$descriptor() {
        return LLVMGetNumHandlers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumHandlers(LLVMValueRef CatchSwitch)
     * }
     */
    public static MethodHandle LLVMGetNumHandlers$handle() {
        return LLVMGetNumHandlers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumHandlers(LLVMValueRef CatchSwitch)
     * }
     */
    public static MemorySegment LLVMGetNumHandlers$address() {
        return LLVMGetNumHandlers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumHandlers(LLVMValueRef CatchSwitch)
     * }
     */
    public static int LLVMGetNumHandlers(MemorySegment CatchSwitch) {
        var mh$ = LLVMGetNumHandlers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumHandlers", CatchSwitch);
            }
            return (int)mh$.invokeExact(CatchSwitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetHandlers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetHandlers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetHandlers(LLVMValueRef CatchSwitch, LLVMBasicBlockRef *Handlers)
     * }
     */
    public static FunctionDescriptor LLVMGetHandlers$descriptor() {
        return LLVMGetHandlers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetHandlers(LLVMValueRef CatchSwitch, LLVMBasicBlockRef *Handlers)
     * }
     */
    public static MethodHandle LLVMGetHandlers$handle() {
        return LLVMGetHandlers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetHandlers(LLVMValueRef CatchSwitch, LLVMBasicBlockRef *Handlers)
     * }
     */
    public static MemorySegment LLVMGetHandlers$address() {
        return LLVMGetHandlers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetHandlers(LLVMValueRef CatchSwitch, LLVMBasicBlockRef *Handlers)
     * }
     */
    public static void LLVMGetHandlers(MemorySegment CatchSwitch, MemorySegment Handlers) {
        var mh$ = LLVMGetHandlers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetHandlers", CatchSwitch, Handlers);
            }
            mh$.invokeExact(CatchSwitch, Handlers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetArgOperand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetArgOperand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetArgOperand(LLVMValueRef Funclet, unsigned int i)
     * }
     */
    public static FunctionDescriptor LLVMGetArgOperand$descriptor() {
        return LLVMGetArgOperand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetArgOperand(LLVMValueRef Funclet, unsigned int i)
     * }
     */
    public static MethodHandle LLVMGetArgOperand$handle() {
        return LLVMGetArgOperand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetArgOperand(LLVMValueRef Funclet, unsigned int i)
     * }
     */
    public static MemorySegment LLVMGetArgOperand$address() {
        return LLVMGetArgOperand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetArgOperand(LLVMValueRef Funclet, unsigned int i)
     * }
     */
    public static MemorySegment LLVMGetArgOperand(MemorySegment Funclet, int i) {
        var mh$ = LLVMGetArgOperand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetArgOperand", Funclet, i);
            }
            return (MemorySegment)mh$.invokeExact(Funclet, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetArgOperand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetArgOperand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetArgOperand(LLVMValueRef Funclet, unsigned int i, LLVMValueRef value)
     * }
     */
    public static FunctionDescriptor LLVMSetArgOperand$descriptor() {
        return LLVMSetArgOperand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetArgOperand(LLVMValueRef Funclet, unsigned int i, LLVMValueRef value)
     * }
     */
    public static MethodHandle LLVMSetArgOperand$handle() {
        return LLVMSetArgOperand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetArgOperand(LLVMValueRef Funclet, unsigned int i, LLVMValueRef value)
     * }
     */
    public static MemorySegment LLVMSetArgOperand$address() {
        return LLVMSetArgOperand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetArgOperand(LLVMValueRef Funclet, unsigned int i, LLVMValueRef value)
     * }
     */
    public static void LLVMSetArgOperand(MemorySegment Funclet, int i, MemorySegment value) {
        var mh$ = LLVMSetArgOperand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetArgOperand", Funclet, i, value);
            }
            mh$.invokeExact(Funclet, i, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParentCatchSwitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParentCatchSwitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParentCatchSwitch(LLVMValueRef CatchPad)
     * }
     */
    public static FunctionDescriptor LLVMGetParentCatchSwitch$descriptor() {
        return LLVMGetParentCatchSwitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParentCatchSwitch(LLVMValueRef CatchPad)
     * }
     */
    public static MethodHandle LLVMGetParentCatchSwitch$handle() {
        return LLVMGetParentCatchSwitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParentCatchSwitch(LLVMValueRef CatchPad)
     * }
     */
    public static MemorySegment LLVMGetParentCatchSwitch$address() {
        return LLVMGetParentCatchSwitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParentCatchSwitch(LLVMValueRef CatchPad)
     * }
     */
    public static MemorySegment LLVMGetParentCatchSwitch(MemorySegment CatchPad) {
        var mh$ = LLVMGetParentCatchSwitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParentCatchSwitch", CatchPad);
            }
            return (MemorySegment)mh$.invokeExact(CatchPad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetParentCatchSwitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetParentCatchSwitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetParentCatchSwitch(LLVMValueRef CatchPad, LLVMValueRef CatchSwitch)
     * }
     */
    public static FunctionDescriptor LLVMSetParentCatchSwitch$descriptor() {
        return LLVMSetParentCatchSwitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetParentCatchSwitch(LLVMValueRef CatchPad, LLVMValueRef CatchSwitch)
     * }
     */
    public static MethodHandle LLVMSetParentCatchSwitch$handle() {
        return LLVMSetParentCatchSwitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetParentCatchSwitch(LLVMValueRef CatchPad, LLVMValueRef CatchSwitch)
     * }
     */
    public static MemorySegment LLVMSetParentCatchSwitch$address() {
        return LLVMSetParentCatchSwitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetParentCatchSwitch(LLVMValueRef CatchPad, LLVMValueRef CatchSwitch)
     * }
     */
    public static void LLVMSetParentCatchSwitch(MemorySegment CatchPad, MemorySegment CatchSwitch) {
        var mh$ = LLVMSetParentCatchSwitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetParentCatchSwitch", CatchPad, CatchSwitch);
            }
            mh$.invokeExact(CatchPad, CatchSwitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAdd$descriptor() {
        return LLVMBuildAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAdd$handle() {
        return LLVMBuildAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAdd$address() {
        return LLVMBuildAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAdd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAdd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNSWAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNSWAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNSWAdd$descriptor() {
        return LLVMBuildNSWAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNSWAdd$handle() {
        return LLVMBuildNSWAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWAdd$address() {
        return LLVMBuildNSWAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWAdd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNSWAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNSWAdd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNUWAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNUWAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNUWAdd$descriptor() {
        return LLVMBuildNUWAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNUWAdd$handle() {
        return LLVMBuildNUWAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWAdd$address() {
        return LLVMBuildNUWAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWAdd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNUWAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNUWAdd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFAdd$descriptor() {
        return LLVMBuildFAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFAdd$handle() {
        return LLVMBuildFAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFAdd$address() {
        return LLVMBuildFAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFAdd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFAdd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSub$descriptor() {
        return LLVMBuildSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSub$handle() {
        return LLVMBuildSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSub$address() {
        return LLVMBuildSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSub(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSub", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNSWSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNSWSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNSWSub$descriptor() {
        return LLVMBuildNSWSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNSWSub$handle() {
        return LLVMBuildNSWSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWSub$address() {
        return LLVMBuildNSWSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWSub(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNSWSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNSWSub", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNUWSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNUWSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNUWSub$descriptor() {
        return LLVMBuildNUWSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNUWSub$handle() {
        return LLVMBuildNUWSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWSub$address() {
        return LLVMBuildNUWSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWSub(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNUWSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNUWSub", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFSub$descriptor() {
        return LLVMBuildFSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFSub$handle() {
        return LLVMBuildFSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFSub$address() {
        return LLVMBuildFSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFSub(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFSub", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildMul$descriptor() {
        return LLVMBuildMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildMul$handle() {
        return LLVMBuildMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildMul$address() {
        return LLVMBuildMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildMul(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMul", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNSWMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNSWMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNSWMul$descriptor() {
        return LLVMBuildNSWMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNSWMul$handle() {
        return LLVMBuildNSWMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWMul$address() {
        return LLVMBuildNSWMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWMul(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNSWMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNSWMul", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNUWMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNUWMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNUWMul$descriptor() {
        return LLVMBuildNUWMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNUWMul$handle() {
        return LLVMBuildNUWMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWMul$address() {
        return LLVMBuildNUWMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWMul(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNUWMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNUWMul", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFMul$descriptor() {
        return LLVMBuildFMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFMul$handle() {
        return LLVMBuildFMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFMul$address() {
        return LLVMBuildFMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFMul(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFMul", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildUDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildUDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildUDiv$descriptor() {
        return LLVMBuildUDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildUDiv$handle() {
        return LLVMBuildUDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildUDiv$address() {
        return LLVMBuildUDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildUDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildUDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildUDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildExactUDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildExactUDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildExactUDiv$descriptor() {
        return LLVMBuildExactUDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildExactUDiv$handle() {
        return LLVMBuildExactUDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExactUDiv$address() {
        return LLVMBuildExactUDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExactUDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildExactUDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildExactUDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSDiv$descriptor() {
        return LLVMBuildSDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSDiv$handle() {
        return LLVMBuildSDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSDiv$address() {
        return LLVMBuildSDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildSDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildExactSDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildExactSDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildExactSDiv$descriptor() {
        return LLVMBuildExactSDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildExactSDiv$handle() {
        return LLVMBuildExactSDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExactSDiv$address() {
        return LLVMBuildExactSDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExactSDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildExactSDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildExactSDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFDiv$descriptor() {
        return LLVMBuildFDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFDiv$handle() {
        return LLVMBuildFDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFDiv$address() {
        return LLVMBuildFDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildURem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildURem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildURem$descriptor() {
        return LLVMBuildURem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildURem$handle() {
        return LLVMBuildURem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildURem$address() {
        return LLVMBuildURem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildURem(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildURem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildURem", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSRem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSRem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSRem$descriptor() {
        return LLVMBuildSRem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSRem$handle() {
        return LLVMBuildSRem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSRem$address() {
        return LLVMBuildSRem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSRem(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildSRem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSRem", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFRem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFRem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFRem$descriptor() {
        return LLVMBuildFRem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFRem$handle() {
        return LLVMBuildFRem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFRem$address() {
        return LLVMBuildFRem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFRem(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFRem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFRem", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildShl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildShl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildShl$descriptor() {
        return LLVMBuildShl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildShl$handle() {
        return LLVMBuildShl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildShl$address() {
        return LLVMBuildShl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildShl(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildShl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildShl", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildLShr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildLShr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildLShr$descriptor() {
        return LLVMBuildLShr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildLShr$handle() {
        return LLVMBuildLShr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLShr$address() {
        return LLVMBuildLShr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLShr(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildLShr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildLShr", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAShr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAShr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAShr$descriptor() {
        return LLVMBuildAShr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAShr$handle() {
        return LLVMBuildAShr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAShr$address() {
        return LLVMBuildAShr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAShr(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildAShr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAShr", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAnd$descriptor() {
        return LLVMBuildAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAnd$handle() {
        return LLVMBuildAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAnd$address() {
        return LLVMBuildAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAnd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAnd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildOr$descriptor() {
        return LLVMBuildOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildOr$handle() {
        return LLVMBuildOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildOr$address() {
        return LLVMBuildOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildOr(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildOr", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildXor$descriptor() {
        return LLVMBuildXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildXor$handle() {
        return LLVMBuildXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildXor$address() {
        return LLVMBuildXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildXor(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildXor", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildBinOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildBinOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildBinOp$descriptor() {
        return LLVMBuildBinOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildBinOp$handle() {
        return LLVMBuildBinOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildBinOp$address() {
        return LLVMBuildBinOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildBinOp(MemorySegment B, int Op, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildBinOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildBinOp", B, Op, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Op, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNeg$descriptor() {
        return LLVMBuildNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNeg$handle() {
        return LLVMBuildNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNeg$address() {
        return LLVMBuildNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNeg(MemorySegment x0, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNeg", x0, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNSWNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNSWNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNSWNeg$descriptor() {
        return LLVMBuildNSWNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNSWNeg$handle() {
        return LLVMBuildNSWNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWNeg$address() {
        return LLVMBuildNSWNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWNeg(MemorySegment B, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildNSWNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNSWNeg", B, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNUWNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNUWNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNUWNeg$descriptor() {
        return LLVMBuildNUWNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNUWNeg$handle() {
        return LLVMBuildNUWNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWNeg$address() {
        return LLVMBuildNUWNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWNeg(MemorySegment B, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildNUWNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNUWNeg", B, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFNeg$descriptor() {
        return LLVMBuildFNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFNeg$handle() {
        return LLVMBuildFNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFNeg$address() {
        return LLVMBuildFNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFNeg(MemorySegment x0, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildFNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFNeg", x0, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNot$descriptor() {
        return LLVMBuildNot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNot$handle() {
        return LLVMBuildNot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNot$address() {
        return LLVMBuildNot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNot(MemorySegment x0, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildNot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNot", x0, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNUW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNUW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNUW(LLVMValueRef ArithInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNUW$descriptor() {
        return LLVMGetNUW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNUW(LLVMValueRef ArithInst)
     * }
     */
    public static MethodHandle LLVMGetNUW$handle() {
        return LLVMGetNUW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNUW(LLVMValueRef ArithInst)
     * }
     */
    public static MemorySegment LLVMGetNUW$address() {
        return LLVMGetNUW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetNUW(LLVMValueRef ArithInst)
     * }
     */
    public static int LLVMGetNUW(MemorySegment ArithInst) {
        var mh$ = LLVMGetNUW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNUW", ArithInst);
            }
            return (int)mh$.invokeExact(ArithInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetNUW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetNUW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetNUW(LLVMValueRef ArithInst, LLVMBool HasNUW)
     * }
     */
    public static FunctionDescriptor LLVMSetNUW$descriptor() {
        return LLVMSetNUW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetNUW(LLVMValueRef ArithInst, LLVMBool HasNUW)
     * }
     */
    public static MethodHandle LLVMSetNUW$handle() {
        return LLVMSetNUW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetNUW(LLVMValueRef ArithInst, LLVMBool HasNUW)
     * }
     */
    public static MemorySegment LLVMSetNUW$address() {
        return LLVMSetNUW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetNUW(LLVMValueRef ArithInst, LLVMBool HasNUW)
     * }
     */
    public static void LLVMSetNUW(MemorySegment ArithInst, int HasNUW) {
        var mh$ = LLVMSetNUW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetNUW", ArithInst, HasNUW);
            }
            mh$.invokeExact(ArithInst, HasNUW);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNSW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNSW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNSW(LLVMValueRef ArithInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNSW$descriptor() {
        return LLVMGetNSW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNSW(LLVMValueRef ArithInst)
     * }
     */
    public static MethodHandle LLVMGetNSW$handle() {
        return LLVMGetNSW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNSW(LLVMValueRef ArithInst)
     * }
     */
    public static MemorySegment LLVMGetNSW$address() {
        return LLVMGetNSW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetNSW(LLVMValueRef ArithInst)
     * }
     */
    public static int LLVMGetNSW(MemorySegment ArithInst) {
        var mh$ = LLVMGetNSW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNSW", ArithInst);
            }
            return (int)mh$.invokeExact(ArithInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetNSW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetNSW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetNSW(LLVMValueRef ArithInst, LLVMBool HasNSW)
     * }
     */
    public static FunctionDescriptor LLVMSetNSW$descriptor() {
        return LLVMSetNSW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetNSW(LLVMValueRef ArithInst, LLVMBool HasNSW)
     * }
     */
    public static MethodHandle LLVMSetNSW$handle() {
        return LLVMSetNSW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetNSW(LLVMValueRef ArithInst, LLVMBool HasNSW)
     * }
     */
    public static MemorySegment LLVMSetNSW$address() {
        return LLVMSetNSW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetNSW(LLVMValueRef ArithInst, LLVMBool HasNSW)
     * }
     */
    public static void LLVMSetNSW(MemorySegment ArithInst, int HasNSW) {
        var mh$ = LLVMSetNSW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetNSW", ArithInst, HasNSW);
            }
            mh$.invokeExact(ArithInst, HasNSW);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetExact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetExact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetExact(LLVMValueRef DivOrShrInst)
     * }
     */
    public static FunctionDescriptor LLVMGetExact$descriptor() {
        return LLVMGetExact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetExact(LLVMValueRef DivOrShrInst)
     * }
     */
    public static MethodHandle LLVMGetExact$handle() {
        return LLVMGetExact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetExact(LLVMValueRef DivOrShrInst)
     * }
     */
    public static MemorySegment LLVMGetExact$address() {
        return LLVMGetExact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetExact(LLVMValueRef DivOrShrInst)
     * }
     */
    public static int LLVMGetExact(MemorySegment DivOrShrInst) {
        var mh$ = LLVMGetExact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetExact", DivOrShrInst);
            }
            return (int)mh$.invokeExact(DivOrShrInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetExact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetExact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetExact(LLVMValueRef DivOrShrInst, LLVMBool IsExact)
     * }
     */
    public static FunctionDescriptor LLVMSetExact$descriptor() {
        return LLVMSetExact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetExact(LLVMValueRef DivOrShrInst, LLVMBool IsExact)
     * }
     */
    public static MethodHandle LLVMSetExact$handle() {
        return LLVMSetExact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetExact(LLVMValueRef DivOrShrInst, LLVMBool IsExact)
     * }
     */
    public static MemorySegment LLVMSetExact$address() {
        return LLVMSetExact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetExact(LLVMValueRef DivOrShrInst, LLVMBool IsExact)
     * }
     */
    public static void LLVMSetExact(MemorySegment DivOrShrInst, int IsExact) {
        var mh$ = LLVMSetExact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetExact", DivOrShrInst, IsExact);
            }
            mh$.invokeExact(DivOrShrInst, IsExact);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNNeg(LLVMValueRef NonNegInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNNeg$descriptor() {
        return LLVMGetNNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNNeg(LLVMValueRef NonNegInst)
     * }
     */
    public static MethodHandle LLVMGetNNeg$handle() {
        return LLVMGetNNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNNeg(LLVMValueRef NonNegInst)
     * }
     */
    public static MemorySegment LLVMGetNNeg$address() {
        return LLVMGetNNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetNNeg(LLVMValueRef NonNegInst)
     * }
     */
    public static int LLVMGetNNeg(MemorySegment NonNegInst) {
        var mh$ = LLVMGetNNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNNeg", NonNegInst);
            }
            return (int)mh$.invokeExact(NonNegInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetNNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetNNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetNNeg(LLVMValueRef NonNegInst, LLVMBool IsNonNeg)
     * }
     */
    public static FunctionDescriptor LLVMSetNNeg$descriptor() {
        return LLVMSetNNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetNNeg(LLVMValueRef NonNegInst, LLVMBool IsNonNeg)
     * }
     */
    public static MethodHandle LLVMSetNNeg$handle() {
        return LLVMSetNNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetNNeg(LLVMValueRef NonNegInst, LLVMBool IsNonNeg)
     * }
     */
    public static MemorySegment LLVMSetNNeg$address() {
        return LLVMSetNNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetNNeg(LLVMValueRef NonNegInst, LLVMBool IsNonNeg)
     * }
     */
    public static void LLVMSetNNeg(MemorySegment NonNegInst, int IsNonNeg) {
        var mh$ = LLVMSetNNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetNNeg", NonNegInst, IsNonNeg);
            }
            mh$.invokeExact(NonNegInst, IsNonNeg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFastMathFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFastMathFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMFastMathFlags LLVMGetFastMathFlags(LLVMValueRef FPMathInst)
     * }
     */
    public static FunctionDescriptor LLVMGetFastMathFlags$descriptor() {
        return LLVMGetFastMathFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMFastMathFlags LLVMGetFastMathFlags(LLVMValueRef FPMathInst)
     * }
     */
    public static MethodHandle LLVMGetFastMathFlags$handle() {
        return LLVMGetFastMathFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMFastMathFlags LLVMGetFastMathFlags(LLVMValueRef FPMathInst)
     * }
     */
    public static MemorySegment LLVMGetFastMathFlags$address() {
        return LLVMGetFastMathFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMFastMathFlags LLVMGetFastMathFlags(LLVMValueRef FPMathInst)
     * }
     */
    public static int LLVMGetFastMathFlags(MemorySegment FPMathInst) {
        var mh$ = LLVMGetFastMathFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFastMathFlags", FPMathInst);
            }
            return (int)mh$.invokeExact(FPMathInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetFastMathFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetFastMathFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetFastMathFlags(LLVMValueRef FPMathInst, LLVMFastMathFlags FMF)
     * }
     */
    public static FunctionDescriptor LLVMSetFastMathFlags$descriptor() {
        return LLVMSetFastMathFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetFastMathFlags(LLVMValueRef FPMathInst, LLVMFastMathFlags FMF)
     * }
     */
    public static MethodHandle LLVMSetFastMathFlags$handle() {
        return LLVMSetFastMathFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetFastMathFlags(LLVMValueRef FPMathInst, LLVMFastMathFlags FMF)
     * }
     */
    public static MemorySegment LLVMSetFastMathFlags$address() {
        return LLVMSetFastMathFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetFastMathFlags(LLVMValueRef FPMathInst, LLVMFastMathFlags FMF)
     * }
     */
    public static void LLVMSetFastMathFlags(MemorySegment FPMathInst, int FMF) {
        var mh$ = LLVMSetFastMathFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetFastMathFlags", FPMathInst, FMF);
            }
            mh$.invokeExact(FPMathInst, FMF);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCanValueUseFastMathFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCanValueUseFastMathFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCanValueUseFastMathFlags(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMCanValueUseFastMathFlags$descriptor() {
        return LLVMCanValueUseFastMathFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCanValueUseFastMathFlags(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMCanValueUseFastMathFlags$handle() {
        return LLVMCanValueUseFastMathFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCanValueUseFastMathFlags(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMCanValueUseFastMathFlags$address() {
        return LLVMCanValueUseFastMathFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCanValueUseFastMathFlags(LLVMValueRef Inst)
     * }
     */
    public static int LLVMCanValueUseFastMathFlags(MemorySegment Inst) {
        var mh$ = LLVMCanValueUseFastMathFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCanValueUseFastMathFlags", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIsDisjoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIsDisjoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetIsDisjoint(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetIsDisjoint$descriptor() {
        return LLVMGetIsDisjoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetIsDisjoint(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetIsDisjoint$handle() {
        return LLVMGetIsDisjoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetIsDisjoint(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetIsDisjoint$address() {
        return LLVMGetIsDisjoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetIsDisjoint(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetIsDisjoint(MemorySegment Inst) {
        var mh$ = LLVMGetIsDisjoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIsDisjoint", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetIsDisjoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetIsDisjoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetIsDisjoint(LLVMValueRef Inst, LLVMBool IsDisjoint)
     * }
     */
    public static FunctionDescriptor LLVMSetIsDisjoint$descriptor() {
        return LLVMSetIsDisjoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetIsDisjoint(LLVMValueRef Inst, LLVMBool IsDisjoint)
     * }
     */
    public static MethodHandle LLVMSetIsDisjoint$handle() {
        return LLVMSetIsDisjoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetIsDisjoint(LLVMValueRef Inst, LLVMBool IsDisjoint)
     * }
     */
    public static MemorySegment LLVMSetIsDisjoint$address() {
        return LLVMSetIsDisjoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetIsDisjoint(LLVMValueRef Inst, LLVMBool IsDisjoint)
     * }
     */
    public static void LLVMSetIsDisjoint(MemorySegment Inst, int IsDisjoint) {
        var mh$ = LLVMSetIsDisjoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetIsDisjoint", Inst, IsDisjoint);
            }
            mh$.invokeExact(Inst, IsDisjoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildMalloc$descriptor() {
        return LLVMBuildMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildMalloc$handle() {
        return LLVMBuildMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildMalloc$address() {
        return LLVMBuildMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildMalloc(MemorySegment x0, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMBuildMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMalloc", x0, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildArrayMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildArrayMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildArrayMalloc$descriptor() {
        return LLVMBuildArrayMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildArrayMalloc$handle() {
        return LLVMBuildArrayMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildArrayMalloc$address() {
        return LLVMBuildArrayMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildArrayMalloc(MemorySegment x0, MemorySegment Ty, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildArrayMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildArrayMalloc", x0, Ty, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMemSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMemSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemSet(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, unsigned int Align)
     * }
     */
    public static FunctionDescriptor LLVMBuildMemSet$descriptor() {
        return LLVMBuildMemSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemSet(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, unsigned int Align)
     * }
     */
    public static MethodHandle LLVMBuildMemSet$handle() {
        return LLVMBuildMemSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemSet(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, unsigned int Align)
     * }
     */
    public static MemorySegment LLVMBuildMemSet$address() {
        return LLVMBuildMemSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemSet(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, unsigned int Align)
     * }
     */
    public static MemorySegment LLVMBuildMemSet(MemorySegment B, MemorySegment Ptr, MemorySegment Val, MemorySegment Len, int Align) {
        var mh$ = LLVMBuildMemSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMemSet", B, Ptr, Val, Len, Align);
            }
            return (MemorySegment)mh$.invokeExact(B, Ptr, Val, Len, Align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMemCpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMemCpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemCpy(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static FunctionDescriptor LLVMBuildMemCpy$descriptor() {
        return LLVMBuildMemCpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemCpy(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MethodHandle LLVMBuildMemCpy$handle() {
        return LLVMBuildMemCpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemCpy(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MemorySegment LLVMBuildMemCpy$address() {
        return LLVMBuildMemCpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemCpy(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MemorySegment LLVMBuildMemCpy(MemorySegment B, MemorySegment Dst, int DstAlign, MemorySegment Src, int SrcAlign, MemorySegment Size) {
        var mh$ = LLVMBuildMemCpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMemCpy", B, Dst, DstAlign, Src, SrcAlign, Size);
            }
            return (MemorySegment)mh$.invokeExact(B, Dst, DstAlign, Src, SrcAlign, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMemMove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMemMove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemMove(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static FunctionDescriptor LLVMBuildMemMove$descriptor() {
        return LLVMBuildMemMove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemMove(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MethodHandle LLVMBuildMemMove$handle() {
        return LLVMBuildMemMove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemMove(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MemorySegment LLVMBuildMemMove$address() {
        return LLVMBuildMemMove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemMove(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MemorySegment LLVMBuildMemMove(MemorySegment B, MemorySegment Dst, int DstAlign, MemorySegment Src, int SrcAlign, MemorySegment Size) {
        var mh$ = LLVMBuildMemMove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMemMove", B, Dst, DstAlign, Src, SrcAlign, Size);
            }
            return (MemorySegment)mh$.invokeExact(B, Dst, DstAlign, Src, SrcAlign, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAlloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAlloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAlloca$descriptor() {
        return LLVMBuildAlloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAlloca$handle() {
        return LLVMBuildAlloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAlloca$address() {
        return LLVMBuildAlloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAlloca(MemorySegment x0, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMBuildAlloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAlloca", x0, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildArrayAlloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildArrayAlloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildArrayAlloca$descriptor() {
        return LLVMBuildArrayAlloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildArrayAlloca$handle() {
        return LLVMBuildArrayAlloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildArrayAlloca$address() {
        return LLVMBuildArrayAlloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildArrayAlloca(MemorySegment x0, MemorySegment Ty, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildArrayAlloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildArrayAlloca", x0, Ty, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal)
     * }
     */
    public static FunctionDescriptor LLVMBuildFree$descriptor() {
        return LLVMBuildFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal)
     * }
     */
    public static MethodHandle LLVMBuildFree$handle() {
        return LLVMBuildFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal)
     * }
     */
    public static MemorySegment LLVMBuildFree$address() {
        return LLVMBuildFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal)
     * }
     */
    public static MemorySegment LLVMBuildFree(MemorySegment x0, MemorySegment PointerVal) {
        var mh$ = LLVMBuildFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFree", x0, PointerVal);
            }
            return (MemorySegment)mh$.invokeExact(x0, PointerVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildLoad2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildLoad2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLoad2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef PointerVal, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildLoad2$descriptor() {
        return LLVMBuildLoad2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLoad2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef PointerVal, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildLoad2$handle() {
        return LLVMBuildLoad2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLoad2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef PointerVal, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLoad2$address() {
        return LLVMBuildLoad2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLoad2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef PointerVal, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLoad2(MemorySegment x0, MemorySegment Ty, MemorySegment PointerVal, MemorySegment Name) {
        var mh$ = LLVMBuildLoad2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildLoad2", x0, Ty, PointerVal, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, PointerVal, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr)
     * }
     */
    public static FunctionDescriptor LLVMBuildStore$descriptor() {
        return LLVMBuildStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr)
     * }
     */
    public static MethodHandle LLVMBuildStore$handle() {
        return LLVMBuildStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr)
     * }
     */
    public static MemorySegment LLVMBuildStore$address() {
        return LLVMBuildStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr)
     * }
     */
    public static MemorySegment LLVMBuildStore(MemorySegment x0, MemorySegment Val, MemorySegment Ptr) {
        var mh$ = LLVMBuildStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildStore", x0, Val, Ptr);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildGEP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildGEP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildGEP2$descriptor() {
        return LLVMBuildGEP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildGEP2$handle() {
        return LLVMBuildGEP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGEP2$address() {
        return LLVMBuildGEP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGEP2(MemorySegment B, MemorySegment Ty, MemorySegment Pointer, MemorySegment Indices, int NumIndices, MemorySegment Name) {
        var mh$ = LLVMBuildGEP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildGEP2", B, Ty, Pointer, Indices, NumIndices, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Pointer, Indices, NumIndices, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInBoundsGEP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInBoundsGEP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInBoundsGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInBoundsGEP2$descriptor() {
        return LLVMBuildInBoundsGEP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInBoundsGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInBoundsGEP2$handle() {
        return LLVMBuildInBoundsGEP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInBoundsGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInBoundsGEP2$address() {
        return LLVMBuildInBoundsGEP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInBoundsGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInBoundsGEP2(MemorySegment B, MemorySegment Ty, MemorySegment Pointer, MemorySegment Indices, int NumIndices, MemorySegment Name) {
        var mh$ = LLVMBuildInBoundsGEP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInBoundsGEP2", B, Ty, Pointer, Indices, NumIndices, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Pointer, Indices, NumIndices, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildGEPWithNoWrapFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildGEPWithNoWrapFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEPWithNoWrapFlags(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static FunctionDescriptor LLVMBuildGEPWithNoWrapFlags$descriptor() {
        return LLVMBuildGEPWithNoWrapFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEPWithNoWrapFlags(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MethodHandle LLVMBuildGEPWithNoWrapFlags$handle() {
        return LLVMBuildGEPWithNoWrapFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEPWithNoWrapFlags(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MemorySegment LLVMBuildGEPWithNoWrapFlags$address() {
        return LLVMBuildGEPWithNoWrapFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEPWithNoWrapFlags(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MemorySegment LLVMBuildGEPWithNoWrapFlags(MemorySegment B, MemorySegment Ty, MemorySegment Pointer, MemorySegment Indices, int NumIndices, MemorySegment Name, int NoWrapFlags) {
        var mh$ = LLVMBuildGEPWithNoWrapFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildGEPWithNoWrapFlags", B, Ty, Pointer, Indices, NumIndices, Name, NoWrapFlags);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Pointer, Indices, NumIndices, Name, NoWrapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildStructGEP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildStructGEP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStructGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, unsigned int Idx, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildStructGEP2$descriptor() {
        return LLVMBuildStructGEP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStructGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, unsigned int Idx, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildStructGEP2$handle() {
        return LLVMBuildStructGEP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStructGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, unsigned int Idx, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildStructGEP2$address() {
        return LLVMBuildStructGEP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStructGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, unsigned int Idx, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildStructGEP2(MemorySegment B, MemorySegment Ty, MemorySegment Pointer, int Idx, MemorySegment Name) {
        var mh$ = LLVMBuildStructGEP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildStructGEP2", B, Ty, Pointer, Idx, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Pointer, Idx, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildGlobalString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildGlobalString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildGlobalString$descriptor() {
        return LLVMBuildGlobalString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildGlobalString$handle() {
        return LLVMBuildGlobalString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGlobalString$address() {
        return LLVMBuildGlobalString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGlobalString(MemorySegment B, MemorySegment Str, MemorySegment Name) {
        var mh$ = LLVMBuildGlobalString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildGlobalString", B, Str, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Str, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildGlobalStringPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildGlobalStringPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildGlobalStringPtr$descriptor() {
        return LLVMBuildGlobalStringPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildGlobalStringPtr$handle() {
        return LLVMBuildGlobalStringPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGlobalStringPtr$address() {
        return LLVMBuildGlobalStringPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGlobalStringPtr(MemorySegment B, MemorySegment Str, MemorySegment Name) {
        var mh$ = LLVMBuildGlobalStringPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildGlobalStringPtr", B, Str, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Str, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetVolatile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetVolatile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static FunctionDescriptor LLVMGetVolatile$descriptor() {
        return LLVMGetVolatile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static MethodHandle LLVMGetVolatile$handle() {
        return LLVMGetVolatile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static MemorySegment LLVMGetVolatile$address() {
        return LLVMGetVolatile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static int LLVMGetVolatile(MemorySegment MemoryAccessInst) {
        var mh$ = LLVMGetVolatile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetVolatile", MemoryAccessInst);
            }
            return (int)mh$.invokeExact(MemoryAccessInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetVolatile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetVolatile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile)
     * }
     */
    public static FunctionDescriptor LLVMSetVolatile$descriptor() {
        return LLVMSetVolatile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile)
     * }
     */
    public static MethodHandle LLVMSetVolatile$handle() {
        return LLVMSetVolatile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile)
     * }
     */
    public static MemorySegment LLVMSetVolatile$address() {
        return LLVMSetVolatile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile)
     * }
     */
    public static void LLVMSetVolatile(MemorySegment MemoryAccessInst, int IsVolatile) {
        var mh$ = LLVMSetVolatile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetVolatile", MemoryAccessInst, IsVolatile);
            }
            mh$.invokeExact(MemoryAccessInst, IsVolatile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetWeak(LLVMValueRef CmpXchgInst)
     * }
     */
    public static FunctionDescriptor LLVMGetWeak$descriptor() {
        return LLVMGetWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetWeak(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MethodHandle LLVMGetWeak$handle() {
        return LLVMGetWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetWeak(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MemorySegment LLVMGetWeak$address() {
        return LLVMGetWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetWeak(LLVMValueRef CmpXchgInst)
     * }
     */
    public static int LLVMGetWeak(MemorySegment CmpXchgInst) {
        var mh$ = LLVMGetWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetWeak", CmpXchgInst);
            }
            return (int)mh$.invokeExact(CmpXchgInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetWeak(LLVMValueRef CmpXchgInst, LLVMBool IsWeak)
     * }
     */
    public static FunctionDescriptor LLVMSetWeak$descriptor() {
        return LLVMSetWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetWeak(LLVMValueRef CmpXchgInst, LLVMBool IsWeak)
     * }
     */
    public static MethodHandle LLVMSetWeak$handle() {
        return LLVMSetWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetWeak(LLVMValueRef CmpXchgInst, LLVMBool IsWeak)
     * }
     */
    public static MemorySegment LLVMSetWeak$address() {
        return LLVMSetWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetWeak(LLVMValueRef CmpXchgInst, LLVMBool IsWeak)
     * }
     */
    public static void LLVMSetWeak(MemorySegment CmpXchgInst, int IsWeak) {
        var mh$ = LLVMSetWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetWeak", CmpXchgInst, IsWeak);
            }
            mh$.invokeExact(CmpXchgInst, IsWeak);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static FunctionDescriptor LLVMGetOrdering$descriptor() {
        return LLVMGetOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static MethodHandle LLVMGetOrdering$handle() {
        return LLVMGetOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static MemorySegment LLVMGetOrdering$address() {
        return LLVMGetOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static int LLVMGetOrdering(MemorySegment MemoryAccessInst) {
        var mh$ = LLVMGetOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOrdering", MemoryAccessInst);
            }
            return (int)mh$.invokeExact(MemoryAccessInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static FunctionDescriptor LLVMSetOrdering$descriptor() {
        return LLVMSetOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MethodHandle LLVMSetOrdering$handle() {
        return LLVMSetOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MemorySegment LLVMSetOrdering$address() {
        return LLVMSetOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static void LLVMSetOrdering(MemorySegment MemoryAccessInst, int Ordering) {
        var mh$ = LLVMSetOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetOrdering", MemoryAccessInst, Ordering);
            }
            mh$.invokeExact(MemoryAccessInst, Ordering);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAtomicRMWBinOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAtomicRMWBinOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAtomicRMWBinOp LLVMGetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst)
     * }
     */
    public static FunctionDescriptor LLVMGetAtomicRMWBinOp$descriptor() {
        return LLVMGetAtomicRMWBinOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAtomicRMWBinOp LLVMGetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst)
     * }
     */
    public static MethodHandle LLVMGetAtomicRMWBinOp$handle() {
        return LLVMGetAtomicRMWBinOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAtomicRMWBinOp LLVMGetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst)
     * }
     */
    public static MemorySegment LLVMGetAtomicRMWBinOp$address() {
        return LLVMGetAtomicRMWBinOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAtomicRMWBinOp LLVMGetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst)
     * }
     */
    public static int LLVMGetAtomicRMWBinOp(MemorySegment AtomicRMWInst) {
        var mh$ = LLVMGetAtomicRMWBinOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAtomicRMWBinOp", AtomicRMWInst);
            }
            return (int)mh$.invokeExact(AtomicRMWInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetAtomicRMWBinOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetAtomicRMWBinOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst, LLVMAtomicRMWBinOp BinOp)
     * }
     */
    public static FunctionDescriptor LLVMSetAtomicRMWBinOp$descriptor() {
        return LLVMSetAtomicRMWBinOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst, LLVMAtomicRMWBinOp BinOp)
     * }
     */
    public static MethodHandle LLVMSetAtomicRMWBinOp$handle() {
        return LLVMSetAtomicRMWBinOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst, LLVMAtomicRMWBinOp BinOp)
     * }
     */
    public static MemorySegment LLVMSetAtomicRMWBinOp$address() {
        return LLVMSetAtomicRMWBinOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst, LLVMAtomicRMWBinOp BinOp)
     * }
     */
    public static void LLVMSetAtomicRMWBinOp(MemorySegment AtomicRMWInst, int BinOp) {
        var mh$ = LLVMSetAtomicRMWBinOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetAtomicRMWBinOp", AtomicRMWInst, BinOp);
            }
            mh$.invokeExact(AtomicRMWInst, BinOp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildTrunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildTrunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildTrunc$descriptor() {
        return LLVMBuildTrunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildTrunc$handle() {
        return LLVMBuildTrunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildTrunc$address() {
        return LLVMBuildTrunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildTrunc(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildTrunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildTrunc", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildZExt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildZExt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildZExt$descriptor() {
        return LLVMBuildZExt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildZExt$handle() {
        return LLVMBuildZExt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildZExt$address() {
        return LLVMBuildZExt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildZExt(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildZExt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildZExt", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSExt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSExt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSExt$descriptor() {
        return LLVMBuildSExt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSExt$handle() {
        return LLVMBuildSExt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSExt$address() {
        return LLVMBuildSExt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSExt(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildSExt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSExt", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPToUI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPToUI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPToUI$descriptor() {
        return LLVMBuildFPToUI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPToUI$handle() {
        return LLVMBuildFPToUI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPToUI$address() {
        return LLVMBuildFPToUI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPToUI(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPToUI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPToUI", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPToSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPToSI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPToSI$descriptor() {
        return LLVMBuildFPToSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPToSI$handle() {
        return LLVMBuildFPToSI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPToSI$address() {
        return LLVMBuildFPToSI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPToSI(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPToSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPToSI", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildUIToFP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildUIToFP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildUIToFP$descriptor() {
        return LLVMBuildUIToFP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildUIToFP$handle() {
        return LLVMBuildUIToFP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildUIToFP$address() {
        return LLVMBuildUIToFP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildUIToFP(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildUIToFP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildUIToFP", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSIToFP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSIToFP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSIToFP$descriptor() {
        return LLVMBuildSIToFP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSIToFP$handle() {
        return LLVMBuildSIToFP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSIToFP$address() {
        return LLVMBuildSIToFP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSIToFP(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildSIToFP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSIToFP", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPTrunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPTrunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPTrunc$descriptor() {
        return LLVMBuildFPTrunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPTrunc$handle() {
        return LLVMBuildFPTrunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPTrunc$address() {
        return LLVMBuildFPTrunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPTrunc(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPTrunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPTrunc", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPExt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPExt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPExt$descriptor() {
        return LLVMBuildFPExt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPExt$handle() {
        return LLVMBuildFPExt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPExt$address() {
        return LLVMBuildFPExt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPExt(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPExt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPExt", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildPtrToInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildPtrToInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildPtrToInt$descriptor() {
        return LLVMBuildPtrToInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildPtrToInt$handle() {
        return LLVMBuildPtrToInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPtrToInt$address() {
        return LLVMBuildPtrToInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPtrToInt(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildPtrToInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildPtrToInt", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIntToPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIntToPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIntToPtr$descriptor() {
        return LLVMBuildIntToPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIntToPtr$handle() {
        return LLVMBuildIntToPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntToPtr$address() {
        return LLVMBuildIntToPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntToPtr(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildIntToPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIntToPtr", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildBitCast$descriptor() {
        return LLVMBuildBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildBitCast$handle() {
        return LLVMBuildBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildBitCast$address() {
        return LLVMBuildBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildBitCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildBitCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAddrSpaceCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAddrSpaceCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAddrSpaceCast$descriptor() {
        return LLVMBuildAddrSpaceCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAddrSpaceCast$handle() {
        return LLVMBuildAddrSpaceCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAddrSpaceCast$address() {
        return LLVMBuildAddrSpaceCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAddrSpaceCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildAddrSpaceCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAddrSpaceCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildZExtOrBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildZExtOrBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildZExtOrBitCast$descriptor() {
        return LLVMBuildZExtOrBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildZExtOrBitCast$handle() {
        return LLVMBuildZExtOrBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildZExtOrBitCast$address() {
        return LLVMBuildZExtOrBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildZExtOrBitCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildZExtOrBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildZExtOrBitCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSExtOrBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSExtOrBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSExtOrBitCast$descriptor() {
        return LLVMBuildSExtOrBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSExtOrBitCast$handle() {
        return LLVMBuildSExtOrBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSExtOrBitCast$address() {
        return LLVMBuildSExtOrBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSExtOrBitCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildSExtOrBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSExtOrBitCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildTruncOrBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildTruncOrBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildTruncOrBitCast$descriptor() {
        return LLVMBuildTruncOrBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildTruncOrBitCast$handle() {
        return LLVMBuildTruncOrBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildTruncOrBitCast$address() {
        return LLVMBuildTruncOrBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildTruncOrBitCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildTruncOrBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildTruncOrBitCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCast$descriptor() {
        return LLVMBuildCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCast$handle() {
        return LLVMBuildCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCast$address() {
        return LLVMBuildCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCast(MemorySegment B, int Op, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCast", B, Op, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Op, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildPointerCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildPointerCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildPointerCast$descriptor() {
        return LLVMBuildPointerCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildPointerCast$handle() {
        return LLVMBuildPointerCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPointerCast$address() {
        return LLVMBuildPointerCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPointerCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildPointerCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildPointerCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIntCast2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIntCast2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast2(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, LLVMBool IsSigned, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIntCast2$descriptor() {
        return LLVMBuildIntCast2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast2(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, LLVMBool IsSigned, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIntCast2$handle() {
        return LLVMBuildIntCast2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast2(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, LLVMBool IsSigned, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntCast2$address() {
        return LLVMBuildIntCast2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast2(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, LLVMBool IsSigned, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntCast2(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, int IsSigned, MemorySegment Name) {
        var mh$ = LLVMBuildIntCast2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIntCast2", x0, Val, DestTy, IsSigned, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, IsSigned, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPCast$descriptor() {
        return LLVMBuildFPCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPCast$handle() {
        return LLVMBuildFPCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPCast$address() {
        return LLVMBuildFPCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIntCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIntCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIntCast$descriptor() {
        return LLVMBuildIntCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIntCast$handle() {
        return LLVMBuildIntCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntCast$address() {
        return LLVMBuildIntCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildIntCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIntCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCastOpcode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCastOpcode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetCastOpcode(LLVMValueRef Src, LLVMBool SrcIsSigned, LLVMTypeRef DestTy, LLVMBool DestIsSigned)
     * }
     */
    public static FunctionDescriptor LLVMGetCastOpcode$descriptor() {
        return LLVMGetCastOpcode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetCastOpcode(LLVMValueRef Src, LLVMBool SrcIsSigned, LLVMTypeRef DestTy, LLVMBool DestIsSigned)
     * }
     */
    public static MethodHandle LLVMGetCastOpcode$handle() {
        return LLVMGetCastOpcode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetCastOpcode(LLVMValueRef Src, LLVMBool SrcIsSigned, LLVMTypeRef DestTy, LLVMBool DestIsSigned)
     * }
     */
    public static MemorySegment LLVMGetCastOpcode$address() {
        return LLVMGetCastOpcode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetCastOpcode(LLVMValueRef Src, LLVMBool SrcIsSigned, LLVMTypeRef DestTy, LLVMBool DestIsSigned)
     * }
     */
    public static int LLVMGetCastOpcode(MemorySegment Src, int SrcIsSigned, MemorySegment DestTy, int DestIsSigned) {
        var mh$ = LLVMGetCastOpcode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCastOpcode", Src, SrcIsSigned, DestTy, DestIsSigned);
            }
            return (int)mh$.invokeExact(Src, SrcIsSigned, DestTy, DestIsSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildICmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildICmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildICmp$descriptor() {
        return LLVMBuildICmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildICmp$handle() {
        return LLVMBuildICmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildICmp$address() {
        return LLVMBuildICmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildICmp(MemorySegment x0, int Op, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildICmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildICmp", x0, Op, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Op, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFCmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFCmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFCmp$descriptor() {
        return LLVMBuildFCmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFCmp$handle() {
        return LLVMBuildFCmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFCmp$address() {
        return LLVMBuildFCmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFCmp(MemorySegment x0, int Op, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFCmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFCmp", x0, Op, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Op, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildPhi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildPhi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildPhi$descriptor() {
        return LLVMBuildPhi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildPhi$handle() {
        return LLVMBuildPhi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPhi$address() {
        return LLVMBuildPhi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPhi(MemorySegment x0, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMBuildPhi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildPhi", x0, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCall2(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCall2$descriptor() {
        return LLVMBuildCall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCall2(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCall2$handle() {
        return LLVMBuildCall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCall2(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCall2$address() {
        return LLVMBuildCall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCall2(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCall2(MemorySegment x0, MemorySegment x1, MemorySegment Fn, MemorySegment Args, int NumArgs, MemorySegment Name) {
        var mh$ = LLVMBuildCall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCall2", x0, x1, Fn, Args, NumArgs, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, Fn, Args, NumArgs, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCallWithOperandBundles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCallWithOperandBundles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallWithOperandBundles(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCallWithOperandBundles$descriptor() {
        return LLVMBuildCallWithOperandBundles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallWithOperandBundles(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCallWithOperandBundles$handle() {
        return LLVMBuildCallWithOperandBundles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallWithOperandBundles(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCallWithOperandBundles$address() {
        return LLVMBuildCallWithOperandBundles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallWithOperandBundles(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCallWithOperandBundles(MemorySegment x0, MemorySegment x1, MemorySegment Fn, MemorySegment Args, int NumArgs, MemorySegment Bundles, int NumBundles, MemorySegment Name) {
        var mh$ = LLVMBuildCallWithOperandBundles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCallWithOperandBundles", x0, x1, Fn, Args, NumArgs, Bundles, NumBundles, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, Fn, Args, NumArgs, Bundles, NumBundles, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSelect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSelect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSelect$descriptor() {
        return LLVMBuildSelect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSelect$handle() {
        return LLVMBuildSelect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSelect$address() {
        return LLVMBuildSelect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSelect(MemorySegment x0, MemorySegment If, MemorySegment Then, MemorySegment Else, MemorySegment Name) {
        var mh$ = LLVMBuildSelect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSelect", x0, If, Then, Else, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, If, Then, Else, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildVAArg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildVAArg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildVAArg$descriptor() {
        return LLVMBuildVAArg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildVAArg$handle() {
        return LLVMBuildVAArg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildVAArg$address() {
        return LLVMBuildVAArg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildVAArg(MemorySegment x0, MemorySegment List, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMBuildVAArg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildVAArg", x0, List, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, List, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildExtractElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildExtractElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildExtractElement$descriptor() {
        return LLVMBuildExtractElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildExtractElement$handle() {
        return LLVMBuildExtractElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExtractElement$address() {
        return LLVMBuildExtractElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExtractElement(MemorySegment x0, MemorySegment VecVal, MemorySegment Index, MemorySegment Name) {
        var mh$ = LLVMBuildExtractElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildExtractElement", x0, VecVal, Index, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, VecVal, Index, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInsertElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInsertElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInsertElement$descriptor() {
        return LLVMBuildInsertElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInsertElement$handle() {
        return LLVMBuildInsertElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInsertElement$address() {
        return LLVMBuildInsertElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInsertElement(MemorySegment x0, MemorySegment VecVal, MemorySegment EltVal, MemorySegment Index, MemorySegment Name) {
        var mh$ = LLVMBuildInsertElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInsertElement", x0, VecVal, EltVal, Index, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, VecVal, EltVal, Index, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildShuffleVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildShuffleVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildShuffleVector$descriptor() {
        return LLVMBuildShuffleVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildShuffleVector$handle() {
        return LLVMBuildShuffleVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildShuffleVector$address() {
        return LLVMBuildShuffleVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildShuffleVector(MemorySegment x0, MemorySegment V1, MemorySegment V2, MemorySegment Mask, MemorySegment Name) {
        var mh$ = LLVMBuildShuffleVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildShuffleVector", x0, V1, V2, Mask, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, V1, V2, Mask, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildExtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildExtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal, unsigned int Index, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildExtractValue$descriptor() {
        return LLVMBuildExtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal, unsigned int Index, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildExtractValue$handle() {
        return LLVMBuildExtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal, unsigned int Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExtractValue$address() {
        return LLVMBuildExtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal, unsigned int Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExtractValue(MemorySegment x0, MemorySegment AggVal, int Index, MemorySegment Name) {
        var mh$ = LLVMBuildExtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildExtractValue", x0, AggVal, Index, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, AggVal, Index, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInsertValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInsertValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal, LLVMValueRef EltVal, unsigned int Index, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInsertValue$descriptor() {
        return LLVMBuildInsertValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal, LLVMValueRef EltVal, unsigned int Index, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInsertValue$handle() {
        return LLVMBuildInsertValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal, LLVMValueRef EltVal, unsigned int Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInsertValue$address() {
        return LLVMBuildInsertValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal, LLVMValueRef EltVal, unsigned int Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInsertValue(MemorySegment x0, MemorySegment AggVal, MemorySegment EltVal, int Index, MemorySegment Name) {
        var mh$ = LLVMBuildInsertValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInsertValue", x0, AggVal, EltVal, Index, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, AggVal, EltVal, Index, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFreeze {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFreeze");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFreeze(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFreeze$descriptor() {
        return LLVMBuildFreeze.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFreeze(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFreeze$handle() {
        return LLVMBuildFreeze.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFreeze(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFreeze$address() {
        return LLVMBuildFreeze.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFreeze(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFreeze(MemorySegment x0, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildFreeze.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFreeze", x0, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIsNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIsNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIsNull$descriptor() {
        return LLVMBuildIsNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIsNull$handle() {
        return LLVMBuildIsNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIsNull$address() {
        return LLVMBuildIsNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIsNull(MemorySegment x0, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildIsNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIsNull", x0, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIsNotNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIsNotNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIsNotNull$descriptor() {
        return LLVMBuildIsNotNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIsNotNull$handle() {
        return LLVMBuildIsNotNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIsNotNull$address() {
        return LLVMBuildIsNotNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIsNotNull(MemorySegment x0, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildIsNotNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIsNotNull", x0, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildPtrDiff2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildPtrDiff2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrDiff2(LLVMBuilderRef, LLVMTypeRef ElemTy, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildPtrDiff2$descriptor() {
        return LLVMBuildPtrDiff2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrDiff2(LLVMBuilderRef, LLVMTypeRef ElemTy, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildPtrDiff2$handle() {
        return LLVMBuildPtrDiff2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrDiff2(LLVMBuilderRef, LLVMTypeRef ElemTy, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPtrDiff2$address() {
        return LLVMBuildPtrDiff2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrDiff2(LLVMBuilderRef, LLVMTypeRef ElemTy, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPtrDiff2(MemorySegment x0, MemorySegment ElemTy, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildPtrDiff2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildPtrDiff2", x0, ElemTy, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, ElemTy, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering, LLVMBool singleThread, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFence$descriptor() {
        return LLVMBuildFence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering, LLVMBool singleThread, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFence$handle() {
        return LLVMBuildFence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering, LLVMBool singleThread, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFence$address() {
        return LLVMBuildFence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering, LLVMBool singleThread, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFence(MemorySegment B, int ordering, int singleThread, MemorySegment Name) {
        var mh$ = LLVMBuildFence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFence", B, ordering, singleThread, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ordering, singleThread, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFenceSyncScope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFenceSyncScope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFenceSyncScope(LLVMBuilderRef B, LLVMAtomicOrdering ordering, unsigned int SSID, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFenceSyncScope$descriptor() {
        return LLVMBuildFenceSyncScope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFenceSyncScope(LLVMBuilderRef B, LLVMAtomicOrdering ordering, unsigned int SSID, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFenceSyncScope$handle() {
        return LLVMBuildFenceSyncScope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFenceSyncScope(LLVMBuilderRef B, LLVMAtomicOrdering ordering, unsigned int SSID, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFenceSyncScope$address() {
        return LLVMBuildFenceSyncScope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFenceSyncScope(LLVMBuilderRef B, LLVMAtomicOrdering ordering, unsigned int SSID, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFenceSyncScope(MemorySegment B, int ordering, int SSID, MemorySegment Name) {
        var mh$ = LLVMBuildFenceSyncScope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFenceSyncScope", B, ordering, SSID, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ordering, SSID, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAtomicRMW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAtomicRMW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, LLVMBool singleThread)
     * }
     */
    public static FunctionDescriptor LLVMBuildAtomicRMW$descriptor() {
        return LLVMBuildAtomicRMW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, LLVMBool singleThread)
     * }
     */
    public static MethodHandle LLVMBuildAtomicRMW$handle() {
        return LLVMBuildAtomicRMW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, LLVMBool singleThread)
     * }
     */
    public static MemorySegment LLVMBuildAtomicRMW$address() {
        return LLVMBuildAtomicRMW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, LLVMBool singleThread)
     * }
     */
    public static MemorySegment LLVMBuildAtomicRMW(MemorySegment B, int op, MemorySegment PTR, MemorySegment Val, int ordering, int singleThread) {
        var mh$ = LLVMBuildAtomicRMW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAtomicRMW", B, op, PTR, Val, ordering, singleThread);
            }
            return (MemorySegment)mh$.invokeExact(B, op, PTR, Val, ordering, singleThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAtomicRMWSyncScope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAtomicRMWSyncScope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMWSyncScope(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, unsigned int SSID)
     * }
     */
    public static FunctionDescriptor LLVMBuildAtomicRMWSyncScope$descriptor() {
        return LLVMBuildAtomicRMWSyncScope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMWSyncScope(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, unsigned int SSID)
     * }
     */
    public static MethodHandle LLVMBuildAtomicRMWSyncScope$handle() {
        return LLVMBuildAtomicRMWSyncScope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMWSyncScope(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMBuildAtomicRMWSyncScope$address() {
        return LLVMBuildAtomicRMWSyncScope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMWSyncScope(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMBuildAtomicRMWSyncScope(MemorySegment B, int op, MemorySegment PTR, MemorySegment Val, int ordering, int SSID) {
        var mh$ = LLVMBuildAtomicRMWSyncScope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAtomicRMWSyncScope", B, op, PTR, Val, ordering, SSID);
            }
            return (MemorySegment)mh$.invokeExact(B, op, PTR, Val, ordering, SSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAtomicCmpXchg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAtomicCmpXchg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, LLVMBool SingleThread)
     * }
     */
    public static FunctionDescriptor LLVMBuildAtomicCmpXchg$descriptor() {
        return LLVMBuildAtomicCmpXchg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, LLVMBool SingleThread)
     * }
     */
    public static MethodHandle LLVMBuildAtomicCmpXchg$handle() {
        return LLVMBuildAtomicCmpXchg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, LLVMBool SingleThread)
     * }
     */
    public static MemorySegment LLVMBuildAtomicCmpXchg$address() {
        return LLVMBuildAtomicCmpXchg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, LLVMBool SingleThread)
     * }
     */
    public static MemorySegment LLVMBuildAtomicCmpXchg(MemorySegment B, MemorySegment Ptr, MemorySegment Cmp, MemorySegment New, int SuccessOrdering, int FailureOrdering, int SingleThread) {
        var mh$ = LLVMBuildAtomicCmpXchg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAtomicCmpXchg", B, Ptr, Cmp, New, SuccessOrdering, FailureOrdering, SingleThread);
            }
            return (MemorySegment)mh$.invokeExact(B, Ptr, Cmp, New, SuccessOrdering, FailureOrdering, SingleThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAtomicCmpXchgSyncScope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAtomicCmpXchgSyncScope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchgSyncScope(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, unsigned int SSID)
     * }
     */
    public static FunctionDescriptor LLVMBuildAtomicCmpXchgSyncScope$descriptor() {
        return LLVMBuildAtomicCmpXchgSyncScope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchgSyncScope(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, unsigned int SSID)
     * }
     */
    public static MethodHandle LLVMBuildAtomicCmpXchgSyncScope$handle() {
        return LLVMBuildAtomicCmpXchgSyncScope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchgSyncScope(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMBuildAtomicCmpXchgSyncScope$address() {
        return LLVMBuildAtomicCmpXchgSyncScope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchgSyncScope(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMBuildAtomicCmpXchgSyncScope(MemorySegment B, MemorySegment Ptr, MemorySegment Cmp, MemorySegment New, int SuccessOrdering, int FailureOrdering, int SSID) {
        var mh$ = LLVMBuildAtomicCmpXchgSyncScope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAtomicCmpXchgSyncScope", B, Ptr, Cmp, New, SuccessOrdering, FailureOrdering, SSID);
            }
            return (MemorySegment)mh$.invokeExact(B, Ptr, Cmp, New, SuccessOrdering, FailureOrdering, SSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumMaskElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumMaskElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumMaskElements(LLVMValueRef ShuffleVectorInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNumMaskElements$descriptor() {
        return LLVMGetNumMaskElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumMaskElements(LLVMValueRef ShuffleVectorInst)
     * }
     */
    public static MethodHandle LLVMGetNumMaskElements$handle() {
        return LLVMGetNumMaskElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumMaskElements(LLVMValueRef ShuffleVectorInst)
     * }
     */
    public static MemorySegment LLVMGetNumMaskElements$address() {
        return LLVMGetNumMaskElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumMaskElements(LLVMValueRef ShuffleVectorInst)
     * }
     */
    public static int LLVMGetNumMaskElements(MemorySegment ShuffleVectorInst) {
        var mh$ = LLVMGetNumMaskElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumMaskElements", ShuffleVectorInst);
            }
            return (int)mh$.invokeExact(ShuffleVectorInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetUndefMaskElem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetUndefMaskElem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LLVMGetUndefMaskElem()
     * }
     */
    public static FunctionDescriptor LLVMGetUndefMaskElem$descriptor() {
        return LLVMGetUndefMaskElem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LLVMGetUndefMaskElem()
     * }
     */
    public static MethodHandle LLVMGetUndefMaskElem$handle() {
        return LLVMGetUndefMaskElem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LLVMGetUndefMaskElem()
     * }
     */
    public static MemorySegment LLVMGetUndefMaskElem$address() {
        return LLVMGetUndefMaskElem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LLVMGetUndefMaskElem()
     * }
     */
    public static int LLVMGetUndefMaskElem() {
        var mh$ = LLVMGetUndefMaskElem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetUndefMaskElem");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMaskValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMaskValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LLVMGetMaskValue(LLVMValueRef ShuffleVectorInst, unsigned int Elt)
     * }
     */
    public static FunctionDescriptor LLVMGetMaskValue$descriptor() {
        return LLVMGetMaskValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LLVMGetMaskValue(LLVMValueRef ShuffleVectorInst, unsigned int Elt)
     * }
     */
    public static MethodHandle LLVMGetMaskValue$handle() {
        return LLVMGetMaskValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LLVMGetMaskValue(LLVMValueRef ShuffleVectorInst, unsigned int Elt)
     * }
     */
    public static MemorySegment LLVMGetMaskValue$address() {
        return LLVMGetMaskValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LLVMGetMaskValue(LLVMValueRef ShuffleVectorInst, unsigned int Elt)
     * }
     */
    public static int LLVMGetMaskValue(MemorySegment ShuffleVectorInst, int Elt) {
        var mh$ = LLVMGetMaskValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMaskValue", ShuffleVectorInst, Elt);
            }
            return (int)mh$.invokeExact(ShuffleVectorInst, Elt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAtomicSingleThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAtomicSingleThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst)
     * }
     */
    public static FunctionDescriptor LLVMIsAtomicSingleThread$descriptor() {
        return LLVMIsAtomicSingleThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst)
     * }
     */
    public static MethodHandle LLVMIsAtomicSingleThread$handle() {
        return LLVMIsAtomicSingleThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst)
     * }
     */
    public static MemorySegment LLVMIsAtomicSingleThread$address() {
        return LLVMIsAtomicSingleThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst)
     * }
     */
    public static int LLVMIsAtomicSingleThread(MemorySegment AtomicInst) {
        var mh$ = LLVMIsAtomicSingleThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAtomicSingleThread", AtomicInst);
            }
            return (int)mh$.invokeExact(AtomicInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetAtomicSingleThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetAtomicSingleThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread)
     * }
     */
    public static FunctionDescriptor LLVMSetAtomicSingleThread$descriptor() {
        return LLVMSetAtomicSingleThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread)
     * }
     */
    public static MethodHandle LLVMSetAtomicSingleThread$handle() {
        return LLVMSetAtomicSingleThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread)
     * }
     */
    public static MemorySegment LLVMSetAtomicSingleThread$address() {
        return LLVMSetAtomicSingleThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread)
     * }
     */
    public static void LLVMSetAtomicSingleThread(MemorySegment AtomicInst, int SingleThread) {
        var mh$ = LLVMSetAtomicSingleThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetAtomicSingleThread", AtomicInst, SingleThread);
            }
            mh$.invokeExact(AtomicInst, SingleThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAtomic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAtomic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomic(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMIsAtomic$descriptor() {
        return LLVMIsAtomic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomic(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMIsAtomic$handle() {
        return LLVMIsAtomic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomic(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMIsAtomic$address() {
        return LLVMIsAtomic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomic(LLVMValueRef Inst)
     * }
     */
    public static int LLVMIsAtomic(MemorySegment Inst) {
        var mh$ = LLVMIsAtomic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAtomic", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAtomicSyncScopeID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAtomicSyncScopeID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAtomicSyncScopeID(LLVMValueRef AtomicInst)
     * }
     */
    public static FunctionDescriptor LLVMGetAtomicSyncScopeID$descriptor() {
        return LLVMGetAtomicSyncScopeID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAtomicSyncScopeID(LLVMValueRef AtomicInst)
     * }
     */
    public static MethodHandle LLVMGetAtomicSyncScopeID$handle() {
        return LLVMGetAtomicSyncScopeID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAtomicSyncScopeID(LLVMValueRef AtomicInst)
     * }
     */
    public static MemorySegment LLVMGetAtomicSyncScopeID$address() {
        return LLVMGetAtomicSyncScopeID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetAtomicSyncScopeID(LLVMValueRef AtomicInst)
     * }
     */
    public static int LLVMGetAtomicSyncScopeID(MemorySegment AtomicInst) {
        var mh$ = LLVMGetAtomicSyncScopeID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAtomicSyncScopeID", AtomicInst);
            }
            return (int)mh$.invokeExact(AtomicInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetAtomicSyncScopeID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetAtomicSyncScopeID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSyncScopeID(LLVMValueRef AtomicInst, unsigned int SSID)
     * }
     */
    public static FunctionDescriptor LLVMSetAtomicSyncScopeID$descriptor() {
        return LLVMSetAtomicSyncScopeID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSyncScopeID(LLVMValueRef AtomicInst, unsigned int SSID)
     * }
     */
    public static MethodHandle LLVMSetAtomicSyncScopeID$handle() {
        return LLVMSetAtomicSyncScopeID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSyncScopeID(LLVMValueRef AtomicInst, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMSetAtomicSyncScopeID$address() {
        return LLVMSetAtomicSyncScopeID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetAtomicSyncScopeID(LLVMValueRef AtomicInst, unsigned int SSID)
     * }
     */
    public static void LLVMSetAtomicSyncScopeID(MemorySegment AtomicInst, int SSID) {
        var mh$ = LLVMSetAtomicSyncScopeID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetAtomicSyncScopeID", AtomicInst, SSID);
            }
            mh$.invokeExact(AtomicInst, SSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCmpXchgSuccessOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCmpXchgSuccessOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static FunctionDescriptor LLVMGetCmpXchgSuccessOrdering$descriptor() {
        return LLVMGetCmpXchgSuccessOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MethodHandle LLVMGetCmpXchgSuccessOrdering$handle() {
        return LLVMGetCmpXchgSuccessOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MemorySegment LLVMGetCmpXchgSuccessOrdering$address() {
        return LLVMGetCmpXchgSuccessOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static int LLVMGetCmpXchgSuccessOrdering(MemorySegment CmpXchgInst) {
        var mh$ = LLVMGetCmpXchgSuccessOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCmpXchgSuccessOrdering", CmpXchgInst);
            }
            return (int)mh$.invokeExact(CmpXchgInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCmpXchgSuccessOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCmpXchgSuccessOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static FunctionDescriptor LLVMSetCmpXchgSuccessOrdering$descriptor() {
        return LLVMSetCmpXchgSuccessOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MethodHandle LLVMSetCmpXchgSuccessOrdering$handle() {
        return LLVMSetCmpXchgSuccessOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MemorySegment LLVMSetCmpXchgSuccessOrdering$address() {
        return LLVMSetCmpXchgSuccessOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static void LLVMSetCmpXchgSuccessOrdering(MemorySegment CmpXchgInst, int Ordering) {
        var mh$ = LLVMSetCmpXchgSuccessOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCmpXchgSuccessOrdering", CmpXchgInst, Ordering);
            }
            mh$.invokeExact(CmpXchgInst, Ordering);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCmpXchgFailureOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCmpXchgFailureOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static FunctionDescriptor LLVMGetCmpXchgFailureOrdering$descriptor() {
        return LLVMGetCmpXchgFailureOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MethodHandle LLVMGetCmpXchgFailureOrdering$handle() {
        return LLVMGetCmpXchgFailureOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MemorySegment LLVMGetCmpXchgFailureOrdering$address() {
        return LLVMGetCmpXchgFailureOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static int LLVMGetCmpXchgFailureOrdering(MemorySegment CmpXchgInst) {
        var mh$ = LLVMGetCmpXchgFailureOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCmpXchgFailureOrdering", CmpXchgInst);
            }
            return (int)mh$.invokeExact(CmpXchgInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCmpXchgFailureOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCmpXchgFailureOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static FunctionDescriptor LLVMSetCmpXchgFailureOrdering$descriptor() {
        return LLVMSetCmpXchgFailureOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MethodHandle LLVMSetCmpXchgFailureOrdering$handle() {
        return LLVMSetCmpXchgFailureOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MemorySegment LLVMSetCmpXchgFailureOrdering$address() {
        return LLVMSetCmpXchgFailureOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static void LLVMSetCmpXchgFailureOrdering(MemorySegment CmpXchgInst, int Ordering) {
        var mh$ = LLVMSetCmpXchgFailureOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCmpXchgFailureOrdering", CmpXchgInst, Ordering);
            }
            mh$.invokeExact(CmpXchgInst, Ordering);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateModuleProviderForExistingModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateModuleProviderForExistingModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMCreateModuleProviderForExistingModule$descriptor() {
        return LLVMCreateModuleProviderForExistingModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMCreateModuleProviderForExistingModule$handle() {
        return LLVMCreateModuleProviderForExistingModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCreateModuleProviderForExistingModule$address() {
        return LLVMCreateModuleProviderForExistingModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCreateModuleProviderForExistingModule(MemorySegment M) {
        var mh$ = LLVMCreateModuleProviderForExistingModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateModuleProviderForExistingModule", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeModuleProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeModuleProvider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleProvider(LLVMModuleProviderRef M)
     * }
     */
    public static FunctionDescriptor LLVMDisposeModuleProvider$descriptor() {
        return LLVMDisposeModuleProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleProvider(LLVMModuleProviderRef M)
     * }
     */
    public static MethodHandle LLVMDisposeModuleProvider$handle() {
        return LLVMDisposeModuleProvider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleProvider(LLVMModuleProviderRef M)
     * }
     */
    public static MemorySegment LLVMDisposeModuleProvider$address() {
        return LLVMDisposeModuleProvider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeModuleProvider(LLVMModuleProviderRef M)
     * }
     */
    public static void LLVMDisposeModuleProvider(MemorySegment M) {
        var mh$ = LLVMDisposeModuleProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeModuleProvider", M);
            }
            mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMemoryBufferWithContentsOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMemoryBufferWithContentsOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path, LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static FunctionDescriptor LLVMCreateMemoryBufferWithContentsOfFile$descriptor() {
        return LLVMCreateMemoryBufferWithContentsOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path, LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static MethodHandle LLVMCreateMemoryBufferWithContentsOfFile$handle() {
        return LLVMCreateMemoryBufferWithContentsOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path, LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithContentsOfFile$address() {
        return LLVMCreateMemoryBufferWithContentsOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path, LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static int LLVMCreateMemoryBufferWithContentsOfFile(MemorySegment Path, MemorySegment OutMemBuf, MemorySegment OutMessage) {
        var mh$ = LLVMCreateMemoryBufferWithContentsOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMemoryBufferWithContentsOfFile", Path, OutMemBuf, OutMessage);
            }
            return (int)mh$.invokeExact(Path, OutMemBuf, OutMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMemoryBufferWithSTDIN {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMemoryBufferWithSTDIN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static FunctionDescriptor LLVMCreateMemoryBufferWithSTDIN$descriptor() {
        return LLVMCreateMemoryBufferWithSTDIN.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static MethodHandle LLVMCreateMemoryBufferWithSTDIN$handle() {
        return LLVMCreateMemoryBufferWithSTDIN.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithSTDIN$address() {
        return LLVMCreateMemoryBufferWithSTDIN.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static int LLVMCreateMemoryBufferWithSTDIN(MemorySegment OutMemBuf, MemorySegment OutMessage) {
        var mh$ = LLVMCreateMemoryBufferWithSTDIN.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMemoryBufferWithSTDIN", OutMemBuf, OutMessage);
            }
            return (int)mh$.invokeExact(OutMemBuf, OutMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMemoryBufferWithMemoryRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMemoryBufferWithMemoryRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData, size_t InputDataLength, const char *BufferName, LLVMBool RequiresNullTerminator)
     * }
     */
    public static FunctionDescriptor LLVMCreateMemoryBufferWithMemoryRange$descriptor() {
        return LLVMCreateMemoryBufferWithMemoryRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData, size_t InputDataLength, const char *BufferName, LLVMBool RequiresNullTerminator)
     * }
     */
    public static MethodHandle LLVMCreateMemoryBufferWithMemoryRange$handle() {
        return LLVMCreateMemoryBufferWithMemoryRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData, size_t InputDataLength, const char *BufferName, LLVMBool RequiresNullTerminator)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithMemoryRange$address() {
        return LLVMCreateMemoryBufferWithMemoryRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData, size_t InputDataLength, const char *BufferName, LLVMBool RequiresNullTerminator)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithMemoryRange(MemorySegment InputData, long InputDataLength, MemorySegment BufferName, int RequiresNullTerminator) {
        var mh$ = LLVMCreateMemoryBufferWithMemoryRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMemoryBufferWithMemoryRange", InputData, InputDataLength, BufferName, RequiresNullTerminator);
            }
            return (MemorySegment)mh$.invokeExact(InputData, InputDataLength, BufferName, RequiresNullTerminator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMemoryBufferWithMemoryRangeCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMemoryBufferWithMemoryRangeCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData, size_t InputDataLength, const char *BufferName)
     * }
     */
    public static FunctionDescriptor LLVMCreateMemoryBufferWithMemoryRangeCopy$descriptor() {
        return LLVMCreateMemoryBufferWithMemoryRangeCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData, size_t InputDataLength, const char *BufferName)
     * }
     */
    public static MethodHandle LLVMCreateMemoryBufferWithMemoryRangeCopy$handle() {
        return LLVMCreateMemoryBufferWithMemoryRangeCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData, size_t InputDataLength, const char *BufferName)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithMemoryRangeCopy$address() {
        return LLVMCreateMemoryBufferWithMemoryRangeCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData, size_t InputDataLength, const char *BufferName)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithMemoryRangeCopy(MemorySegment InputData, long InputDataLength, MemorySegment BufferName) {
        var mh$ = LLVMCreateMemoryBufferWithMemoryRangeCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMemoryBufferWithMemoryRangeCopy", InputData, InputDataLength, BufferName);
            }
            return (MemorySegment)mh$.invokeExact(InputData, InputDataLength, BufferName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBufferStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBufferStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static FunctionDescriptor LLVMGetBufferStart$descriptor() {
        return LLVMGetBufferStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MethodHandle LLVMGetBufferStart$handle() {
        return LLVMGetBufferStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MemorySegment LLVMGetBufferStart$address() {
        return LLVMGetBufferStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MemorySegment LLVMGetBufferStart(MemorySegment MemBuf) {
        var mh$ = LLVMGetBufferStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBufferStart", MemBuf);
            }
            return (MemorySegment)mh$.invokeExact(MemBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static FunctionDescriptor LLVMGetBufferSize$descriptor() {
        return LLVMGetBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MethodHandle LLVMGetBufferSize$handle() {
        return LLVMGetBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MemorySegment LLVMGetBufferSize$address() {
        return LLVMGetBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static long LLVMGetBufferSize(MemorySegment MemBuf) {
        var mh$ = LLVMGetBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBufferSize", MemBuf);
            }
            return (long)mh$.invokeExact(MemBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeMemoryBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeMemoryBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static FunctionDescriptor LLVMDisposeMemoryBuffer$descriptor() {
        return LLVMDisposeMemoryBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MethodHandle LLVMDisposeMemoryBuffer$handle() {
        return LLVMDisposeMemoryBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MemorySegment LLVMDisposeMemoryBuffer$address() {
        return LLVMDisposeMemoryBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static void LLVMDisposeMemoryBuffer(MemorySegment MemBuf) {
        var mh$ = LLVMDisposeMemoryBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeMemoryBuffer", MemBuf);
            }
            mh$.invokeExact(MemBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreatePassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreatePassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreatePassManager()
     * }
     */
    public static FunctionDescriptor LLVMCreatePassManager$descriptor() {
        return LLVMCreatePassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreatePassManager()
     * }
     */
    public static MethodHandle LLVMCreatePassManager$handle() {
        return LLVMCreatePassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreatePassManager()
     * }
     */
    public static MemorySegment LLVMCreatePassManager$address() {
        return LLVMCreatePassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreatePassManager()
     * }
     */
    public static MemorySegment LLVMCreatePassManager() {
        var mh$ = LLVMCreatePassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreatePassManager");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateFunctionPassManagerForModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateFunctionPassManagerForModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMCreateFunctionPassManagerForModule$descriptor() {
        return LLVMCreateFunctionPassManagerForModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMCreateFunctionPassManagerForModule$handle() {
        return LLVMCreateFunctionPassManagerForModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCreateFunctionPassManagerForModule$address() {
        return LLVMCreateFunctionPassManagerForModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCreateFunctionPassManagerForModule(MemorySegment M) {
        var mh$ = LLVMCreateFunctionPassManagerForModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateFunctionPassManagerForModule", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateFunctionPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateFunctionPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP)
     * }
     */
    public static FunctionDescriptor LLVMCreateFunctionPassManager$descriptor() {
        return LLVMCreateFunctionPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP)
     * }
     */
    public static MethodHandle LLVMCreateFunctionPassManager$handle() {
        return LLVMCreateFunctionPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP)
     * }
     */
    public static MemorySegment LLVMCreateFunctionPassManager$address() {
        return LLVMCreateFunctionPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP)
     * }
     */
    public static MemorySegment LLVMCreateFunctionPassManager(MemorySegment MP) {
        var mh$ = LLVMCreateFunctionPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateFunctionPassManager", MP);
            }
            return (MemorySegment)mh$.invokeExact(MP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRunPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRunPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMRunPassManager$descriptor() {
        return LLVMRunPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMRunPassManager$handle() {
        return LLVMRunPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMRunPassManager$address() {
        return LLVMRunPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M)
     * }
     */
    public static int LLVMRunPassManager(MemorySegment PM, MemorySegment M) {
        var mh$ = LLVMRunPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRunPassManager", PM, M);
            }
            return (int)mh$.invokeExact(PM, M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeFunctionPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeFunctionPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static FunctionDescriptor LLVMInitializeFunctionPassManager$descriptor() {
        return LLVMInitializeFunctionPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static MethodHandle LLVMInitializeFunctionPassManager$handle() {
        return LLVMInitializeFunctionPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static MemorySegment LLVMInitializeFunctionPassManager$address() {
        return LLVMInitializeFunctionPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static int LLVMInitializeFunctionPassManager(MemorySegment FPM) {
        var mh$ = LLVMInitializeFunctionPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeFunctionPassManager", FPM);
            }
            return (int)mh$.invokeExact(FPM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRunFunctionPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRunFunctionPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F)
     * }
     */
    public static FunctionDescriptor LLVMRunFunctionPassManager$descriptor() {
        return LLVMRunFunctionPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F)
     * }
     */
    public static MethodHandle LLVMRunFunctionPassManager$handle() {
        return LLVMRunFunctionPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F)
     * }
     */
    public static MemorySegment LLVMRunFunctionPassManager$address() {
        return LLVMRunFunctionPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F)
     * }
     */
    public static int LLVMRunFunctionPassManager(MemorySegment FPM, MemorySegment F) {
        var mh$ = LLVMRunFunctionPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRunFunctionPassManager", FPM, F);
            }
            return (int)mh$.invokeExact(FPM, F);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFinalizeFunctionPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFinalizeFunctionPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static FunctionDescriptor LLVMFinalizeFunctionPassManager$descriptor() {
        return LLVMFinalizeFunctionPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static MethodHandle LLVMFinalizeFunctionPassManager$handle() {
        return LLVMFinalizeFunctionPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static MemorySegment LLVMFinalizeFunctionPassManager$address() {
        return LLVMFinalizeFunctionPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static int LLVMFinalizeFunctionPassManager(MemorySegment FPM) {
        var mh$ = LLVMFinalizeFunctionPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFinalizeFunctionPassManager", FPM);
            }
            return (int)mh$.invokeExact(FPM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposePassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposePassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposePassManager(LLVMPassManagerRef PM)
     * }
     */
    public static FunctionDescriptor LLVMDisposePassManager$descriptor() {
        return LLVMDisposePassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposePassManager(LLVMPassManagerRef PM)
     * }
     */
    public static MethodHandle LLVMDisposePassManager$handle() {
        return LLVMDisposePassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposePassManager(LLVMPassManagerRef PM)
     * }
     */
    public static MemorySegment LLVMDisposePassManager$address() {
        return LLVMDisposePassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposePassManager(LLVMPassManagerRef PM)
     * }
     */
    public static void LLVMDisposePassManager(MemorySegment PM) {
        var mh$ = LLVMDisposePassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposePassManager", PM);
            }
            mh$.invokeExact(PM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStartMultithreaded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStartMultithreaded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMStartMultithreaded()
     * }
     */
    public static FunctionDescriptor LLVMStartMultithreaded$descriptor() {
        return LLVMStartMultithreaded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMStartMultithreaded()
     * }
     */
    public static MethodHandle LLVMStartMultithreaded$handle() {
        return LLVMStartMultithreaded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMStartMultithreaded()
     * }
     */
    public static MemorySegment LLVMStartMultithreaded$address() {
        return LLVMStartMultithreaded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMStartMultithreaded()
     * }
     */
    public static int LLVMStartMultithreaded() {
        var mh$ = LLVMStartMultithreaded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStartMultithreaded");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStopMultithreaded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStopMultithreaded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMStopMultithreaded()
     * }
     */
    public static FunctionDescriptor LLVMStopMultithreaded$descriptor() {
        return LLVMStopMultithreaded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMStopMultithreaded()
     * }
     */
    public static MethodHandle LLVMStopMultithreaded$handle() {
        return LLVMStopMultithreaded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMStopMultithreaded()
     * }
     */
    public static MemorySegment LLVMStopMultithreaded$address() {
        return LLVMStopMultithreaded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMStopMultithreaded()
     * }
     */
    public static void LLVMStopMultithreaded() {
        var mh$ = LLVMStopMultithreaded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStopMultithreaded");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsMultithreaded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsMultithreaded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsMultithreaded()
     * }
     */
    public static FunctionDescriptor LLVMIsMultithreaded$descriptor() {
        return LLVMIsMultithreaded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsMultithreaded()
     * }
     */
    public static MethodHandle LLVMIsMultithreaded$handle() {
        return LLVMIsMultithreaded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsMultithreaded()
     * }
     */
    public static MemorySegment LLVMIsMultithreaded$address() {
        return LLVMIsMultithreaded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsMultithreaded()
     * }
     */
    public static int LLVMIsMultithreaded() {
        var mh$ = LLVMIsMultithreaded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsMultithreaded");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMLoadLibraryPermanently {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMLoadLibraryPermanently");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMLoadLibraryPermanently(const char *Filename)
     * }
     */
    public static FunctionDescriptor LLVMLoadLibraryPermanently$descriptor() {
        return LLVMLoadLibraryPermanently.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMLoadLibraryPermanently(const char *Filename)
     * }
     */
    public static MethodHandle LLVMLoadLibraryPermanently$handle() {
        return LLVMLoadLibraryPermanently.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMLoadLibraryPermanently(const char *Filename)
     * }
     */
    public static MemorySegment LLVMLoadLibraryPermanently$address() {
        return LLVMLoadLibraryPermanently.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMLoadLibraryPermanently(const char *Filename)
     * }
     */
    public static int LLVMLoadLibraryPermanently(MemorySegment Filename) {
        var mh$ = LLVMLoadLibraryPermanently.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMLoadLibraryPermanently", Filename);
            }
            return (int)mh$.invokeExact(Filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMParseCommandLineOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMParseCommandLineOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMParseCommandLineOptions(int argc, const char *const *argv, const char *Overview)
     * }
     */
    public static FunctionDescriptor LLVMParseCommandLineOptions$descriptor() {
        return LLVMParseCommandLineOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMParseCommandLineOptions(int argc, const char *const *argv, const char *Overview)
     * }
     */
    public static MethodHandle LLVMParseCommandLineOptions$handle() {
        return LLVMParseCommandLineOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMParseCommandLineOptions(int argc, const char *const *argv, const char *Overview)
     * }
     */
    public static MemorySegment LLVMParseCommandLineOptions$address() {
        return LLVMParseCommandLineOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMParseCommandLineOptions(int argc, const char *const *argv, const char *Overview)
     * }
     */
    public static void LLVMParseCommandLineOptions(int argc, MemorySegment argv, MemorySegment Overview) {
        var mh$ = LLVMParseCommandLineOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMParseCommandLineOptions", argc, argv, Overview);
            }
            mh$.invokeExact(argc, argv, Overview);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSearchForAddressOfSymbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSearchForAddressOfSymbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *LLVMSearchForAddressOfSymbol(const char *symbolName)
     * }
     */
    public static FunctionDescriptor LLVMSearchForAddressOfSymbol$descriptor() {
        return LLVMSearchForAddressOfSymbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *LLVMSearchForAddressOfSymbol(const char *symbolName)
     * }
     */
    public static MethodHandle LLVMSearchForAddressOfSymbol$handle() {
        return LLVMSearchForAddressOfSymbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *LLVMSearchForAddressOfSymbol(const char *symbolName)
     * }
     */
    public static MemorySegment LLVMSearchForAddressOfSymbol$address() {
        return LLVMSearchForAddressOfSymbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *LLVMSearchForAddressOfSymbol(const char *symbolName)
     * }
     */
    public static MemorySegment LLVMSearchForAddressOfSymbol(MemorySegment symbolName) {
        var mh$ = LLVMSearchForAddressOfSymbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSearchForAddressOfSymbol", symbolName);
            }
            return (MemorySegment)mh$.invokeExact(symbolName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddSymbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddSymbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddSymbol(const char *symbolName, void *symbolValue)
     * }
     */
    public static FunctionDescriptor LLVMAddSymbol$descriptor() {
        return LLVMAddSymbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddSymbol(const char *symbolName, void *symbolValue)
     * }
     */
    public static MethodHandle LLVMAddSymbol$handle() {
        return LLVMAddSymbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddSymbol(const char *symbolName, void *symbolValue)
     * }
     */
    public static MemorySegment LLVMAddSymbol$address() {
        return LLVMAddSymbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddSymbol(const char *symbolName, void *symbolValue)
     * }
     */
    public static void LLVMAddSymbol(MemorySegment symbolName, MemorySegment symbolValue) {
        var mh$ = LLVMAddSymbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddSymbol", symbolName, symbolValue);
            }
            mh$.invokeExact(symbolName, symbolValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int LLVMBigEndian = (int)0L;
    /**
     * {@snippet lang=c :
     * enum LLVMByteOrdering.LLVMBigEndian = 0
     * }
     */
    public static int LLVMBigEndian() {
        return LLVMBigEndian;
    }
    private static final int LLVMLittleEndian = (int)1L;
    /**
     * {@snippet lang=c :
     * enum LLVMByteOrdering.LLVMLittleEndian = 1
     * }
     */
    public static int LLVMLittleEndian() {
        return LLVMLittleEndian;
    }
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueTargetData *LLVMTargetDataRef
     * }
     */
    public static final AddressLayout LLVMTargetDataRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueTargetLibraryInfotData *LLVMTargetLibraryInfoRef
     * }
     */
    public static final AddressLayout LLVMTargetLibraryInfoRef = LLVM.C_POINTER;

    private static class LLVMInitializeAArch64TargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAArch64TargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64TargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAArch64TargetInfo$descriptor() {
        return LLVMInitializeAArch64TargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64TargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeAArch64TargetInfo$handle() {
        return LLVMInitializeAArch64TargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64TargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeAArch64TargetInfo$address() {
        return LLVMInitializeAArch64TargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAArch64TargetInfo()
     * }
     */
    public static void LLVMInitializeAArch64TargetInfo() {
        var mh$ = LLVMInitializeAArch64TargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAArch64TargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAMDGPUTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAMDGPUTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAMDGPUTargetInfo$descriptor() {
        return LLVMInitializeAMDGPUTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeAMDGPUTargetInfo$handle() {
        return LLVMInitializeAMDGPUTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeAMDGPUTargetInfo$address() {
        return LLVMInitializeAMDGPUTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTargetInfo()
     * }
     */
    public static void LLVMInitializeAMDGPUTargetInfo() {
        var mh$ = LLVMInitializeAMDGPUTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAMDGPUTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeARMTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeARMTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeARMTargetInfo$descriptor() {
        return LLVMInitializeARMTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeARMTargetInfo$handle() {
        return LLVMInitializeARMTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeARMTargetInfo$address() {
        return LLVMInitializeARMTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeARMTargetInfo()
     * }
     */
    public static void LLVMInitializeARMTargetInfo() {
        var mh$ = LLVMInitializeARMTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeARMTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAVRTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAVRTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAVRTargetInfo$descriptor() {
        return LLVMInitializeAVRTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeAVRTargetInfo$handle() {
        return LLVMInitializeAVRTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeAVRTargetInfo$address() {
        return LLVMInitializeAVRTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAVRTargetInfo()
     * }
     */
    public static void LLVMInitializeAVRTargetInfo() {
        var mh$ = LLVMInitializeAVRTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAVRTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeBPFTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeBPFTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeBPFTargetInfo$descriptor() {
        return LLVMInitializeBPFTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeBPFTargetInfo$handle() {
        return LLVMInitializeBPFTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeBPFTargetInfo$address() {
        return LLVMInitializeBPFTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeBPFTargetInfo()
     * }
     */
    public static void LLVMInitializeBPFTargetInfo() {
        var mh$ = LLVMInitializeBPFTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeBPFTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeHexagonTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeHexagonTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeHexagonTargetInfo$descriptor() {
        return LLVMInitializeHexagonTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeHexagonTargetInfo$handle() {
        return LLVMInitializeHexagonTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeHexagonTargetInfo$address() {
        return LLVMInitializeHexagonTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTargetInfo()
     * }
     */
    public static void LLVMInitializeHexagonTargetInfo() {
        var mh$ = LLVMInitializeHexagonTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeHexagonTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLanaiTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLanaiTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLanaiTargetInfo$descriptor() {
        return LLVMInitializeLanaiTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeLanaiTargetInfo$handle() {
        return LLVMInitializeLanaiTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeLanaiTargetInfo$address() {
        return LLVMInitializeLanaiTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTargetInfo()
     * }
     */
    public static void LLVMInitializeLanaiTargetInfo() {
        var mh$ = LLVMInitializeLanaiTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLanaiTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLoongArchTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLoongArchTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLoongArchTargetInfo$descriptor() {
        return LLVMInitializeLoongArchTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeLoongArchTargetInfo$handle() {
        return LLVMInitializeLoongArchTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeLoongArchTargetInfo$address() {
        return LLVMInitializeLoongArchTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTargetInfo()
     * }
     */
    public static void LLVMInitializeLoongArchTargetInfo() {
        var mh$ = LLVMInitializeLoongArchTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLoongArchTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMipsTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMipsTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMipsTargetInfo$descriptor() {
        return LLVMInitializeMipsTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeMipsTargetInfo$handle() {
        return LLVMInitializeMipsTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeMipsTargetInfo$address() {
        return LLVMInitializeMipsTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMipsTargetInfo()
     * }
     */
    public static void LLVMInitializeMipsTargetInfo() {
        var mh$ = LLVMInitializeMipsTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMipsTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMSP430TargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMSP430TargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430TargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMSP430TargetInfo$descriptor() {
        return LLVMInitializeMSP430TargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430TargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeMSP430TargetInfo$handle() {
        return LLVMInitializeMSP430TargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430TargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeMSP430TargetInfo$address() {
        return LLVMInitializeMSP430TargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMSP430TargetInfo()
     * }
     */
    public static void LLVMInitializeMSP430TargetInfo() {
        var mh$ = LLVMInitializeMSP430TargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMSP430TargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeNVPTXTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeNVPTXTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeNVPTXTargetInfo$descriptor() {
        return LLVMInitializeNVPTXTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeNVPTXTargetInfo$handle() {
        return LLVMInitializeNVPTXTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeNVPTXTargetInfo$address() {
        return LLVMInitializeNVPTXTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTargetInfo()
     * }
     */
    public static void LLVMInitializeNVPTXTargetInfo() {
        var mh$ = LLVMInitializeNVPTXTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeNVPTXTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializePowerPCTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializePowerPCTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializePowerPCTargetInfo$descriptor() {
        return LLVMInitializePowerPCTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializePowerPCTargetInfo$handle() {
        return LLVMInitializePowerPCTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializePowerPCTargetInfo$address() {
        return LLVMInitializePowerPCTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTargetInfo()
     * }
     */
    public static void LLVMInitializePowerPCTargetInfo() {
        var mh$ = LLVMInitializePowerPCTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializePowerPCTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeRISCVTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeRISCVTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeRISCVTargetInfo$descriptor() {
        return LLVMInitializeRISCVTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeRISCVTargetInfo$handle() {
        return LLVMInitializeRISCVTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeRISCVTargetInfo$address() {
        return LLVMInitializeRISCVTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTargetInfo()
     * }
     */
    public static void LLVMInitializeRISCVTargetInfo() {
        var mh$ = LLVMInitializeRISCVTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeRISCVTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSparcTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSparcTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSparcTargetInfo$descriptor() {
        return LLVMInitializeSparcTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeSparcTargetInfo$handle() {
        return LLVMInitializeSparcTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeSparcTargetInfo$address() {
        return LLVMInitializeSparcTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSparcTargetInfo()
     * }
     */
    public static void LLVMInitializeSparcTargetInfo() {
        var mh$ = LLVMInitializeSparcTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSparcTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSystemZTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSystemZTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSystemZTargetInfo$descriptor() {
        return LLVMInitializeSystemZTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeSystemZTargetInfo$handle() {
        return LLVMInitializeSystemZTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeSystemZTargetInfo$address() {
        return LLVMInitializeSystemZTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTargetInfo()
     * }
     */
    public static void LLVMInitializeSystemZTargetInfo() {
        var mh$ = LLVMInitializeSystemZTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSystemZTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeVETargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeVETargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeVETargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeVETargetInfo$descriptor() {
        return LLVMInitializeVETargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeVETargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeVETargetInfo$handle() {
        return LLVMInitializeVETargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeVETargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeVETargetInfo$address() {
        return LLVMInitializeVETargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeVETargetInfo()
     * }
     */
    public static void LLVMInitializeVETargetInfo() {
        var mh$ = LLVMInitializeVETargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeVETargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeWebAssemblyTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeWebAssemblyTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeWebAssemblyTargetInfo$descriptor() {
        return LLVMInitializeWebAssemblyTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeWebAssemblyTargetInfo$handle() {
        return LLVMInitializeWebAssemblyTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeWebAssemblyTargetInfo$address() {
        return LLVMInitializeWebAssemblyTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTargetInfo()
     * }
     */
    public static void LLVMInitializeWebAssemblyTargetInfo() {
        var mh$ = LLVMInitializeWebAssemblyTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeWebAssemblyTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeX86TargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeX86TargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeX86TargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeX86TargetInfo$descriptor() {
        return LLVMInitializeX86TargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeX86TargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeX86TargetInfo$handle() {
        return LLVMInitializeX86TargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeX86TargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeX86TargetInfo$address() {
        return LLVMInitializeX86TargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeX86TargetInfo()
     * }
     */
    public static void LLVMInitializeX86TargetInfo() {
        var mh$ = LLVMInitializeX86TargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeX86TargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXCoreTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXCoreTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXCoreTargetInfo$descriptor() {
        return LLVMInitializeXCoreTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeXCoreTargetInfo$handle() {
        return LLVMInitializeXCoreTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeXCoreTargetInfo$address() {
        return LLVMInitializeXCoreTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTargetInfo()
     * }
     */
    public static void LLVMInitializeXCoreTargetInfo() {
        var mh$ = LLVMInitializeXCoreTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXCoreTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeM68kTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeM68kTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeM68kTargetInfo$descriptor() {
        return LLVMInitializeM68kTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeM68kTargetInfo$handle() {
        return LLVMInitializeM68kTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeM68kTargetInfo$address() {
        return LLVMInitializeM68kTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeM68kTargetInfo()
     * }
     */
    public static void LLVMInitializeM68kTargetInfo() {
        var mh$ = LLVMInitializeM68kTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeM68kTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXtensaTargetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXtensaTargetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTargetInfo()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXtensaTargetInfo$descriptor() {
        return LLVMInitializeXtensaTargetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTargetInfo()
     * }
     */
    public static MethodHandle LLVMInitializeXtensaTargetInfo$handle() {
        return LLVMInitializeXtensaTargetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTargetInfo()
     * }
     */
    public static MemorySegment LLVMInitializeXtensaTargetInfo$address() {
        return LLVMInitializeXtensaTargetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTargetInfo()
     * }
     */
    public static void LLVMInitializeXtensaTargetInfo() {
        var mh$ = LLVMInitializeXtensaTargetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXtensaTargetInfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAArch64Target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAArch64Target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64Target()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAArch64Target$descriptor() {
        return LLVMInitializeAArch64Target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64Target()
     * }
     */
    public static MethodHandle LLVMInitializeAArch64Target$handle() {
        return LLVMInitializeAArch64Target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64Target()
     * }
     */
    public static MemorySegment LLVMInitializeAArch64Target$address() {
        return LLVMInitializeAArch64Target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAArch64Target()
     * }
     */
    public static void LLVMInitializeAArch64Target() {
        var mh$ = LLVMInitializeAArch64Target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAArch64Target");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAMDGPUTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAMDGPUTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAMDGPUTarget$descriptor() {
        return LLVMInitializeAMDGPUTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTarget()
     * }
     */
    public static MethodHandle LLVMInitializeAMDGPUTarget$handle() {
        return LLVMInitializeAMDGPUTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTarget()
     * }
     */
    public static MemorySegment LLVMInitializeAMDGPUTarget$address() {
        return LLVMInitializeAMDGPUTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTarget()
     * }
     */
    public static void LLVMInitializeAMDGPUTarget() {
        var mh$ = LLVMInitializeAMDGPUTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAMDGPUTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeARMTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeARMTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeARMTarget$descriptor() {
        return LLVMInitializeARMTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTarget()
     * }
     */
    public static MethodHandle LLVMInitializeARMTarget$handle() {
        return LLVMInitializeARMTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTarget()
     * }
     */
    public static MemorySegment LLVMInitializeARMTarget$address() {
        return LLVMInitializeARMTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeARMTarget()
     * }
     */
    public static void LLVMInitializeARMTarget() {
        var mh$ = LLVMInitializeARMTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeARMTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAVRTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAVRTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAVRTarget$descriptor() {
        return LLVMInitializeAVRTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTarget()
     * }
     */
    public static MethodHandle LLVMInitializeAVRTarget$handle() {
        return LLVMInitializeAVRTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTarget()
     * }
     */
    public static MemorySegment LLVMInitializeAVRTarget$address() {
        return LLVMInitializeAVRTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAVRTarget()
     * }
     */
    public static void LLVMInitializeAVRTarget() {
        var mh$ = LLVMInitializeAVRTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAVRTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeBPFTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeBPFTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeBPFTarget$descriptor() {
        return LLVMInitializeBPFTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTarget()
     * }
     */
    public static MethodHandle LLVMInitializeBPFTarget$handle() {
        return LLVMInitializeBPFTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTarget()
     * }
     */
    public static MemorySegment LLVMInitializeBPFTarget$address() {
        return LLVMInitializeBPFTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeBPFTarget()
     * }
     */
    public static void LLVMInitializeBPFTarget() {
        var mh$ = LLVMInitializeBPFTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeBPFTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeHexagonTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeHexagonTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeHexagonTarget$descriptor() {
        return LLVMInitializeHexagonTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTarget()
     * }
     */
    public static MethodHandle LLVMInitializeHexagonTarget$handle() {
        return LLVMInitializeHexagonTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTarget()
     * }
     */
    public static MemorySegment LLVMInitializeHexagonTarget$address() {
        return LLVMInitializeHexagonTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTarget()
     * }
     */
    public static void LLVMInitializeHexagonTarget() {
        var mh$ = LLVMInitializeHexagonTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeHexagonTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLanaiTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLanaiTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLanaiTarget$descriptor() {
        return LLVMInitializeLanaiTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTarget()
     * }
     */
    public static MethodHandle LLVMInitializeLanaiTarget$handle() {
        return LLVMInitializeLanaiTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTarget()
     * }
     */
    public static MemorySegment LLVMInitializeLanaiTarget$address() {
        return LLVMInitializeLanaiTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTarget()
     * }
     */
    public static void LLVMInitializeLanaiTarget() {
        var mh$ = LLVMInitializeLanaiTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLanaiTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLoongArchTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLoongArchTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLoongArchTarget$descriptor() {
        return LLVMInitializeLoongArchTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTarget()
     * }
     */
    public static MethodHandle LLVMInitializeLoongArchTarget$handle() {
        return LLVMInitializeLoongArchTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTarget()
     * }
     */
    public static MemorySegment LLVMInitializeLoongArchTarget$address() {
        return LLVMInitializeLoongArchTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTarget()
     * }
     */
    public static void LLVMInitializeLoongArchTarget() {
        var mh$ = LLVMInitializeLoongArchTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLoongArchTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMipsTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMipsTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMipsTarget$descriptor() {
        return LLVMInitializeMipsTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTarget()
     * }
     */
    public static MethodHandle LLVMInitializeMipsTarget$handle() {
        return LLVMInitializeMipsTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTarget()
     * }
     */
    public static MemorySegment LLVMInitializeMipsTarget$address() {
        return LLVMInitializeMipsTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMipsTarget()
     * }
     */
    public static void LLVMInitializeMipsTarget() {
        var mh$ = LLVMInitializeMipsTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMipsTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMSP430Target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMSP430Target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430Target()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMSP430Target$descriptor() {
        return LLVMInitializeMSP430Target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430Target()
     * }
     */
    public static MethodHandle LLVMInitializeMSP430Target$handle() {
        return LLVMInitializeMSP430Target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430Target()
     * }
     */
    public static MemorySegment LLVMInitializeMSP430Target$address() {
        return LLVMInitializeMSP430Target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMSP430Target()
     * }
     */
    public static void LLVMInitializeMSP430Target() {
        var mh$ = LLVMInitializeMSP430Target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMSP430Target");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeNVPTXTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeNVPTXTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeNVPTXTarget$descriptor() {
        return LLVMInitializeNVPTXTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTarget()
     * }
     */
    public static MethodHandle LLVMInitializeNVPTXTarget$handle() {
        return LLVMInitializeNVPTXTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTarget()
     * }
     */
    public static MemorySegment LLVMInitializeNVPTXTarget$address() {
        return LLVMInitializeNVPTXTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTarget()
     * }
     */
    public static void LLVMInitializeNVPTXTarget() {
        var mh$ = LLVMInitializeNVPTXTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeNVPTXTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializePowerPCTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializePowerPCTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializePowerPCTarget$descriptor() {
        return LLVMInitializePowerPCTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTarget()
     * }
     */
    public static MethodHandle LLVMInitializePowerPCTarget$handle() {
        return LLVMInitializePowerPCTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTarget()
     * }
     */
    public static MemorySegment LLVMInitializePowerPCTarget$address() {
        return LLVMInitializePowerPCTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTarget()
     * }
     */
    public static void LLVMInitializePowerPCTarget() {
        var mh$ = LLVMInitializePowerPCTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializePowerPCTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeRISCVTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeRISCVTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeRISCVTarget$descriptor() {
        return LLVMInitializeRISCVTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTarget()
     * }
     */
    public static MethodHandle LLVMInitializeRISCVTarget$handle() {
        return LLVMInitializeRISCVTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTarget()
     * }
     */
    public static MemorySegment LLVMInitializeRISCVTarget$address() {
        return LLVMInitializeRISCVTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTarget()
     * }
     */
    public static void LLVMInitializeRISCVTarget() {
        var mh$ = LLVMInitializeRISCVTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeRISCVTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSparcTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSparcTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSparcTarget$descriptor() {
        return LLVMInitializeSparcTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTarget()
     * }
     */
    public static MethodHandle LLVMInitializeSparcTarget$handle() {
        return LLVMInitializeSparcTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTarget()
     * }
     */
    public static MemorySegment LLVMInitializeSparcTarget$address() {
        return LLVMInitializeSparcTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSparcTarget()
     * }
     */
    public static void LLVMInitializeSparcTarget() {
        var mh$ = LLVMInitializeSparcTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSparcTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSystemZTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSystemZTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSystemZTarget$descriptor() {
        return LLVMInitializeSystemZTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTarget()
     * }
     */
    public static MethodHandle LLVMInitializeSystemZTarget$handle() {
        return LLVMInitializeSystemZTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTarget()
     * }
     */
    public static MemorySegment LLVMInitializeSystemZTarget$address() {
        return LLVMInitializeSystemZTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTarget()
     * }
     */
    public static void LLVMInitializeSystemZTarget() {
        var mh$ = LLVMInitializeSystemZTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSystemZTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeVETarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeVETarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeVETarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeVETarget$descriptor() {
        return LLVMInitializeVETarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeVETarget()
     * }
     */
    public static MethodHandle LLVMInitializeVETarget$handle() {
        return LLVMInitializeVETarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeVETarget()
     * }
     */
    public static MemorySegment LLVMInitializeVETarget$address() {
        return LLVMInitializeVETarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeVETarget()
     * }
     */
    public static void LLVMInitializeVETarget() {
        var mh$ = LLVMInitializeVETarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeVETarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeWebAssemblyTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeWebAssemblyTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeWebAssemblyTarget$descriptor() {
        return LLVMInitializeWebAssemblyTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTarget()
     * }
     */
    public static MethodHandle LLVMInitializeWebAssemblyTarget$handle() {
        return LLVMInitializeWebAssemblyTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTarget()
     * }
     */
    public static MemorySegment LLVMInitializeWebAssemblyTarget$address() {
        return LLVMInitializeWebAssemblyTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTarget()
     * }
     */
    public static void LLVMInitializeWebAssemblyTarget() {
        var mh$ = LLVMInitializeWebAssemblyTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeWebAssemblyTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeX86Target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeX86Target");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeX86Target()
     * }
     */
    public static FunctionDescriptor LLVMInitializeX86Target$descriptor() {
        return LLVMInitializeX86Target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeX86Target()
     * }
     */
    public static MethodHandle LLVMInitializeX86Target$handle() {
        return LLVMInitializeX86Target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeX86Target()
     * }
     */
    public static MemorySegment LLVMInitializeX86Target$address() {
        return LLVMInitializeX86Target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeX86Target()
     * }
     */
    public static void LLVMInitializeX86Target() {
        var mh$ = LLVMInitializeX86Target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeX86Target");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXCoreTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXCoreTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXCoreTarget$descriptor() {
        return LLVMInitializeXCoreTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTarget()
     * }
     */
    public static MethodHandle LLVMInitializeXCoreTarget$handle() {
        return LLVMInitializeXCoreTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTarget()
     * }
     */
    public static MemorySegment LLVMInitializeXCoreTarget$address() {
        return LLVMInitializeXCoreTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTarget()
     * }
     */
    public static void LLVMInitializeXCoreTarget() {
        var mh$ = LLVMInitializeXCoreTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXCoreTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeM68kTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeM68kTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeM68kTarget$descriptor() {
        return LLVMInitializeM68kTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTarget()
     * }
     */
    public static MethodHandle LLVMInitializeM68kTarget$handle() {
        return LLVMInitializeM68kTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTarget()
     * }
     */
    public static MemorySegment LLVMInitializeM68kTarget$address() {
        return LLVMInitializeM68kTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeM68kTarget()
     * }
     */
    public static void LLVMInitializeM68kTarget() {
        var mh$ = LLVMInitializeM68kTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeM68kTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXtensaTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXtensaTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTarget()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXtensaTarget$descriptor() {
        return LLVMInitializeXtensaTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTarget()
     * }
     */
    public static MethodHandle LLVMInitializeXtensaTarget$handle() {
        return LLVMInitializeXtensaTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTarget()
     * }
     */
    public static MemorySegment LLVMInitializeXtensaTarget$address() {
        return LLVMInitializeXtensaTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTarget()
     * }
     */
    public static void LLVMInitializeXtensaTarget() {
        var mh$ = LLVMInitializeXtensaTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXtensaTarget");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAArch64TargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAArch64TargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64TargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAArch64TargetMC$descriptor() {
        return LLVMInitializeAArch64TargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64TargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeAArch64TargetMC$handle() {
        return LLVMInitializeAArch64TargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64TargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeAArch64TargetMC$address() {
        return LLVMInitializeAArch64TargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAArch64TargetMC()
     * }
     */
    public static void LLVMInitializeAArch64TargetMC() {
        var mh$ = LLVMInitializeAArch64TargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAArch64TargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAMDGPUTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAMDGPUTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAMDGPUTargetMC$descriptor() {
        return LLVMInitializeAMDGPUTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeAMDGPUTargetMC$handle() {
        return LLVMInitializeAMDGPUTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeAMDGPUTargetMC$address() {
        return LLVMInitializeAMDGPUTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUTargetMC()
     * }
     */
    public static void LLVMInitializeAMDGPUTargetMC() {
        var mh$ = LLVMInitializeAMDGPUTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAMDGPUTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeARMTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeARMTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeARMTargetMC$descriptor() {
        return LLVMInitializeARMTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeARMTargetMC$handle() {
        return LLVMInitializeARMTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeARMTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeARMTargetMC$address() {
        return LLVMInitializeARMTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeARMTargetMC()
     * }
     */
    public static void LLVMInitializeARMTargetMC() {
        var mh$ = LLVMInitializeARMTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeARMTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAVRTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAVRTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAVRTargetMC$descriptor() {
        return LLVMInitializeAVRTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeAVRTargetMC$handle() {
        return LLVMInitializeAVRTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeAVRTargetMC$address() {
        return LLVMInitializeAVRTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAVRTargetMC()
     * }
     */
    public static void LLVMInitializeAVRTargetMC() {
        var mh$ = LLVMInitializeAVRTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAVRTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeBPFTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeBPFTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeBPFTargetMC$descriptor() {
        return LLVMInitializeBPFTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeBPFTargetMC$handle() {
        return LLVMInitializeBPFTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeBPFTargetMC$address() {
        return LLVMInitializeBPFTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeBPFTargetMC()
     * }
     */
    public static void LLVMInitializeBPFTargetMC() {
        var mh$ = LLVMInitializeBPFTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeBPFTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeHexagonTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeHexagonTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeHexagonTargetMC$descriptor() {
        return LLVMInitializeHexagonTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeHexagonTargetMC$handle() {
        return LLVMInitializeHexagonTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeHexagonTargetMC$address() {
        return LLVMInitializeHexagonTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeHexagonTargetMC()
     * }
     */
    public static void LLVMInitializeHexagonTargetMC() {
        var mh$ = LLVMInitializeHexagonTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeHexagonTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLanaiTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLanaiTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLanaiTargetMC$descriptor() {
        return LLVMInitializeLanaiTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeLanaiTargetMC$handle() {
        return LLVMInitializeLanaiTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeLanaiTargetMC$address() {
        return LLVMInitializeLanaiTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLanaiTargetMC()
     * }
     */
    public static void LLVMInitializeLanaiTargetMC() {
        var mh$ = LLVMInitializeLanaiTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLanaiTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLoongArchTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLoongArchTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLoongArchTargetMC$descriptor() {
        return LLVMInitializeLoongArchTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeLoongArchTargetMC$handle() {
        return LLVMInitializeLoongArchTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeLoongArchTargetMC$address() {
        return LLVMInitializeLoongArchTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchTargetMC()
     * }
     */
    public static void LLVMInitializeLoongArchTargetMC() {
        var mh$ = LLVMInitializeLoongArchTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLoongArchTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMipsTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMipsTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMipsTargetMC$descriptor() {
        return LLVMInitializeMipsTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeMipsTargetMC$handle() {
        return LLVMInitializeMipsTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeMipsTargetMC$address() {
        return LLVMInitializeMipsTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMipsTargetMC()
     * }
     */
    public static void LLVMInitializeMipsTargetMC() {
        var mh$ = LLVMInitializeMipsTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMipsTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMSP430TargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMSP430TargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430TargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMSP430TargetMC$descriptor() {
        return LLVMInitializeMSP430TargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430TargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeMSP430TargetMC$handle() {
        return LLVMInitializeMSP430TargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430TargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeMSP430TargetMC$address() {
        return LLVMInitializeMSP430TargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMSP430TargetMC()
     * }
     */
    public static void LLVMInitializeMSP430TargetMC() {
        var mh$ = LLVMInitializeMSP430TargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMSP430TargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeNVPTXTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeNVPTXTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeNVPTXTargetMC$descriptor() {
        return LLVMInitializeNVPTXTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeNVPTXTargetMC$handle() {
        return LLVMInitializeNVPTXTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeNVPTXTargetMC$address() {
        return LLVMInitializeNVPTXTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXTargetMC()
     * }
     */
    public static void LLVMInitializeNVPTXTargetMC() {
        var mh$ = LLVMInitializeNVPTXTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeNVPTXTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializePowerPCTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializePowerPCTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializePowerPCTargetMC$descriptor() {
        return LLVMInitializePowerPCTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializePowerPCTargetMC$handle() {
        return LLVMInitializePowerPCTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializePowerPCTargetMC$address() {
        return LLVMInitializePowerPCTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializePowerPCTargetMC()
     * }
     */
    public static void LLVMInitializePowerPCTargetMC() {
        var mh$ = LLVMInitializePowerPCTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializePowerPCTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeRISCVTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeRISCVTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeRISCVTargetMC$descriptor() {
        return LLVMInitializeRISCVTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeRISCVTargetMC$handle() {
        return LLVMInitializeRISCVTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeRISCVTargetMC$address() {
        return LLVMInitializeRISCVTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeRISCVTargetMC()
     * }
     */
    public static void LLVMInitializeRISCVTargetMC() {
        var mh$ = LLVMInitializeRISCVTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeRISCVTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSparcTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSparcTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSparcTargetMC$descriptor() {
        return LLVMInitializeSparcTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeSparcTargetMC$handle() {
        return LLVMInitializeSparcTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeSparcTargetMC$address() {
        return LLVMInitializeSparcTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSparcTargetMC()
     * }
     */
    public static void LLVMInitializeSparcTargetMC() {
        var mh$ = LLVMInitializeSparcTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSparcTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSystemZTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSystemZTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSystemZTargetMC$descriptor() {
        return LLVMInitializeSystemZTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeSystemZTargetMC$handle() {
        return LLVMInitializeSystemZTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeSystemZTargetMC$address() {
        return LLVMInitializeSystemZTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSystemZTargetMC()
     * }
     */
    public static void LLVMInitializeSystemZTargetMC() {
        var mh$ = LLVMInitializeSystemZTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSystemZTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeVETargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeVETargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeVETargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeVETargetMC$descriptor() {
        return LLVMInitializeVETargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeVETargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeVETargetMC$handle() {
        return LLVMInitializeVETargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeVETargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeVETargetMC$address() {
        return LLVMInitializeVETargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeVETargetMC()
     * }
     */
    public static void LLVMInitializeVETargetMC() {
        var mh$ = LLVMInitializeVETargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeVETargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeWebAssemblyTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeWebAssemblyTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeWebAssemblyTargetMC$descriptor() {
        return LLVMInitializeWebAssemblyTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeWebAssemblyTargetMC$handle() {
        return LLVMInitializeWebAssemblyTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeWebAssemblyTargetMC$address() {
        return LLVMInitializeWebAssemblyTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyTargetMC()
     * }
     */
    public static void LLVMInitializeWebAssemblyTargetMC() {
        var mh$ = LLVMInitializeWebAssemblyTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeWebAssemblyTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeX86TargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeX86TargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeX86TargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeX86TargetMC$descriptor() {
        return LLVMInitializeX86TargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeX86TargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeX86TargetMC$handle() {
        return LLVMInitializeX86TargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeX86TargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeX86TargetMC$address() {
        return LLVMInitializeX86TargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeX86TargetMC()
     * }
     */
    public static void LLVMInitializeX86TargetMC() {
        var mh$ = LLVMInitializeX86TargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeX86TargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXCoreTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXCoreTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXCoreTargetMC$descriptor() {
        return LLVMInitializeXCoreTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeXCoreTargetMC$handle() {
        return LLVMInitializeXCoreTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeXCoreTargetMC$address() {
        return LLVMInitializeXCoreTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXCoreTargetMC()
     * }
     */
    public static void LLVMInitializeXCoreTargetMC() {
        var mh$ = LLVMInitializeXCoreTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXCoreTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeM68kTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeM68kTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeM68kTargetMC$descriptor() {
        return LLVMInitializeM68kTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeM68kTargetMC$handle() {
        return LLVMInitializeM68kTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeM68kTargetMC$address() {
        return LLVMInitializeM68kTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeM68kTargetMC()
     * }
     */
    public static void LLVMInitializeM68kTargetMC() {
        var mh$ = LLVMInitializeM68kTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeM68kTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXtensaTargetMC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXtensaTargetMC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTargetMC()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXtensaTargetMC$descriptor() {
        return LLVMInitializeXtensaTargetMC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTargetMC()
     * }
     */
    public static MethodHandle LLVMInitializeXtensaTargetMC$handle() {
        return LLVMInitializeXtensaTargetMC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTargetMC()
     * }
     */
    public static MemorySegment LLVMInitializeXtensaTargetMC$address() {
        return LLVMInitializeXtensaTargetMC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXtensaTargetMC()
     * }
     */
    public static void LLVMInitializeXtensaTargetMC() {
        var mh$ = LLVMInitializeXtensaTargetMC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXtensaTargetMC");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAArch64AsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAArch64AsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64AsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAArch64AsmPrinter$descriptor() {
        return LLVMInitializeAArch64AsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64AsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeAArch64AsmPrinter$handle() {
        return LLVMInitializeAArch64AsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64AsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeAArch64AsmPrinter$address() {
        return LLVMInitializeAArch64AsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAArch64AsmPrinter()
     * }
     */
    public static void LLVMInitializeAArch64AsmPrinter() {
        var mh$ = LLVMInitializeAArch64AsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAArch64AsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAMDGPUAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAMDGPUAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAMDGPUAsmPrinter$descriptor() {
        return LLVMInitializeAMDGPUAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeAMDGPUAsmPrinter$handle() {
        return LLVMInitializeAMDGPUAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeAMDGPUAsmPrinter$address() {
        return LLVMInitializeAMDGPUAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUAsmPrinter()
     * }
     */
    public static void LLVMInitializeAMDGPUAsmPrinter() {
        var mh$ = LLVMInitializeAMDGPUAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAMDGPUAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeARMAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeARMAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeARMAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeARMAsmPrinter$descriptor() {
        return LLVMInitializeARMAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeARMAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeARMAsmPrinter$handle() {
        return LLVMInitializeARMAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeARMAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeARMAsmPrinter$address() {
        return LLVMInitializeARMAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeARMAsmPrinter()
     * }
     */
    public static void LLVMInitializeARMAsmPrinter() {
        var mh$ = LLVMInitializeARMAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeARMAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAVRAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAVRAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAVRAsmPrinter$descriptor() {
        return LLVMInitializeAVRAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeAVRAsmPrinter$handle() {
        return LLVMInitializeAVRAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeAVRAsmPrinter$address() {
        return LLVMInitializeAVRAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAVRAsmPrinter()
     * }
     */
    public static void LLVMInitializeAVRAsmPrinter() {
        var mh$ = LLVMInitializeAVRAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAVRAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeBPFAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeBPFAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeBPFAsmPrinter$descriptor() {
        return LLVMInitializeBPFAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeBPFAsmPrinter$handle() {
        return LLVMInitializeBPFAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeBPFAsmPrinter$address() {
        return LLVMInitializeBPFAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeBPFAsmPrinter()
     * }
     */
    public static void LLVMInitializeBPFAsmPrinter() {
        var mh$ = LLVMInitializeBPFAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeBPFAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeHexagonAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeHexagonAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeHexagonAsmPrinter$descriptor() {
        return LLVMInitializeHexagonAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeHexagonAsmPrinter$handle() {
        return LLVMInitializeHexagonAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeHexagonAsmPrinter$address() {
        return LLVMInitializeHexagonAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeHexagonAsmPrinter()
     * }
     */
    public static void LLVMInitializeHexagonAsmPrinter() {
        var mh$ = LLVMInitializeHexagonAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeHexagonAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLanaiAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLanaiAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLanaiAsmPrinter$descriptor() {
        return LLVMInitializeLanaiAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeLanaiAsmPrinter$handle() {
        return LLVMInitializeLanaiAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeLanaiAsmPrinter$address() {
        return LLVMInitializeLanaiAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLanaiAsmPrinter()
     * }
     */
    public static void LLVMInitializeLanaiAsmPrinter() {
        var mh$ = LLVMInitializeLanaiAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLanaiAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLoongArchAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLoongArchAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLoongArchAsmPrinter$descriptor() {
        return LLVMInitializeLoongArchAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeLoongArchAsmPrinter$handle() {
        return LLVMInitializeLoongArchAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeLoongArchAsmPrinter$address() {
        return LLVMInitializeLoongArchAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchAsmPrinter()
     * }
     */
    public static void LLVMInitializeLoongArchAsmPrinter() {
        var mh$ = LLVMInitializeLoongArchAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLoongArchAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMipsAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMipsAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMipsAsmPrinter$descriptor() {
        return LLVMInitializeMipsAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeMipsAsmPrinter$handle() {
        return LLVMInitializeMipsAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeMipsAsmPrinter$address() {
        return LLVMInitializeMipsAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMipsAsmPrinter()
     * }
     */
    public static void LLVMInitializeMipsAsmPrinter() {
        var mh$ = LLVMInitializeMipsAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMipsAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMSP430AsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMSP430AsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430AsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMSP430AsmPrinter$descriptor() {
        return LLVMInitializeMSP430AsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430AsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeMSP430AsmPrinter$handle() {
        return LLVMInitializeMSP430AsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430AsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeMSP430AsmPrinter$address() {
        return LLVMInitializeMSP430AsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMSP430AsmPrinter()
     * }
     */
    public static void LLVMInitializeMSP430AsmPrinter() {
        var mh$ = LLVMInitializeMSP430AsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMSP430AsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeNVPTXAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeNVPTXAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeNVPTXAsmPrinter$descriptor() {
        return LLVMInitializeNVPTXAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeNVPTXAsmPrinter$handle() {
        return LLVMInitializeNVPTXAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeNVPTXAsmPrinter$address() {
        return LLVMInitializeNVPTXAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeNVPTXAsmPrinter()
     * }
     */
    public static void LLVMInitializeNVPTXAsmPrinter() {
        var mh$ = LLVMInitializeNVPTXAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeNVPTXAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializePowerPCAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializePowerPCAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializePowerPCAsmPrinter$descriptor() {
        return LLVMInitializePowerPCAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializePowerPCAsmPrinter$handle() {
        return LLVMInitializePowerPCAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializePowerPCAsmPrinter$address() {
        return LLVMInitializePowerPCAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializePowerPCAsmPrinter()
     * }
     */
    public static void LLVMInitializePowerPCAsmPrinter() {
        var mh$ = LLVMInitializePowerPCAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializePowerPCAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeRISCVAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeRISCVAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeRISCVAsmPrinter$descriptor() {
        return LLVMInitializeRISCVAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeRISCVAsmPrinter$handle() {
        return LLVMInitializeRISCVAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeRISCVAsmPrinter$address() {
        return LLVMInitializeRISCVAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeRISCVAsmPrinter()
     * }
     */
    public static void LLVMInitializeRISCVAsmPrinter() {
        var mh$ = LLVMInitializeRISCVAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeRISCVAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSparcAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSparcAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSparcAsmPrinter$descriptor() {
        return LLVMInitializeSparcAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeSparcAsmPrinter$handle() {
        return LLVMInitializeSparcAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeSparcAsmPrinter$address() {
        return LLVMInitializeSparcAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSparcAsmPrinter()
     * }
     */
    public static void LLVMInitializeSparcAsmPrinter() {
        var mh$ = LLVMInitializeSparcAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSparcAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSystemZAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSystemZAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSystemZAsmPrinter$descriptor() {
        return LLVMInitializeSystemZAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeSystemZAsmPrinter$handle() {
        return LLVMInitializeSystemZAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeSystemZAsmPrinter$address() {
        return LLVMInitializeSystemZAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSystemZAsmPrinter()
     * }
     */
    public static void LLVMInitializeSystemZAsmPrinter() {
        var mh$ = LLVMInitializeSystemZAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSystemZAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeVEAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeVEAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeVEAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeVEAsmPrinter$descriptor() {
        return LLVMInitializeVEAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeVEAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeVEAsmPrinter$handle() {
        return LLVMInitializeVEAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeVEAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeVEAsmPrinter$address() {
        return LLVMInitializeVEAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeVEAsmPrinter()
     * }
     */
    public static void LLVMInitializeVEAsmPrinter() {
        var mh$ = LLVMInitializeVEAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeVEAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeWebAssemblyAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeWebAssemblyAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeWebAssemblyAsmPrinter$descriptor() {
        return LLVMInitializeWebAssemblyAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeWebAssemblyAsmPrinter$handle() {
        return LLVMInitializeWebAssemblyAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeWebAssemblyAsmPrinter$address() {
        return LLVMInitializeWebAssemblyAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyAsmPrinter()
     * }
     */
    public static void LLVMInitializeWebAssemblyAsmPrinter() {
        var mh$ = LLVMInitializeWebAssemblyAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeWebAssemblyAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeX86AsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeX86AsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeX86AsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeX86AsmPrinter$descriptor() {
        return LLVMInitializeX86AsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeX86AsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeX86AsmPrinter$handle() {
        return LLVMInitializeX86AsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeX86AsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeX86AsmPrinter$address() {
        return LLVMInitializeX86AsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeX86AsmPrinter()
     * }
     */
    public static void LLVMInitializeX86AsmPrinter() {
        var mh$ = LLVMInitializeX86AsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeX86AsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXCoreAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXCoreAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXCoreAsmPrinter$descriptor() {
        return LLVMInitializeXCoreAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeXCoreAsmPrinter$handle() {
        return LLVMInitializeXCoreAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeXCoreAsmPrinter$address() {
        return LLVMInitializeXCoreAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXCoreAsmPrinter()
     * }
     */
    public static void LLVMInitializeXCoreAsmPrinter() {
        var mh$ = LLVMInitializeXCoreAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXCoreAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeM68kAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeM68kAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeM68kAsmPrinter$descriptor() {
        return LLVMInitializeM68kAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeM68kAsmPrinter$handle() {
        return LLVMInitializeM68kAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeM68kAsmPrinter$address() {
        return LLVMInitializeM68kAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeM68kAsmPrinter()
     * }
     */
    public static void LLVMInitializeM68kAsmPrinter() {
        var mh$ = LLVMInitializeM68kAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeM68kAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXtensaAsmPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXtensaAsmPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaAsmPrinter()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXtensaAsmPrinter$descriptor() {
        return LLVMInitializeXtensaAsmPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaAsmPrinter()
     * }
     */
    public static MethodHandle LLVMInitializeXtensaAsmPrinter$handle() {
        return LLVMInitializeXtensaAsmPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaAsmPrinter()
     * }
     */
    public static MemorySegment LLVMInitializeXtensaAsmPrinter$address() {
        return LLVMInitializeXtensaAsmPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXtensaAsmPrinter()
     * }
     */
    public static void LLVMInitializeXtensaAsmPrinter() {
        var mh$ = LLVMInitializeXtensaAsmPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXtensaAsmPrinter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAArch64AsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAArch64AsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64AsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAArch64AsmParser$descriptor() {
        return LLVMInitializeAArch64AsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64AsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeAArch64AsmParser$handle() {
        return LLVMInitializeAArch64AsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64AsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeAArch64AsmParser$address() {
        return LLVMInitializeAArch64AsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAArch64AsmParser()
     * }
     */
    public static void LLVMInitializeAArch64AsmParser() {
        var mh$ = LLVMInitializeAArch64AsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAArch64AsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAMDGPUAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAMDGPUAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAMDGPUAsmParser$descriptor() {
        return LLVMInitializeAMDGPUAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeAMDGPUAsmParser$handle() {
        return LLVMInitializeAMDGPUAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeAMDGPUAsmParser$address() {
        return LLVMInitializeAMDGPUAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUAsmParser()
     * }
     */
    public static void LLVMInitializeAMDGPUAsmParser() {
        var mh$ = LLVMInitializeAMDGPUAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAMDGPUAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeARMAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeARMAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeARMAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeARMAsmParser$descriptor() {
        return LLVMInitializeARMAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeARMAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeARMAsmParser$handle() {
        return LLVMInitializeARMAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeARMAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeARMAsmParser$address() {
        return LLVMInitializeARMAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeARMAsmParser()
     * }
     */
    public static void LLVMInitializeARMAsmParser() {
        var mh$ = LLVMInitializeARMAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeARMAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAVRAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAVRAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAVRAsmParser$descriptor() {
        return LLVMInitializeAVRAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeAVRAsmParser$handle() {
        return LLVMInitializeAVRAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeAVRAsmParser$address() {
        return LLVMInitializeAVRAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAVRAsmParser()
     * }
     */
    public static void LLVMInitializeAVRAsmParser() {
        var mh$ = LLVMInitializeAVRAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAVRAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeBPFAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeBPFAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeBPFAsmParser$descriptor() {
        return LLVMInitializeBPFAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeBPFAsmParser$handle() {
        return LLVMInitializeBPFAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeBPFAsmParser$address() {
        return LLVMInitializeBPFAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeBPFAsmParser()
     * }
     */
    public static void LLVMInitializeBPFAsmParser() {
        var mh$ = LLVMInitializeBPFAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeBPFAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeHexagonAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeHexagonAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeHexagonAsmParser$descriptor() {
        return LLVMInitializeHexagonAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeHexagonAsmParser$handle() {
        return LLVMInitializeHexagonAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeHexagonAsmParser$address() {
        return LLVMInitializeHexagonAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeHexagonAsmParser()
     * }
     */
    public static void LLVMInitializeHexagonAsmParser() {
        var mh$ = LLVMInitializeHexagonAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeHexagonAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLanaiAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLanaiAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLanaiAsmParser$descriptor() {
        return LLVMInitializeLanaiAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeLanaiAsmParser$handle() {
        return LLVMInitializeLanaiAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeLanaiAsmParser$address() {
        return LLVMInitializeLanaiAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLanaiAsmParser()
     * }
     */
    public static void LLVMInitializeLanaiAsmParser() {
        var mh$ = LLVMInitializeLanaiAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLanaiAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLoongArchAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLoongArchAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLoongArchAsmParser$descriptor() {
        return LLVMInitializeLoongArchAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeLoongArchAsmParser$handle() {
        return LLVMInitializeLoongArchAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeLoongArchAsmParser$address() {
        return LLVMInitializeLoongArchAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchAsmParser()
     * }
     */
    public static void LLVMInitializeLoongArchAsmParser() {
        var mh$ = LLVMInitializeLoongArchAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLoongArchAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMipsAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMipsAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMipsAsmParser$descriptor() {
        return LLVMInitializeMipsAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeMipsAsmParser$handle() {
        return LLVMInitializeMipsAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeMipsAsmParser$address() {
        return LLVMInitializeMipsAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMipsAsmParser()
     * }
     */
    public static void LLVMInitializeMipsAsmParser() {
        var mh$ = LLVMInitializeMipsAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMipsAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMSP430AsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMSP430AsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430AsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMSP430AsmParser$descriptor() {
        return LLVMInitializeMSP430AsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430AsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeMSP430AsmParser$handle() {
        return LLVMInitializeMSP430AsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430AsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeMSP430AsmParser$address() {
        return LLVMInitializeMSP430AsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMSP430AsmParser()
     * }
     */
    public static void LLVMInitializeMSP430AsmParser() {
        var mh$ = LLVMInitializeMSP430AsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMSP430AsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializePowerPCAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializePowerPCAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializePowerPCAsmParser$descriptor() {
        return LLVMInitializePowerPCAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializePowerPCAsmParser$handle() {
        return LLVMInitializePowerPCAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializePowerPCAsmParser$address() {
        return LLVMInitializePowerPCAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializePowerPCAsmParser()
     * }
     */
    public static void LLVMInitializePowerPCAsmParser() {
        var mh$ = LLVMInitializePowerPCAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializePowerPCAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeRISCVAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeRISCVAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeRISCVAsmParser$descriptor() {
        return LLVMInitializeRISCVAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeRISCVAsmParser$handle() {
        return LLVMInitializeRISCVAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeRISCVAsmParser$address() {
        return LLVMInitializeRISCVAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeRISCVAsmParser()
     * }
     */
    public static void LLVMInitializeRISCVAsmParser() {
        var mh$ = LLVMInitializeRISCVAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeRISCVAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSparcAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSparcAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSparcAsmParser$descriptor() {
        return LLVMInitializeSparcAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeSparcAsmParser$handle() {
        return LLVMInitializeSparcAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeSparcAsmParser$address() {
        return LLVMInitializeSparcAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSparcAsmParser()
     * }
     */
    public static void LLVMInitializeSparcAsmParser() {
        var mh$ = LLVMInitializeSparcAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSparcAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSystemZAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSystemZAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSystemZAsmParser$descriptor() {
        return LLVMInitializeSystemZAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeSystemZAsmParser$handle() {
        return LLVMInitializeSystemZAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeSystemZAsmParser$address() {
        return LLVMInitializeSystemZAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSystemZAsmParser()
     * }
     */
    public static void LLVMInitializeSystemZAsmParser() {
        var mh$ = LLVMInitializeSystemZAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSystemZAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeVEAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeVEAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeVEAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeVEAsmParser$descriptor() {
        return LLVMInitializeVEAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeVEAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeVEAsmParser$handle() {
        return LLVMInitializeVEAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeVEAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeVEAsmParser$address() {
        return LLVMInitializeVEAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeVEAsmParser()
     * }
     */
    public static void LLVMInitializeVEAsmParser() {
        var mh$ = LLVMInitializeVEAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeVEAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeWebAssemblyAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeWebAssemblyAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeWebAssemblyAsmParser$descriptor() {
        return LLVMInitializeWebAssemblyAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeWebAssemblyAsmParser$handle() {
        return LLVMInitializeWebAssemblyAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeWebAssemblyAsmParser$address() {
        return LLVMInitializeWebAssemblyAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyAsmParser()
     * }
     */
    public static void LLVMInitializeWebAssemblyAsmParser() {
        var mh$ = LLVMInitializeWebAssemblyAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeWebAssemblyAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeX86AsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeX86AsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeX86AsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeX86AsmParser$descriptor() {
        return LLVMInitializeX86AsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeX86AsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeX86AsmParser$handle() {
        return LLVMInitializeX86AsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeX86AsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeX86AsmParser$address() {
        return LLVMInitializeX86AsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeX86AsmParser()
     * }
     */
    public static void LLVMInitializeX86AsmParser() {
        var mh$ = LLVMInitializeX86AsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeX86AsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeM68kAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeM68kAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeM68kAsmParser$descriptor() {
        return LLVMInitializeM68kAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeM68kAsmParser$handle() {
        return LLVMInitializeM68kAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeM68kAsmParser$address() {
        return LLVMInitializeM68kAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeM68kAsmParser()
     * }
     */
    public static void LLVMInitializeM68kAsmParser() {
        var mh$ = LLVMInitializeM68kAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeM68kAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXtensaAsmParser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXtensaAsmParser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaAsmParser()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXtensaAsmParser$descriptor() {
        return LLVMInitializeXtensaAsmParser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaAsmParser()
     * }
     */
    public static MethodHandle LLVMInitializeXtensaAsmParser$handle() {
        return LLVMInitializeXtensaAsmParser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaAsmParser()
     * }
     */
    public static MemorySegment LLVMInitializeXtensaAsmParser$address() {
        return LLVMInitializeXtensaAsmParser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXtensaAsmParser()
     * }
     */
    public static void LLVMInitializeXtensaAsmParser() {
        var mh$ = LLVMInitializeXtensaAsmParser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXtensaAsmParser");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAArch64Disassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAArch64Disassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64Disassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAArch64Disassembler$descriptor() {
        return LLVMInitializeAArch64Disassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64Disassembler()
     * }
     */
    public static MethodHandle LLVMInitializeAArch64Disassembler$handle() {
        return LLVMInitializeAArch64Disassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAArch64Disassembler()
     * }
     */
    public static MemorySegment LLVMInitializeAArch64Disassembler$address() {
        return LLVMInitializeAArch64Disassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAArch64Disassembler()
     * }
     */
    public static void LLVMInitializeAArch64Disassembler() {
        var mh$ = LLVMInitializeAArch64Disassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAArch64Disassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAMDGPUDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAMDGPUDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAMDGPUDisassembler$descriptor() {
        return LLVMInitializeAMDGPUDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeAMDGPUDisassembler$handle() {
        return LLVMInitializeAMDGPUDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeAMDGPUDisassembler$address() {
        return LLVMInitializeAMDGPUDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAMDGPUDisassembler()
     * }
     */
    public static void LLVMInitializeAMDGPUDisassembler() {
        var mh$ = LLVMInitializeAMDGPUDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAMDGPUDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeARMDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeARMDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeARMDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeARMDisassembler$descriptor() {
        return LLVMInitializeARMDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeARMDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeARMDisassembler$handle() {
        return LLVMInitializeARMDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeARMDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeARMDisassembler$address() {
        return LLVMInitializeARMDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeARMDisassembler()
     * }
     */
    public static void LLVMInitializeARMDisassembler() {
        var mh$ = LLVMInitializeARMDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeARMDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeAVRDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeAVRDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeAVRDisassembler$descriptor() {
        return LLVMInitializeAVRDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeAVRDisassembler$handle() {
        return LLVMInitializeAVRDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeAVRDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeAVRDisassembler$address() {
        return LLVMInitializeAVRDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeAVRDisassembler()
     * }
     */
    public static void LLVMInitializeAVRDisassembler() {
        var mh$ = LLVMInitializeAVRDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeAVRDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeBPFDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeBPFDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeBPFDisassembler$descriptor() {
        return LLVMInitializeBPFDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeBPFDisassembler$handle() {
        return LLVMInitializeBPFDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeBPFDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeBPFDisassembler$address() {
        return LLVMInitializeBPFDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeBPFDisassembler()
     * }
     */
    public static void LLVMInitializeBPFDisassembler() {
        var mh$ = LLVMInitializeBPFDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeBPFDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeHexagonDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeHexagonDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeHexagonDisassembler$descriptor() {
        return LLVMInitializeHexagonDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeHexagonDisassembler$handle() {
        return LLVMInitializeHexagonDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeHexagonDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeHexagonDisassembler$address() {
        return LLVMInitializeHexagonDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeHexagonDisassembler()
     * }
     */
    public static void LLVMInitializeHexagonDisassembler() {
        var mh$ = LLVMInitializeHexagonDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeHexagonDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLanaiDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLanaiDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLanaiDisassembler$descriptor() {
        return LLVMInitializeLanaiDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeLanaiDisassembler$handle() {
        return LLVMInitializeLanaiDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLanaiDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeLanaiDisassembler$address() {
        return LLVMInitializeLanaiDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLanaiDisassembler()
     * }
     */
    public static void LLVMInitializeLanaiDisassembler() {
        var mh$ = LLVMInitializeLanaiDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLanaiDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeLoongArchDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeLoongArchDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeLoongArchDisassembler$descriptor() {
        return LLVMInitializeLoongArchDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeLoongArchDisassembler$handle() {
        return LLVMInitializeLoongArchDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeLoongArchDisassembler$address() {
        return LLVMInitializeLoongArchDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeLoongArchDisassembler()
     * }
     */
    public static void LLVMInitializeLoongArchDisassembler() {
        var mh$ = LLVMInitializeLoongArchDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeLoongArchDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMipsDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMipsDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMipsDisassembler$descriptor() {
        return LLVMInitializeMipsDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeMipsDisassembler$handle() {
        return LLVMInitializeMipsDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMipsDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeMipsDisassembler$address() {
        return LLVMInitializeMipsDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMipsDisassembler()
     * }
     */
    public static void LLVMInitializeMipsDisassembler() {
        var mh$ = LLVMInitializeMipsDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMipsDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMSP430Disassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMSP430Disassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430Disassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeMSP430Disassembler$descriptor() {
        return LLVMInitializeMSP430Disassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430Disassembler()
     * }
     */
    public static MethodHandle LLVMInitializeMSP430Disassembler$handle() {
        return LLVMInitializeMSP430Disassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMSP430Disassembler()
     * }
     */
    public static MemorySegment LLVMInitializeMSP430Disassembler$address() {
        return LLVMInitializeMSP430Disassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMSP430Disassembler()
     * }
     */
    public static void LLVMInitializeMSP430Disassembler() {
        var mh$ = LLVMInitializeMSP430Disassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMSP430Disassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializePowerPCDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializePowerPCDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializePowerPCDisassembler$descriptor() {
        return LLVMInitializePowerPCDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializePowerPCDisassembler$handle() {
        return LLVMInitializePowerPCDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializePowerPCDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializePowerPCDisassembler$address() {
        return LLVMInitializePowerPCDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializePowerPCDisassembler()
     * }
     */
    public static void LLVMInitializePowerPCDisassembler() {
        var mh$ = LLVMInitializePowerPCDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializePowerPCDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeRISCVDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeRISCVDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeRISCVDisassembler$descriptor() {
        return LLVMInitializeRISCVDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeRISCVDisassembler$handle() {
        return LLVMInitializeRISCVDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeRISCVDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeRISCVDisassembler$address() {
        return LLVMInitializeRISCVDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeRISCVDisassembler()
     * }
     */
    public static void LLVMInitializeRISCVDisassembler() {
        var mh$ = LLVMInitializeRISCVDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeRISCVDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSparcDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSparcDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSparcDisassembler$descriptor() {
        return LLVMInitializeSparcDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeSparcDisassembler$handle() {
        return LLVMInitializeSparcDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSparcDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeSparcDisassembler$address() {
        return LLVMInitializeSparcDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSparcDisassembler()
     * }
     */
    public static void LLVMInitializeSparcDisassembler() {
        var mh$ = LLVMInitializeSparcDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSparcDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeSystemZDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeSystemZDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeSystemZDisassembler$descriptor() {
        return LLVMInitializeSystemZDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeSystemZDisassembler$handle() {
        return LLVMInitializeSystemZDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeSystemZDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeSystemZDisassembler$address() {
        return LLVMInitializeSystemZDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeSystemZDisassembler()
     * }
     */
    public static void LLVMInitializeSystemZDisassembler() {
        var mh$ = LLVMInitializeSystemZDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeSystemZDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeVEDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeVEDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeVEDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeVEDisassembler$descriptor() {
        return LLVMInitializeVEDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeVEDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeVEDisassembler$handle() {
        return LLVMInitializeVEDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeVEDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeVEDisassembler$address() {
        return LLVMInitializeVEDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeVEDisassembler()
     * }
     */
    public static void LLVMInitializeVEDisassembler() {
        var mh$ = LLVMInitializeVEDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeVEDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeWebAssemblyDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeWebAssemblyDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeWebAssemblyDisassembler$descriptor() {
        return LLVMInitializeWebAssemblyDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeWebAssemblyDisassembler$handle() {
        return LLVMInitializeWebAssemblyDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeWebAssemblyDisassembler$address() {
        return LLVMInitializeWebAssemblyDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeWebAssemblyDisassembler()
     * }
     */
    public static void LLVMInitializeWebAssemblyDisassembler() {
        var mh$ = LLVMInitializeWebAssemblyDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeWebAssemblyDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeX86Disassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeX86Disassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeX86Disassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeX86Disassembler$descriptor() {
        return LLVMInitializeX86Disassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeX86Disassembler()
     * }
     */
    public static MethodHandle LLVMInitializeX86Disassembler$handle() {
        return LLVMInitializeX86Disassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeX86Disassembler()
     * }
     */
    public static MemorySegment LLVMInitializeX86Disassembler$address() {
        return LLVMInitializeX86Disassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeX86Disassembler()
     * }
     */
    public static void LLVMInitializeX86Disassembler() {
        var mh$ = LLVMInitializeX86Disassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeX86Disassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXCoreDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXCoreDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXCoreDisassembler$descriptor() {
        return LLVMInitializeXCoreDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeXCoreDisassembler$handle() {
        return LLVMInitializeXCoreDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXCoreDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeXCoreDisassembler$address() {
        return LLVMInitializeXCoreDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXCoreDisassembler()
     * }
     */
    public static void LLVMInitializeXCoreDisassembler() {
        var mh$ = LLVMInitializeXCoreDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXCoreDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeM68kDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeM68kDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeM68kDisassembler$descriptor() {
        return LLVMInitializeM68kDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeM68kDisassembler$handle() {
        return LLVMInitializeM68kDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeM68kDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeM68kDisassembler$address() {
        return LLVMInitializeM68kDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeM68kDisassembler()
     * }
     */
    public static void LLVMInitializeM68kDisassembler() {
        var mh$ = LLVMInitializeM68kDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeM68kDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeXtensaDisassembler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeXtensaDisassembler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaDisassembler()
     * }
     */
    public static FunctionDescriptor LLVMInitializeXtensaDisassembler$descriptor() {
        return LLVMInitializeXtensaDisassembler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaDisassembler()
     * }
     */
    public static MethodHandle LLVMInitializeXtensaDisassembler$handle() {
        return LLVMInitializeXtensaDisassembler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeXtensaDisassembler()
     * }
     */
    public static MemorySegment LLVMInitializeXtensaDisassembler$address() {
        return LLVMInitializeXtensaDisassembler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeXtensaDisassembler()
     * }
     */
    public static void LLVMInitializeXtensaDisassembler() {
        var mh$ = LLVMInitializeXtensaDisassembler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeXtensaDisassembler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetModuleDataLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetModuleDataLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMGetModuleDataLayout(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetModuleDataLayout$descriptor() {
        return LLVMGetModuleDataLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMGetModuleDataLayout(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetModuleDataLayout$handle() {
        return LLVMGetModuleDataLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMGetModuleDataLayout(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetModuleDataLayout$address() {
        return LLVMGetModuleDataLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMGetModuleDataLayout(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetModuleDataLayout(MemorySegment M) {
        var mh$ = LLVMGetModuleDataLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetModuleDataLayout", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetModuleDataLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetModuleDataLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetModuleDataLayout(LLVMModuleRef M, LLVMTargetDataRef DL)
     * }
     */
    public static FunctionDescriptor LLVMSetModuleDataLayout$descriptor() {
        return LLVMSetModuleDataLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetModuleDataLayout(LLVMModuleRef M, LLVMTargetDataRef DL)
     * }
     */
    public static MethodHandle LLVMSetModuleDataLayout$handle() {
        return LLVMSetModuleDataLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetModuleDataLayout(LLVMModuleRef M, LLVMTargetDataRef DL)
     * }
     */
    public static MemorySegment LLVMSetModuleDataLayout$address() {
        return LLVMSetModuleDataLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetModuleDataLayout(LLVMModuleRef M, LLVMTargetDataRef DL)
     * }
     */
    public static void LLVMSetModuleDataLayout(MemorySegment M, MemorySegment DL) {
        var mh$ = LLVMSetModuleDataLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetModuleDataLayout", M, DL);
            }
            mh$.invokeExact(M, DL);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateTargetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateTargetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMCreateTargetData(const char *StringRep)
     * }
     */
    public static FunctionDescriptor LLVMCreateTargetData$descriptor() {
        return LLVMCreateTargetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMCreateTargetData(const char *StringRep)
     * }
     */
    public static MethodHandle LLVMCreateTargetData$handle() {
        return LLVMCreateTargetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMCreateTargetData(const char *StringRep)
     * }
     */
    public static MemorySegment LLVMCreateTargetData$address() {
        return LLVMCreateTargetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMCreateTargetData(const char *StringRep)
     * }
     */
    public static MemorySegment LLVMCreateTargetData(MemorySegment StringRep) {
        var mh$ = LLVMCreateTargetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateTargetData", StringRep);
            }
            return (MemorySegment)mh$.invokeExact(StringRep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeTargetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeTargetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetData(LLVMTargetDataRef TD)
     * }
     */
    public static FunctionDescriptor LLVMDisposeTargetData$descriptor() {
        return LLVMDisposeTargetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetData(LLVMTargetDataRef TD)
     * }
     */
    public static MethodHandle LLVMDisposeTargetData$handle() {
        return LLVMDisposeTargetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetData(LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMDisposeTargetData$address() {
        return LLVMDisposeTargetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeTargetData(LLVMTargetDataRef TD)
     * }
     */
    public static void LLVMDisposeTargetData(MemorySegment TD) {
        var mh$ = LLVMDisposeTargetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeTargetData", TD);
            }
            mh$.invokeExact(TD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddTargetLibraryInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddTargetLibraryInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddTargetLibraryInfo(LLVMTargetLibraryInfoRef TLI, LLVMPassManagerRef PM)
     * }
     */
    public static FunctionDescriptor LLVMAddTargetLibraryInfo$descriptor() {
        return LLVMAddTargetLibraryInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddTargetLibraryInfo(LLVMTargetLibraryInfoRef TLI, LLVMPassManagerRef PM)
     * }
     */
    public static MethodHandle LLVMAddTargetLibraryInfo$handle() {
        return LLVMAddTargetLibraryInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddTargetLibraryInfo(LLVMTargetLibraryInfoRef TLI, LLVMPassManagerRef PM)
     * }
     */
    public static MemorySegment LLVMAddTargetLibraryInfo$address() {
        return LLVMAddTargetLibraryInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddTargetLibraryInfo(LLVMTargetLibraryInfoRef TLI, LLVMPassManagerRef PM)
     * }
     */
    public static void LLVMAddTargetLibraryInfo(MemorySegment TLI, MemorySegment PM) {
        var mh$ = LLVMAddTargetLibraryInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddTargetLibraryInfo", TLI, PM);
            }
            mh$.invokeExact(TLI, PM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCopyStringRepOfTargetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCopyStringRepOfTargetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMCopyStringRepOfTargetData(LLVMTargetDataRef TD)
     * }
     */
    public static FunctionDescriptor LLVMCopyStringRepOfTargetData$descriptor() {
        return LLVMCopyStringRepOfTargetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMCopyStringRepOfTargetData(LLVMTargetDataRef TD)
     * }
     */
    public static MethodHandle LLVMCopyStringRepOfTargetData$handle() {
        return LLVMCopyStringRepOfTargetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMCopyStringRepOfTargetData(LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMCopyStringRepOfTargetData$address() {
        return LLVMCopyStringRepOfTargetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMCopyStringRepOfTargetData(LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMCopyStringRepOfTargetData(MemorySegment TD) {
        var mh$ = LLVMCopyStringRepOfTargetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCopyStringRepOfTargetData", TD);
            }
            return (MemorySegment)mh$.invokeExact(TD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMByteOrder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMByteOrder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum LLVMByteOrdering LLVMByteOrder(LLVMTargetDataRef TD)
     * }
     */
    public static FunctionDescriptor LLVMByteOrder$descriptor() {
        return LLVMByteOrder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum LLVMByteOrdering LLVMByteOrder(LLVMTargetDataRef TD)
     * }
     */
    public static MethodHandle LLVMByteOrder$handle() {
        return LLVMByteOrder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum LLVMByteOrdering LLVMByteOrder(LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMByteOrder$address() {
        return LLVMByteOrder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum LLVMByteOrdering LLVMByteOrder(LLVMTargetDataRef TD)
     * }
     */
    public static int LLVMByteOrder(MemorySegment TD) {
        var mh$ = LLVMByteOrder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMByteOrder", TD);
            }
            return (int)mh$.invokeExact(TD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPointerSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPointerSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMPointerSize(LLVMTargetDataRef TD)
     * }
     */
    public static FunctionDescriptor LLVMPointerSize$descriptor() {
        return LLVMPointerSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMPointerSize(LLVMTargetDataRef TD)
     * }
     */
    public static MethodHandle LLVMPointerSize$handle() {
        return LLVMPointerSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMPointerSize(LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMPointerSize$address() {
        return LLVMPointerSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMPointerSize(LLVMTargetDataRef TD)
     * }
     */
    public static int LLVMPointerSize(MemorySegment TD) {
        var mh$ = LLVMPointerSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPointerSize", TD);
            }
            return (int)mh$.invokeExact(TD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPointerSizeForAS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPointerSizeForAS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMPointerSizeForAS(LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static FunctionDescriptor LLVMPointerSizeForAS$descriptor() {
        return LLVMPointerSizeForAS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMPointerSizeForAS(LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static MethodHandle LLVMPointerSizeForAS$handle() {
        return LLVMPointerSizeForAS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMPointerSizeForAS(LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static MemorySegment LLVMPointerSizeForAS$address() {
        return LLVMPointerSizeForAS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMPointerSizeForAS(LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static int LLVMPointerSizeForAS(MemorySegment TD, int AS) {
        var mh$ = LLVMPointerSizeForAS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPointerSizeForAS", TD, AS);
            }
            return (int)mh$.invokeExact(TD, AS);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntPtrType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntPtrType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrType(LLVMTargetDataRef TD)
     * }
     */
    public static FunctionDescriptor LLVMIntPtrType$descriptor() {
        return LLVMIntPtrType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrType(LLVMTargetDataRef TD)
     * }
     */
    public static MethodHandle LLVMIntPtrType$handle() {
        return LLVMIntPtrType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrType(LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMIntPtrType$address() {
        return LLVMIntPtrType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrType(LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMIntPtrType(MemorySegment TD) {
        var mh$ = LLVMIntPtrType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntPtrType", TD);
            }
            return (MemorySegment)mh$.invokeExact(TD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntPtrTypeForAS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntPtrTypeForAS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeForAS(LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static FunctionDescriptor LLVMIntPtrTypeForAS$descriptor() {
        return LLVMIntPtrTypeForAS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeForAS(LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static MethodHandle LLVMIntPtrTypeForAS$handle() {
        return LLVMIntPtrTypeForAS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeForAS(LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static MemorySegment LLVMIntPtrTypeForAS$address() {
        return LLVMIntPtrTypeForAS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeForAS(LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static MemorySegment LLVMIntPtrTypeForAS(MemorySegment TD, int AS) {
        var mh$ = LLVMIntPtrTypeForAS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntPtrTypeForAS", TD, AS);
            }
            return (MemorySegment)mh$.invokeExact(TD, AS);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntPtrTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntPtrTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeInContext(LLVMContextRef C, LLVMTargetDataRef TD)
     * }
     */
    public static FunctionDescriptor LLVMIntPtrTypeInContext$descriptor() {
        return LLVMIntPtrTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeInContext(LLVMContextRef C, LLVMTargetDataRef TD)
     * }
     */
    public static MethodHandle LLVMIntPtrTypeInContext$handle() {
        return LLVMIntPtrTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeInContext(LLVMContextRef C, LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMIntPtrTypeInContext$address() {
        return LLVMIntPtrTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeInContext(LLVMContextRef C, LLVMTargetDataRef TD)
     * }
     */
    public static MemorySegment LLVMIntPtrTypeInContext(MemorySegment C, MemorySegment TD) {
        var mh$ = LLVMIntPtrTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntPtrTypeInContext", C, TD);
            }
            return (MemorySegment)mh$.invokeExact(C, TD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntPtrTypeForASInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntPtrTypeForASInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeForASInContext(LLVMContextRef C, LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static FunctionDescriptor LLVMIntPtrTypeForASInContext$descriptor() {
        return LLVMIntPtrTypeForASInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeForASInContext(LLVMContextRef C, LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static MethodHandle LLVMIntPtrTypeForASInContext$handle() {
        return LLVMIntPtrTypeForASInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeForASInContext(LLVMContextRef C, LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static MemorySegment LLVMIntPtrTypeForASInContext$address() {
        return LLVMIntPtrTypeForASInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntPtrTypeForASInContext(LLVMContextRef C, LLVMTargetDataRef TD, unsigned int AS)
     * }
     */
    public static MemorySegment LLVMIntPtrTypeForASInContext(MemorySegment C, MemorySegment TD, int AS) {
        var mh$ = LLVMIntPtrTypeForASInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntPtrTypeForASInContext", C, TD, AS);
            }
            return (MemorySegment)mh$.invokeExact(C, TD, AS);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSizeOfTypeInBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSizeOfTypeInBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long LLVMSizeOfTypeInBits(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMSizeOfTypeInBits$descriptor() {
        return LLVMSizeOfTypeInBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long LLVMSizeOfTypeInBits(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMSizeOfTypeInBits$handle() {
        return LLVMSizeOfTypeInBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long LLVMSizeOfTypeInBits(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMSizeOfTypeInBits$address() {
        return LLVMSizeOfTypeInBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long LLVMSizeOfTypeInBits(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static long LLVMSizeOfTypeInBits(MemorySegment TD, MemorySegment Ty) {
        var mh$ = LLVMSizeOfTypeInBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSizeOfTypeInBits", TD, Ty);
            }
            return (long)mh$.invokeExact(TD, Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStoreSizeOfType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStoreSizeOfType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long LLVMStoreSizeOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMStoreSizeOfType$descriptor() {
        return LLVMStoreSizeOfType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long LLVMStoreSizeOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMStoreSizeOfType$handle() {
        return LLVMStoreSizeOfType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long LLVMStoreSizeOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMStoreSizeOfType$address() {
        return LLVMStoreSizeOfType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long LLVMStoreSizeOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static long LLVMStoreSizeOfType(MemorySegment TD, MemorySegment Ty) {
        var mh$ = LLVMStoreSizeOfType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStoreSizeOfType", TD, Ty);
            }
            return (long)mh$.invokeExact(TD, Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMABISizeOfType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMABISizeOfType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long LLVMABISizeOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMABISizeOfType$descriptor() {
        return LLVMABISizeOfType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long LLVMABISizeOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMABISizeOfType$handle() {
        return LLVMABISizeOfType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long LLVMABISizeOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMABISizeOfType$address() {
        return LLVMABISizeOfType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long LLVMABISizeOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static long LLVMABISizeOfType(MemorySegment TD, MemorySegment Ty) {
        var mh$ = LLVMABISizeOfType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMABISizeOfType", TD, Ty);
            }
            return (long)mh$.invokeExact(TD, Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMABIAlignmentOfType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMABIAlignmentOfType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMABIAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMABIAlignmentOfType$descriptor() {
        return LLVMABIAlignmentOfType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMABIAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMABIAlignmentOfType$handle() {
        return LLVMABIAlignmentOfType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMABIAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMABIAlignmentOfType$address() {
        return LLVMABIAlignmentOfType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMABIAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static int LLVMABIAlignmentOfType(MemorySegment TD, MemorySegment Ty) {
        var mh$ = LLVMABIAlignmentOfType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMABIAlignmentOfType", TD, Ty);
            }
            return (int)mh$.invokeExact(TD, Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCallFrameAlignmentOfType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCallFrameAlignmentOfType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCallFrameAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMCallFrameAlignmentOfType$descriptor() {
        return LLVMCallFrameAlignmentOfType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCallFrameAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMCallFrameAlignmentOfType$handle() {
        return LLVMCallFrameAlignmentOfType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCallFrameAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMCallFrameAlignmentOfType$address() {
        return LLVMCallFrameAlignmentOfType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCallFrameAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static int LLVMCallFrameAlignmentOfType(MemorySegment TD, MemorySegment Ty) {
        var mh$ = LLVMCallFrameAlignmentOfType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCallFrameAlignmentOfType", TD, Ty);
            }
            return (int)mh$.invokeExact(TD, Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPreferredAlignmentOfType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPreferredAlignmentOfType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMPreferredAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMPreferredAlignmentOfType$descriptor() {
        return LLVMPreferredAlignmentOfType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMPreferredAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMPreferredAlignmentOfType$handle() {
        return LLVMPreferredAlignmentOfType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMPreferredAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMPreferredAlignmentOfType$address() {
        return LLVMPreferredAlignmentOfType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMPreferredAlignmentOfType(LLVMTargetDataRef TD, LLVMTypeRef Ty)
     * }
     */
    public static int LLVMPreferredAlignmentOfType(MemorySegment TD, MemorySegment Ty) {
        var mh$ = LLVMPreferredAlignmentOfType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPreferredAlignmentOfType", TD, Ty);
            }
            return (int)mh$.invokeExact(TD, Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPreferredAlignmentOfGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPreferredAlignmentOfGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMPreferredAlignmentOfGlobal(LLVMTargetDataRef TD, LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMPreferredAlignmentOfGlobal$descriptor() {
        return LLVMPreferredAlignmentOfGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMPreferredAlignmentOfGlobal(LLVMTargetDataRef TD, LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMPreferredAlignmentOfGlobal$handle() {
        return LLVMPreferredAlignmentOfGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMPreferredAlignmentOfGlobal(LLVMTargetDataRef TD, LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMPreferredAlignmentOfGlobal$address() {
        return LLVMPreferredAlignmentOfGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMPreferredAlignmentOfGlobal(LLVMTargetDataRef TD, LLVMValueRef GlobalVar)
     * }
     */
    public static int LLVMPreferredAlignmentOfGlobal(MemorySegment TD, MemorySegment GlobalVar) {
        var mh$ = LLVMPreferredAlignmentOfGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPreferredAlignmentOfGlobal", TD, GlobalVar);
            }
            return (int)mh$.invokeExact(TD, GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMElementAtOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMElementAtOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMElementAtOffset(LLVMTargetDataRef TD, LLVMTypeRef StructTy, unsigned long long Offset)
     * }
     */
    public static FunctionDescriptor LLVMElementAtOffset$descriptor() {
        return LLVMElementAtOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMElementAtOffset(LLVMTargetDataRef TD, LLVMTypeRef StructTy, unsigned long long Offset)
     * }
     */
    public static MethodHandle LLVMElementAtOffset$handle() {
        return LLVMElementAtOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMElementAtOffset(LLVMTargetDataRef TD, LLVMTypeRef StructTy, unsigned long long Offset)
     * }
     */
    public static MemorySegment LLVMElementAtOffset$address() {
        return LLVMElementAtOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMElementAtOffset(LLVMTargetDataRef TD, LLVMTypeRef StructTy, unsigned long long Offset)
     * }
     */
    public static int LLVMElementAtOffset(MemorySegment TD, MemorySegment StructTy, long Offset) {
        var mh$ = LLVMElementAtOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMElementAtOffset", TD, StructTy, Offset);
            }
            return (int)mh$.invokeExact(TD, StructTy, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMOffsetOfElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMOffsetOfElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long LLVMOffsetOfElement(LLVMTargetDataRef TD, LLVMTypeRef StructTy, unsigned int Element)
     * }
     */
    public static FunctionDescriptor LLVMOffsetOfElement$descriptor() {
        return LLVMOffsetOfElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long LLVMOffsetOfElement(LLVMTargetDataRef TD, LLVMTypeRef StructTy, unsigned int Element)
     * }
     */
    public static MethodHandle LLVMOffsetOfElement$handle() {
        return LLVMOffsetOfElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long LLVMOffsetOfElement(LLVMTargetDataRef TD, LLVMTypeRef StructTy, unsigned int Element)
     * }
     */
    public static MemorySegment LLVMOffsetOfElement$address() {
        return LLVMOffsetOfElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long LLVMOffsetOfElement(LLVMTargetDataRef TD, LLVMTypeRef StructTy, unsigned int Element)
     * }
     */
    public static long LLVMOffsetOfElement(MemorySegment TD, MemorySegment StructTy, int Element) {
        var mh$ = LLVMOffsetOfElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMOffsetOfElement", TD, StructTy, Element);
            }
            return (long)mh$.invokeExact(TD, StructTy, Element);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueTargetMachineOptions *LLVMTargetMachineOptionsRef
     * }
     */
    public static final AddressLayout LLVMTargetMachineOptionsRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef
     * }
     */
    public static final AddressLayout LLVMTargetMachineRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMTarget *LLVMTargetRef
     * }
     */
    public static final AddressLayout LLVMTargetRef = LLVM.C_POINTER;
    private static final int LLVMCodeGenLevelNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeGenLevelNone = 0
     * }
     */
    public static int LLVMCodeGenLevelNone() {
        return LLVMCodeGenLevelNone;
    }
    private static final int LLVMCodeGenLevelLess = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeGenLevelLess = 1
     * }
     */
    public static int LLVMCodeGenLevelLess() {
        return LLVMCodeGenLevelLess;
    }
    private static final int LLVMCodeGenLevelDefault = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeGenLevelDefault = 2
     * }
     */
    public static int LLVMCodeGenLevelDefault() {
        return LLVMCodeGenLevelDefault;
    }
    private static final int LLVMCodeGenLevelAggressive = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeGenLevelAggressive = 3
     * }
     */
    public static int LLVMCodeGenLevelAggressive() {
        return LLVMCodeGenLevelAggressive;
    }
    private static final int LLVMRelocDefault = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRelocDefault = 0
     * }
     */
    public static int LLVMRelocDefault() {
        return LLVMRelocDefault;
    }
    private static final int LLVMRelocStatic = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRelocStatic = 1
     * }
     */
    public static int LLVMRelocStatic() {
        return LLVMRelocStatic;
    }
    private static final int LLVMRelocPIC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRelocPIC = 2
     * }
     */
    public static int LLVMRelocPIC() {
        return LLVMRelocPIC;
    }
    private static final int LLVMRelocDynamicNoPic = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRelocDynamicNoPic = 3
     * }
     */
    public static int LLVMRelocDynamicNoPic() {
        return LLVMRelocDynamicNoPic;
    }
    private static final int LLVMRelocROPI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRelocROPI = 4
     * }
     */
    public static int LLVMRelocROPI() {
        return LLVMRelocROPI;
    }
    private static final int LLVMRelocRWPI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRelocRWPI = 5
     * }
     */
    public static int LLVMRelocRWPI() {
        return LLVMRelocRWPI;
    }
    private static final int LLVMRelocROPI_RWPI = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRelocROPI_RWPI = 6
     * }
     */
    public static int LLVMRelocROPI_RWPI() {
        return LLVMRelocROPI_RWPI;
    }
    private static final int LLVMCodeModelDefault = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeModelDefault = 0
     * }
     */
    public static int LLVMCodeModelDefault() {
        return LLVMCodeModelDefault;
    }
    private static final int LLVMCodeModelJITDefault = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeModelJITDefault = 1
     * }
     */
    public static int LLVMCodeModelJITDefault() {
        return LLVMCodeModelJITDefault;
    }
    private static final int LLVMCodeModelTiny = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeModelTiny = 2
     * }
     */
    public static int LLVMCodeModelTiny() {
        return LLVMCodeModelTiny;
    }
    private static final int LLVMCodeModelSmall = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeModelSmall = 3
     * }
     */
    public static int LLVMCodeModelSmall() {
        return LLVMCodeModelSmall;
    }
    private static final int LLVMCodeModelKernel = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeModelKernel = 4
     * }
     */
    public static int LLVMCodeModelKernel() {
        return LLVMCodeModelKernel;
    }
    private static final int LLVMCodeModelMedium = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeModelMedium = 5
     * }
     */
    public static int LLVMCodeModelMedium() {
        return LLVMCodeModelMedium;
    }
    private static final int LLVMCodeModelLarge = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCodeModelLarge = 6
     * }
     */
    public static int LLVMCodeModelLarge() {
        return LLVMCodeModelLarge;
    }
    private static final int LLVMAssemblyFile = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAssemblyFile = 0
     * }
     */
    public static int LLVMAssemblyFile() {
        return LLVMAssemblyFile;
    }
    private static final int LLVMObjectFile = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMObjectFile = 1
     * }
     */
    public static int LLVMObjectFile() {
        return LLVMObjectFile;
    }
    private static final int LLVMGlobalISelAbortEnable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGlobalISelAbortEnable = 0
     * }
     */
    public static int LLVMGlobalISelAbortEnable() {
        return LLVMGlobalISelAbortEnable;
    }
    private static final int LLVMGlobalISelAbortDisable = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGlobalISelAbortDisable = 1
     * }
     */
    public static int LLVMGlobalISelAbortDisable() {
        return LLVMGlobalISelAbortDisable;
    }
    private static final int LLVMGlobalISelAbortDisableWithDiag = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGlobalISelAbortDisableWithDiag = 2
     * }
     */
    public static int LLVMGlobalISelAbortDisableWithDiag() {
        return LLVMGlobalISelAbortDisableWithDiag;
    }

    private static class LLVMGetFirstTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetFirstTarget()
     * }
     */
    public static FunctionDescriptor LLVMGetFirstTarget$descriptor() {
        return LLVMGetFirstTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetFirstTarget()
     * }
     */
    public static MethodHandle LLVMGetFirstTarget$handle() {
        return LLVMGetFirstTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetFirstTarget()
     * }
     */
    public static MemorySegment LLVMGetFirstTarget$address() {
        return LLVMGetFirstTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetFirstTarget()
     * }
     */
    public static MemorySegment LLVMGetFirstTarget() {
        var mh$ = LLVMGetFirstTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstTarget");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetNextTarget(LLVMTargetRef T)
     * }
     */
    public static FunctionDescriptor LLVMGetNextTarget$descriptor() {
        return LLVMGetNextTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetNextTarget(LLVMTargetRef T)
     * }
     */
    public static MethodHandle LLVMGetNextTarget$handle() {
        return LLVMGetNextTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetNextTarget(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMGetNextTarget$address() {
        return LLVMGetNextTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetNextTarget(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMGetNextTarget(MemorySegment T) {
        var mh$ = LLVMGetNextTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextTarget", T);
            }
            return (MemorySegment)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetFromName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetFromName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetTargetFromName(const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetFromName$descriptor() {
        return LLVMGetTargetFromName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetTargetFromName(const char *Name)
     * }
     */
    public static MethodHandle LLVMGetTargetFromName$handle() {
        return LLVMGetTargetFromName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetTargetFromName(const char *Name)
     * }
     */
    public static MemorySegment LLVMGetTargetFromName$address() {
        return LLVMGetTargetFromName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetTargetFromName(const char *Name)
     * }
     */
    public static MemorySegment LLVMGetTargetFromName(MemorySegment Name) {
        var mh$ = LLVMGetTargetFromName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetFromName", Name);
            }
            return (MemorySegment)mh$.invokeExact(Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetFromTriple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetFromTriple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetTargetFromTriple(const char *Triple, LLVMTargetRef *T, char **ErrorMessage)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetFromTriple$descriptor() {
        return LLVMGetTargetFromTriple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetTargetFromTriple(const char *Triple, LLVMTargetRef *T, char **ErrorMessage)
     * }
     */
    public static MethodHandle LLVMGetTargetFromTriple$handle() {
        return LLVMGetTargetFromTriple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetTargetFromTriple(const char *Triple, LLVMTargetRef *T, char **ErrorMessage)
     * }
     */
    public static MemorySegment LLVMGetTargetFromTriple$address() {
        return LLVMGetTargetFromTriple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetTargetFromTriple(const char *Triple, LLVMTargetRef *T, char **ErrorMessage)
     * }
     */
    public static int LLVMGetTargetFromTriple(MemorySegment Triple, MemorySegment T, MemorySegment ErrorMessage) {
        var mh$ = LLVMGetTargetFromTriple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetFromTriple", Triple, T, ErrorMessage);
            }
            return (int)mh$.invokeExact(Triple, T, ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetName(LLVMTargetRef T)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetName$descriptor() {
        return LLVMGetTargetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetName(LLVMTargetRef T)
     * }
     */
    public static MethodHandle LLVMGetTargetName$handle() {
        return LLVMGetTargetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetName(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetName$address() {
        return LLVMGetTargetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetTargetName(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetName(MemorySegment T) {
        var mh$ = LLVMGetTargetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetName", T);
            }
            return (MemorySegment)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetDescription(LLVMTargetRef T)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetDescription$descriptor() {
        return LLVMGetTargetDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetDescription(LLVMTargetRef T)
     * }
     */
    public static MethodHandle LLVMGetTargetDescription$handle() {
        return LLVMGetTargetDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetDescription(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetDescription$address() {
        return LLVMGetTargetDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetTargetDescription(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetDescription(MemorySegment T) {
        var mh$ = LLVMGetTargetDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetDescription", T);
            }
            return (MemorySegment)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetHasJIT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetHasJIT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasJIT(LLVMTargetRef T)
     * }
     */
    public static FunctionDescriptor LLVMTargetHasJIT$descriptor() {
        return LLVMTargetHasJIT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasJIT(LLVMTargetRef T)
     * }
     */
    public static MethodHandle LLVMTargetHasJIT$handle() {
        return LLVMTargetHasJIT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasJIT(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMTargetHasJIT$address() {
        return LLVMTargetHasJIT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasJIT(LLVMTargetRef T)
     * }
     */
    public static int LLVMTargetHasJIT(MemorySegment T) {
        var mh$ = LLVMTargetHasJIT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetHasJIT", T);
            }
            return (int)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetHasTargetMachine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetHasTargetMachine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasTargetMachine(LLVMTargetRef T)
     * }
     */
    public static FunctionDescriptor LLVMTargetHasTargetMachine$descriptor() {
        return LLVMTargetHasTargetMachine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasTargetMachine(LLVMTargetRef T)
     * }
     */
    public static MethodHandle LLVMTargetHasTargetMachine$handle() {
        return LLVMTargetHasTargetMachine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasTargetMachine(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMTargetHasTargetMachine$address() {
        return LLVMTargetHasTargetMachine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasTargetMachine(LLVMTargetRef T)
     * }
     */
    public static int LLVMTargetHasTargetMachine(MemorySegment T) {
        var mh$ = LLVMTargetHasTargetMachine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetHasTargetMachine", T);
            }
            return (int)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetHasAsmBackend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetHasAsmBackend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasAsmBackend(LLVMTargetRef T)
     * }
     */
    public static FunctionDescriptor LLVMTargetHasAsmBackend$descriptor() {
        return LLVMTargetHasAsmBackend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasAsmBackend(LLVMTargetRef T)
     * }
     */
    public static MethodHandle LLVMTargetHasAsmBackend$handle() {
        return LLVMTargetHasAsmBackend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasAsmBackend(LLVMTargetRef T)
     * }
     */
    public static MemorySegment LLVMTargetHasAsmBackend$address() {
        return LLVMTargetHasAsmBackend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMTargetHasAsmBackend(LLVMTargetRef T)
     * }
     */
    public static int LLVMTargetHasAsmBackend(MemorySegment T) {
        var mh$ = LLVMTargetHasAsmBackend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetHasAsmBackend", T);
            }
            return (int)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateTargetMachineOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateTargetMachineOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetMachineOptionsRef LLVMCreateTargetMachineOptions()
     * }
     */
    public static FunctionDescriptor LLVMCreateTargetMachineOptions$descriptor() {
        return LLVMCreateTargetMachineOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetMachineOptionsRef LLVMCreateTargetMachineOptions()
     * }
     */
    public static MethodHandle LLVMCreateTargetMachineOptions$handle() {
        return LLVMCreateTargetMachineOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetMachineOptionsRef LLVMCreateTargetMachineOptions()
     * }
     */
    public static MemorySegment LLVMCreateTargetMachineOptions$address() {
        return LLVMCreateTargetMachineOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetMachineOptionsRef LLVMCreateTargetMachineOptions()
     * }
     */
    public static MemorySegment LLVMCreateTargetMachineOptions() {
        var mh$ = LLVMCreateTargetMachineOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateTargetMachineOptions");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeTargetMachineOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeTargetMachineOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetMachineOptions(LLVMTargetMachineOptionsRef Options)
     * }
     */
    public static FunctionDescriptor LLVMDisposeTargetMachineOptions$descriptor() {
        return LLVMDisposeTargetMachineOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetMachineOptions(LLVMTargetMachineOptionsRef Options)
     * }
     */
    public static MethodHandle LLVMDisposeTargetMachineOptions$handle() {
        return LLVMDisposeTargetMachineOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetMachineOptions(LLVMTargetMachineOptionsRef Options)
     * }
     */
    public static MemorySegment LLVMDisposeTargetMachineOptions$address() {
        return LLVMDisposeTargetMachineOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeTargetMachineOptions(LLVMTargetMachineOptionsRef Options)
     * }
     */
    public static void LLVMDisposeTargetMachineOptions(MemorySegment Options) {
        var mh$ = LLVMDisposeTargetMachineOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeTargetMachineOptions", Options);
            }
            mh$.invokeExact(Options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetMachineOptionsSetCPU {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetMachineOptionsSetCPU");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCPU(LLVMTargetMachineOptionsRef Options, const char *CPU)
     * }
     */
    public static FunctionDescriptor LLVMTargetMachineOptionsSetCPU$descriptor() {
        return LLVMTargetMachineOptionsSetCPU.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCPU(LLVMTargetMachineOptionsRef Options, const char *CPU)
     * }
     */
    public static MethodHandle LLVMTargetMachineOptionsSetCPU$handle() {
        return LLVMTargetMachineOptionsSetCPU.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCPU(LLVMTargetMachineOptionsRef Options, const char *CPU)
     * }
     */
    public static MemorySegment LLVMTargetMachineOptionsSetCPU$address() {
        return LLVMTargetMachineOptionsSetCPU.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCPU(LLVMTargetMachineOptionsRef Options, const char *CPU)
     * }
     */
    public static void LLVMTargetMachineOptionsSetCPU(MemorySegment Options, MemorySegment CPU) {
        var mh$ = LLVMTargetMachineOptionsSetCPU.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetMachineOptionsSetCPU", Options, CPU);
            }
            mh$.invokeExact(Options, CPU);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetMachineOptionsSetFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetMachineOptionsSetFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetFeatures(LLVMTargetMachineOptionsRef Options, const char *Features)
     * }
     */
    public static FunctionDescriptor LLVMTargetMachineOptionsSetFeatures$descriptor() {
        return LLVMTargetMachineOptionsSetFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetFeatures(LLVMTargetMachineOptionsRef Options, const char *Features)
     * }
     */
    public static MethodHandle LLVMTargetMachineOptionsSetFeatures$handle() {
        return LLVMTargetMachineOptionsSetFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetFeatures(LLVMTargetMachineOptionsRef Options, const char *Features)
     * }
     */
    public static MemorySegment LLVMTargetMachineOptionsSetFeatures$address() {
        return LLVMTargetMachineOptionsSetFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetFeatures(LLVMTargetMachineOptionsRef Options, const char *Features)
     * }
     */
    public static void LLVMTargetMachineOptionsSetFeatures(MemorySegment Options, MemorySegment Features) {
        var mh$ = LLVMTargetMachineOptionsSetFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetMachineOptionsSetFeatures", Options, Features);
            }
            mh$.invokeExact(Options, Features);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetMachineOptionsSetABI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetMachineOptionsSetABI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetABI(LLVMTargetMachineOptionsRef Options, const char *ABI)
     * }
     */
    public static FunctionDescriptor LLVMTargetMachineOptionsSetABI$descriptor() {
        return LLVMTargetMachineOptionsSetABI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetABI(LLVMTargetMachineOptionsRef Options, const char *ABI)
     * }
     */
    public static MethodHandle LLVMTargetMachineOptionsSetABI$handle() {
        return LLVMTargetMachineOptionsSetABI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetABI(LLVMTargetMachineOptionsRef Options, const char *ABI)
     * }
     */
    public static MemorySegment LLVMTargetMachineOptionsSetABI$address() {
        return LLVMTargetMachineOptionsSetABI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetABI(LLVMTargetMachineOptionsRef Options, const char *ABI)
     * }
     */
    public static void LLVMTargetMachineOptionsSetABI(MemorySegment Options, MemorySegment ABI) {
        var mh$ = LLVMTargetMachineOptionsSetABI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetMachineOptionsSetABI", Options, ABI);
            }
            mh$.invokeExact(Options, ABI);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetMachineOptionsSetCodeGenOptLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetMachineOptionsSetCodeGenOptLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCodeGenOptLevel(LLVMTargetMachineOptionsRef Options, LLVMCodeGenOptLevel Level)
     * }
     */
    public static FunctionDescriptor LLVMTargetMachineOptionsSetCodeGenOptLevel$descriptor() {
        return LLVMTargetMachineOptionsSetCodeGenOptLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCodeGenOptLevel(LLVMTargetMachineOptionsRef Options, LLVMCodeGenOptLevel Level)
     * }
     */
    public static MethodHandle LLVMTargetMachineOptionsSetCodeGenOptLevel$handle() {
        return LLVMTargetMachineOptionsSetCodeGenOptLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCodeGenOptLevel(LLVMTargetMachineOptionsRef Options, LLVMCodeGenOptLevel Level)
     * }
     */
    public static MemorySegment LLVMTargetMachineOptionsSetCodeGenOptLevel$address() {
        return LLVMTargetMachineOptionsSetCodeGenOptLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCodeGenOptLevel(LLVMTargetMachineOptionsRef Options, LLVMCodeGenOptLevel Level)
     * }
     */
    public static void LLVMTargetMachineOptionsSetCodeGenOptLevel(MemorySegment Options, int Level) {
        var mh$ = LLVMTargetMachineOptionsSetCodeGenOptLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetMachineOptionsSetCodeGenOptLevel", Options, Level);
            }
            mh$.invokeExact(Options, Level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetMachineOptionsSetRelocMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetMachineOptionsSetRelocMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetRelocMode(LLVMTargetMachineOptionsRef Options, LLVMRelocMode Reloc)
     * }
     */
    public static FunctionDescriptor LLVMTargetMachineOptionsSetRelocMode$descriptor() {
        return LLVMTargetMachineOptionsSetRelocMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetRelocMode(LLVMTargetMachineOptionsRef Options, LLVMRelocMode Reloc)
     * }
     */
    public static MethodHandle LLVMTargetMachineOptionsSetRelocMode$handle() {
        return LLVMTargetMachineOptionsSetRelocMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetRelocMode(LLVMTargetMachineOptionsRef Options, LLVMRelocMode Reloc)
     * }
     */
    public static MemorySegment LLVMTargetMachineOptionsSetRelocMode$address() {
        return LLVMTargetMachineOptionsSetRelocMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetRelocMode(LLVMTargetMachineOptionsRef Options, LLVMRelocMode Reloc)
     * }
     */
    public static void LLVMTargetMachineOptionsSetRelocMode(MemorySegment Options, int Reloc) {
        var mh$ = LLVMTargetMachineOptionsSetRelocMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetMachineOptionsSetRelocMode", Options, Reloc);
            }
            mh$.invokeExact(Options, Reloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetMachineOptionsSetCodeModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetMachineOptionsSetCodeModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCodeModel(LLVMTargetMachineOptionsRef Options, LLVMCodeModel CodeModel)
     * }
     */
    public static FunctionDescriptor LLVMTargetMachineOptionsSetCodeModel$descriptor() {
        return LLVMTargetMachineOptionsSetCodeModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCodeModel(LLVMTargetMachineOptionsRef Options, LLVMCodeModel CodeModel)
     * }
     */
    public static MethodHandle LLVMTargetMachineOptionsSetCodeModel$handle() {
        return LLVMTargetMachineOptionsSetCodeModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCodeModel(LLVMTargetMachineOptionsRef Options, LLVMCodeModel CodeModel)
     * }
     */
    public static MemorySegment LLVMTargetMachineOptionsSetCodeModel$address() {
        return LLVMTargetMachineOptionsSetCodeModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMTargetMachineOptionsSetCodeModel(LLVMTargetMachineOptionsRef Options, LLVMCodeModel CodeModel)
     * }
     */
    public static void LLVMTargetMachineOptionsSetCodeModel(MemorySegment Options, int CodeModel) {
        var mh$ = LLVMTargetMachineOptionsSetCodeModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetMachineOptionsSetCodeModel", Options, CodeModel);
            }
            mh$.invokeExact(Options, CodeModel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateTargetMachineWithOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateTargetMachineWithOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMCreateTargetMachineWithOptions(LLVMTargetRef T, const char *Triple, LLVMTargetMachineOptionsRef Options)
     * }
     */
    public static FunctionDescriptor LLVMCreateTargetMachineWithOptions$descriptor() {
        return LLVMCreateTargetMachineWithOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMCreateTargetMachineWithOptions(LLVMTargetRef T, const char *Triple, LLVMTargetMachineOptionsRef Options)
     * }
     */
    public static MethodHandle LLVMCreateTargetMachineWithOptions$handle() {
        return LLVMCreateTargetMachineWithOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMCreateTargetMachineWithOptions(LLVMTargetRef T, const char *Triple, LLVMTargetMachineOptionsRef Options)
     * }
     */
    public static MemorySegment LLVMCreateTargetMachineWithOptions$address() {
        return LLVMCreateTargetMachineWithOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMCreateTargetMachineWithOptions(LLVMTargetRef T, const char *Triple, LLVMTargetMachineOptionsRef Options)
     * }
     */
    public static MemorySegment LLVMCreateTargetMachineWithOptions(MemorySegment T, MemorySegment Triple, MemorySegment Options) {
        var mh$ = LLVMCreateTargetMachineWithOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateTargetMachineWithOptions", T, Triple, Options);
            }
            return (MemorySegment)mh$.invokeExact(T, Triple, Options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateTargetMachine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateTargetMachine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMCreateTargetMachine(LLVMTargetRef T, const char *Triple, const char *CPU, const char *Features, LLVMCodeGenOptLevel Level, LLVMRelocMode Reloc, LLVMCodeModel CodeModel)
     * }
     */
    public static FunctionDescriptor LLVMCreateTargetMachine$descriptor() {
        return LLVMCreateTargetMachine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMCreateTargetMachine(LLVMTargetRef T, const char *Triple, const char *CPU, const char *Features, LLVMCodeGenOptLevel Level, LLVMRelocMode Reloc, LLVMCodeModel CodeModel)
     * }
     */
    public static MethodHandle LLVMCreateTargetMachine$handle() {
        return LLVMCreateTargetMachine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMCreateTargetMachine(LLVMTargetRef T, const char *Triple, const char *CPU, const char *Features, LLVMCodeGenOptLevel Level, LLVMRelocMode Reloc, LLVMCodeModel CodeModel)
     * }
     */
    public static MemorySegment LLVMCreateTargetMachine$address() {
        return LLVMCreateTargetMachine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMCreateTargetMachine(LLVMTargetRef T, const char *Triple, const char *CPU, const char *Features, LLVMCodeGenOptLevel Level, LLVMRelocMode Reloc, LLVMCodeModel CodeModel)
     * }
     */
    public static MemorySegment LLVMCreateTargetMachine(MemorySegment T, MemorySegment Triple, MemorySegment CPU, MemorySegment Features, int Level, int Reloc, int CodeModel) {
        var mh$ = LLVMCreateTargetMachine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateTargetMachine", T, Triple, CPU, Features, Level, Reloc, CodeModel);
            }
            return (MemorySegment)mh$.invokeExact(T, Triple, CPU, Features, Level, Reloc, CodeModel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeTargetMachine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeTargetMachine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetMachine(LLVMTargetMachineRef T)
     * }
     */
    public static FunctionDescriptor LLVMDisposeTargetMachine$descriptor() {
        return LLVMDisposeTargetMachine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetMachine(LLVMTargetMachineRef T)
     * }
     */
    public static MethodHandle LLVMDisposeTargetMachine$handle() {
        return LLVMDisposeTargetMachine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeTargetMachine(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMDisposeTargetMachine$address() {
        return LLVMDisposeTargetMachine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeTargetMachine(LLVMTargetMachineRef T)
     * }
     */
    public static void LLVMDisposeTargetMachine(MemorySegment T) {
        var mh$ = LLVMDisposeTargetMachine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeTargetMachine", T);
            }
            mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetMachineTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetMachineTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetTargetMachineTarget(LLVMTargetMachineRef T)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetMachineTarget$descriptor() {
        return LLVMGetTargetMachineTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetTargetMachineTarget(LLVMTargetMachineRef T)
     * }
     */
    public static MethodHandle LLVMGetTargetMachineTarget$handle() {
        return LLVMGetTargetMachineTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetTargetMachineTarget(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetMachineTarget$address() {
        return LLVMGetTargetMachineTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetRef LLVMGetTargetMachineTarget(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetMachineTarget(MemorySegment T) {
        var mh$ = LLVMGetTargetMachineTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetMachineTarget", T);
            }
            return (MemorySegment)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetMachineTriple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetMachineTriple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineTriple(LLVMTargetMachineRef T)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetMachineTriple$descriptor() {
        return LLVMGetTargetMachineTriple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineTriple(LLVMTargetMachineRef T)
     * }
     */
    public static MethodHandle LLVMGetTargetMachineTriple$handle() {
        return LLVMGetTargetMachineTriple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineTriple(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetMachineTriple$address() {
        return LLVMGetTargetMachineTriple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineTriple(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetMachineTriple(MemorySegment T) {
        var mh$ = LLVMGetTargetMachineTriple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetMachineTriple", T);
            }
            return (MemorySegment)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetMachineCPU {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetMachineCPU");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineCPU(LLVMTargetMachineRef T)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetMachineCPU$descriptor() {
        return LLVMGetTargetMachineCPU.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineCPU(LLVMTargetMachineRef T)
     * }
     */
    public static MethodHandle LLVMGetTargetMachineCPU$handle() {
        return LLVMGetTargetMachineCPU.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineCPU(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetMachineCPU$address() {
        return LLVMGetTargetMachineCPU.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineCPU(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetMachineCPU(MemorySegment T) {
        var mh$ = LLVMGetTargetMachineCPU.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetMachineCPU", T);
            }
            return (MemorySegment)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetMachineFeatureString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetMachineFeatureString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineFeatureString(LLVMTargetMachineRef T)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetMachineFeatureString$descriptor() {
        return LLVMGetTargetMachineFeatureString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineFeatureString(LLVMTargetMachineRef T)
     * }
     */
    public static MethodHandle LLVMGetTargetMachineFeatureString$handle() {
        return LLVMGetTargetMachineFeatureString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineFeatureString(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetMachineFeatureString$address() {
        return LLVMGetTargetMachineFeatureString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMGetTargetMachineFeatureString(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMGetTargetMachineFeatureString(MemorySegment T) {
        var mh$ = LLVMGetTargetMachineFeatureString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetMachineFeatureString", T);
            }
            return (MemorySegment)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateTargetDataLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateTargetDataLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMCreateTargetDataLayout(LLVMTargetMachineRef T)
     * }
     */
    public static FunctionDescriptor LLVMCreateTargetDataLayout$descriptor() {
        return LLVMCreateTargetDataLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMCreateTargetDataLayout(LLVMTargetMachineRef T)
     * }
     */
    public static MethodHandle LLVMCreateTargetDataLayout$handle() {
        return LLVMCreateTargetDataLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMCreateTargetDataLayout(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMCreateTargetDataLayout$address() {
        return LLVMCreateTargetDataLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMCreateTargetDataLayout(LLVMTargetMachineRef T)
     * }
     */
    public static MemorySegment LLVMCreateTargetDataLayout(MemorySegment T) {
        var mh$ = LLVMCreateTargetDataLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateTargetDataLayout", T);
            }
            return (MemorySegment)mh$.invokeExact(T);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTargetMachineAsmVerbosity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTargetMachineAsmVerbosity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineAsmVerbosity(LLVMTargetMachineRef T, LLVMBool VerboseAsm)
     * }
     */
    public static FunctionDescriptor LLVMSetTargetMachineAsmVerbosity$descriptor() {
        return LLVMSetTargetMachineAsmVerbosity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineAsmVerbosity(LLVMTargetMachineRef T, LLVMBool VerboseAsm)
     * }
     */
    public static MethodHandle LLVMSetTargetMachineAsmVerbosity$handle() {
        return LLVMSetTargetMachineAsmVerbosity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineAsmVerbosity(LLVMTargetMachineRef T, LLVMBool VerboseAsm)
     * }
     */
    public static MemorySegment LLVMSetTargetMachineAsmVerbosity$address() {
        return LLVMSetTargetMachineAsmVerbosity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTargetMachineAsmVerbosity(LLVMTargetMachineRef T, LLVMBool VerboseAsm)
     * }
     */
    public static void LLVMSetTargetMachineAsmVerbosity(MemorySegment T, int VerboseAsm) {
        var mh$ = LLVMSetTargetMachineAsmVerbosity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTargetMachineAsmVerbosity", T, VerboseAsm);
            }
            mh$.invokeExact(T, VerboseAsm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTargetMachineFastISel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTargetMachineFastISel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineFastISel(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static FunctionDescriptor LLVMSetTargetMachineFastISel$descriptor() {
        return LLVMSetTargetMachineFastISel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineFastISel(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static MethodHandle LLVMSetTargetMachineFastISel$handle() {
        return LLVMSetTargetMachineFastISel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineFastISel(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static MemorySegment LLVMSetTargetMachineFastISel$address() {
        return LLVMSetTargetMachineFastISel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTargetMachineFastISel(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static void LLVMSetTargetMachineFastISel(MemorySegment T, int Enable) {
        var mh$ = LLVMSetTargetMachineFastISel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTargetMachineFastISel", T, Enable);
            }
            mh$.invokeExact(T, Enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTargetMachineGlobalISel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTargetMachineGlobalISel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineGlobalISel(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static FunctionDescriptor LLVMSetTargetMachineGlobalISel$descriptor() {
        return LLVMSetTargetMachineGlobalISel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineGlobalISel(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static MethodHandle LLVMSetTargetMachineGlobalISel$handle() {
        return LLVMSetTargetMachineGlobalISel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineGlobalISel(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static MemorySegment LLVMSetTargetMachineGlobalISel$address() {
        return LLVMSetTargetMachineGlobalISel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTargetMachineGlobalISel(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static void LLVMSetTargetMachineGlobalISel(MemorySegment T, int Enable) {
        var mh$ = LLVMSetTargetMachineGlobalISel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTargetMachineGlobalISel", T, Enable);
            }
            mh$.invokeExact(T, Enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTargetMachineGlobalISelAbort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTargetMachineGlobalISelAbort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineGlobalISelAbort(LLVMTargetMachineRef T, LLVMGlobalISelAbortMode Mode)
     * }
     */
    public static FunctionDescriptor LLVMSetTargetMachineGlobalISelAbort$descriptor() {
        return LLVMSetTargetMachineGlobalISelAbort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineGlobalISelAbort(LLVMTargetMachineRef T, LLVMGlobalISelAbortMode Mode)
     * }
     */
    public static MethodHandle LLVMSetTargetMachineGlobalISelAbort$handle() {
        return LLVMSetTargetMachineGlobalISelAbort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineGlobalISelAbort(LLVMTargetMachineRef T, LLVMGlobalISelAbortMode Mode)
     * }
     */
    public static MemorySegment LLVMSetTargetMachineGlobalISelAbort$address() {
        return LLVMSetTargetMachineGlobalISelAbort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTargetMachineGlobalISelAbort(LLVMTargetMachineRef T, LLVMGlobalISelAbortMode Mode)
     * }
     */
    public static void LLVMSetTargetMachineGlobalISelAbort(MemorySegment T, int Mode) {
        var mh$ = LLVMSetTargetMachineGlobalISelAbort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTargetMachineGlobalISelAbort", T, Mode);
            }
            mh$.invokeExact(T, Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTargetMachineMachineOutliner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTargetMachineMachineOutliner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineMachineOutliner(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static FunctionDescriptor LLVMSetTargetMachineMachineOutliner$descriptor() {
        return LLVMSetTargetMachineMachineOutliner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineMachineOutliner(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static MethodHandle LLVMSetTargetMachineMachineOutliner$handle() {
        return LLVMSetTargetMachineMachineOutliner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTargetMachineMachineOutliner(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static MemorySegment LLVMSetTargetMachineMachineOutliner$address() {
        return LLVMSetTargetMachineMachineOutliner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTargetMachineMachineOutliner(LLVMTargetMachineRef T, LLVMBool Enable)
     * }
     */
    public static void LLVMSetTargetMachineMachineOutliner(MemorySegment T, int Enable) {
        var mh$ = LLVMSetTargetMachineMachineOutliner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTargetMachineMachineOutliner", T, Enable);
            }
            mh$.invokeExact(T, Enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetMachineEmitToFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetMachineEmitToFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetMachineEmitToFile(LLVMTargetMachineRef T, LLVMModuleRef M, const char *Filename, LLVMCodeGenFileType codegen, char **ErrorMessage)
     * }
     */
    public static FunctionDescriptor LLVMTargetMachineEmitToFile$descriptor() {
        return LLVMTargetMachineEmitToFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetMachineEmitToFile(LLVMTargetMachineRef T, LLVMModuleRef M, const char *Filename, LLVMCodeGenFileType codegen, char **ErrorMessage)
     * }
     */
    public static MethodHandle LLVMTargetMachineEmitToFile$handle() {
        return LLVMTargetMachineEmitToFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetMachineEmitToFile(LLVMTargetMachineRef T, LLVMModuleRef M, const char *Filename, LLVMCodeGenFileType codegen, char **ErrorMessage)
     * }
     */
    public static MemorySegment LLVMTargetMachineEmitToFile$address() {
        return LLVMTargetMachineEmitToFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMTargetMachineEmitToFile(LLVMTargetMachineRef T, LLVMModuleRef M, const char *Filename, LLVMCodeGenFileType codegen, char **ErrorMessage)
     * }
     */
    public static int LLVMTargetMachineEmitToFile(MemorySegment T, MemorySegment M, MemorySegment Filename, int codegen, MemorySegment ErrorMessage) {
        var mh$ = LLVMTargetMachineEmitToFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetMachineEmitToFile", T, M, Filename, codegen, ErrorMessage);
            }
            return (int)mh$.invokeExact(T, M, Filename, codegen, ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetMachineEmitToMemoryBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetMachineEmitToMemoryBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetMachineEmitToMemoryBuffer(LLVMTargetMachineRef T, LLVMModuleRef M, LLVMCodeGenFileType codegen, char **ErrorMessage, LLVMMemoryBufferRef *OutMemBuf)
     * }
     */
    public static FunctionDescriptor LLVMTargetMachineEmitToMemoryBuffer$descriptor() {
        return LLVMTargetMachineEmitToMemoryBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetMachineEmitToMemoryBuffer(LLVMTargetMachineRef T, LLVMModuleRef M, LLVMCodeGenFileType codegen, char **ErrorMessage, LLVMMemoryBufferRef *OutMemBuf)
     * }
     */
    public static MethodHandle LLVMTargetMachineEmitToMemoryBuffer$handle() {
        return LLVMTargetMachineEmitToMemoryBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMTargetMachineEmitToMemoryBuffer(LLVMTargetMachineRef T, LLVMModuleRef M, LLVMCodeGenFileType codegen, char **ErrorMessage, LLVMMemoryBufferRef *OutMemBuf)
     * }
     */
    public static MemorySegment LLVMTargetMachineEmitToMemoryBuffer$address() {
        return LLVMTargetMachineEmitToMemoryBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMTargetMachineEmitToMemoryBuffer(LLVMTargetMachineRef T, LLVMModuleRef M, LLVMCodeGenFileType codegen, char **ErrorMessage, LLVMMemoryBufferRef *OutMemBuf)
     * }
     */
    public static int LLVMTargetMachineEmitToMemoryBuffer(MemorySegment T, MemorySegment M, int codegen, MemorySegment ErrorMessage, MemorySegment OutMemBuf) {
        var mh$ = LLVMTargetMachineEmitToMemoryBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetMachineEmitToMemoryBuffer", T, M, codegen, ErrorMessage, OutMemBuf);
            }
            return (int)mh$.invokeExact(T, M, codegen, ErrorMessage, OutMemBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDefaultTargetTriple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDefaultTargetTriple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMGetDefaultTargetTriple()
     * }
     */
    public static FunctionDescriptor LLVMGetDefaultTargetTriple$descriptor() {
        return LLVMGetDefaultTargetTriple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMGetDefaultTargetTriple()
     * }
     */
    public static MethodHandle LLVMGetDefaultTargetTriple$handle() {
        return LLVMGetDefaultTargetTriple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMGetDefaultTargetTriple()
     * }
     */
    public static MemorySegment LLVMGetDefaultTargetTriple$address() {
        return LLVMGetDefaultTargetTriple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMGetDefaultTargetTriple()
     * }
     */
    public static MemorySegment LLVMGetDefaultTargetTriple() {
        var mh$ = LLVMGetDefaultTargetTriple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDefaultTargetTriple");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMNormalizeTargetTriple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMNormalizeTargetTriple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMNormalizeTargetTriple(const char *triple)
     * }
     */
    public static FunctionDescriptor LLVMNormalizeTargetTriple$descriptor() {
        return LLVMNormalizeTargetTriple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMNormalizeTargetTriple(const char *triple)
     * }
     */
    public static MethodHandle LLVMNormalizeTargetTriple$handle() {
        return LLVMNormalizeTargetTriple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMNormalizeTargetTriple(const char *triple)
     * }
     */
    public static MemorySegment LLVMNormalizeTargetTriple$address() {
        return LLVMNormalizeTargetTriple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMNormalizeTargetTriple(const char *triple)
     * }
     */
    public static MemorySegment LLVMNormalizeTargetTriple(MemorySegment triple) {
        var mh$ = LLVMNormalizeTargetTriple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMNormalizeTargetTriple", triple);
            }
            return (MemorySegment)mh$.invokeExact(triple);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetHostCPUName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetHostCPUName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMGetHostCPUName()
     * }
     */
    public static FunctionDescriptor LLVMGetHostCPUName$descriptor() {
        return LLVMGetHostCPUName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMGetHostCPUName()
     * }
     */
    public static MethodHandle LLVMGetHostCPUName$handle() {
        return LLVMGetHostCPUName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMGetHostCPUName()
     * }
     */
    public static MemorySegment LLVMGetHostCPUName$address() {
        return LLVMGetHostCPUName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMGetHostCPUName()
     * }
     */
    public static MemorySegment LLVMGetHostCPUName() {
        var mh$ = LLVMGetHostCPUName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetHostCPUName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetHostCPUFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetHostCPUFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMGetHostCPUFeatures()
     * }
     */
    public static FunctionDescriptor LLVMGetHostCPUFeatures$descriptor() {
        return LLVMGetHostCPUFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMGetHostCPUFeatures()
     * }
     */
    public static MethodHandle LLVMGetHostCPUFeatures$handle() {
        return LLVMGetHostCPUFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMGetHostCPUFeatures()
     * }
     */
    public static MemorySegment LLVMGetHostCPUFeatures$address() {
        return LLVMGetHostCPUFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMGetHostCPUFeatures()
     * }
     */
    public static MemorySegment LLVMGetHostCPUFeatures() {
        var mh$ = LLVMGetHostCPUFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetHostCPUFeatures");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddAnalysisPasses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddAnalysisPasses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddAnalysisPasses(LLVMTargetMachineRef T, LLVMPassManagerRef PM)
     * }
     */
    public static FunctionDescriptor LLVMAddAnalysisPasses$descriptor() {
        return LLVMAddAnalysisPasses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddAnalysisPasses(LLVMTargetMachineRef T, LLVMPassManagerRef PM)
     * }
     */
    public static MethodHandle LLVMAddAnalysisPasses$handle() {
        return LLVMAddAnalysisPasses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddAnalysisPasses(LLVMTargetMachineRef T, LLVMPassManagerRef PM)
     * }
     */
    public static MemorySegment LLVMAddAnalysisPasses$address() {
        return LLVMAddAnalysisPasses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddAnalysisPasses(LLVMTargetMachineRef T, LLVMPassManagerRef PM)
     * }
     */
    public static void LLVMAddAnalysisPasses(MemorySegment T, MemorySegment PM) {
        var mh$ = LLVMAddAnalysisPasses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddAnalysisPasses", T, PM);
            }
            mh$.invokeExact(T, PM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMLinkInMCJIT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMLinkInMCJIT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMLinkInMCJIT()
     * }
     */
    public static FunctionDescriptor LLVMLinkInMCJIT$descriptor() {
        return LLVMLinkInMCJIT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMLinkInMCJIT()
     * }
     */
    public static MethodHandle LLVMLinkInMCJIT$handle() {
        return LLVMLinkInMCJIT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMLinkInMCJIT()
     * }
     */
    public static MemorySegment LLVMLinkInMCJIT$address() {
        return LLVMLinkInMCJIT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMLinkInMCJIT()
     * }
     */
    public static void LLVMLinkInMCJIT() {
        var mh$ = LLVMLinkInMCJIT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMLinkInMCJIT");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMLinkInInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMLinkInInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMLinkInInterpreter()
     * }
     */
    public static FunctionDescriptor LLVMLinkInInterpreter$descriptor() {
        return LLVMLinkInInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMLinkInInterpreter()
     * }
     */
    public static MethodHandle LLVMLinkInInterpreter$handle() {
        return LLVMLinkInInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMLinkInInterpreter()
     * }
     */
    public static MemorySegment LLVMLinkInInterpreter$address() {
        return LLVMLinkInInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMLinkInInterpreter()
     * }
     */
    public static void LLVMLinkInInterpreter() {
        var mh$ = LLVMLinkInInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMLinkInInterpreter");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueGenericValue *LLVMGenericValueRef
     * }
     */
    public static final AddressLayout LLVMGenericValueRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueExecutionEngine *LLVMExecutionEngineRef
     * }
     */
    public static final AddressLayout LLVMExecutionEngineRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueMCJITMemoryManager *LLVMMCJITMemoryManagerRef
     * }
     */
    public static final AddressLayout LLVMMCJITMemoryManagerRef = LLVM.C_POINTER;

    private static class LLVMCreateGenericValueOfInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG_LONG,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateGenericValueOfInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfInt(LLVMTypeRef Ty, unsigned long long N, LLVMBool IsSigned)
     * }
     */
    public static FunctionDescriptor LLVMCreateGenericValueOfInt$descriptor() {
        return LLVMCreateGenericValueOfInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfInt(LLVMTypeRef Ty, unsigned long long N, LLVMBool IsSigned)
     * }
     */
    public static MethodHandle LLVMCreateGenericValueOfInt$handle() {
        return LLVMCreateGenericValueOfInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfInt(LLVMTypeRef Ty, unsigned long long N, LLVMBool IsSigned)
     * }
     */
    public static MemorySegment LLVMCreateGenericValueOfInt$address() {
        return LLVMCreateGenericValueOfInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfInt(LLVMTypeRef Ty, unsigned long long N, LLVMBool IsSigned)
     * }
     */
    public static MemorySegment LLVMCreateGenericValueOfInt(MemorySegment Ty, long N, int IsSigned) {
        var mh$ = LLVMCreateGenericValueOfInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateGenericValueOfInt", Ty, N, IsSigned);
            }
            return (MemorySegment)mh$.invokeExact(Ty, N, IsSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateGenericValueOfPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateGenericValueOfPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfPointer(void *P)
     * }
     */
    public static FunctionDescriptor LLVMCreateGenericValueOfPointer$descriptor() {
        return LLVMCreateGenericValueOfPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfPointer(void *P)
     * }
     */
    public static MethodHandle LLVMCreateGenericValueOfPointer$handle() {
        return LLVMCreateGenericValueOfPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfPointer(void *P)
     * }
     */
    public static MemorySegment LLVMCreateGenericValueOfPointer$address() {
        return LLVMCreateGenericValueOfPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfPointer(void *P)
     * }
     */
    public static MemorySegment LLVMCreateGenericValueOfPointer(MemorySegment P) {
        var mh$ = LLVMCreateGenericValueOfPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateGenericValueOfPointer", P);
            }
            return (MemorySegment)mh$.invokeExact(P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateGenericValueOfFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_DOUBLE
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateGenericValueOfFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfFloat(LLVMTypeRef Ty, double N)
     * }
     */
    public static FunctionDescriptor LLVMCreateGenericValueOfFloat$descriptor() {
        return LLVMCreateGenericValueOfFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfFloat(LLVMTypeRef Ty, double N)
     * }
     */
    public static MethodHandle LLVMCreateGenericValueOfFloat$handle() {
        return LLVMCreateGenericValueOfFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfFloat(LLVMTypeRef Ty, double N)
     * }
     */
    public static MemorySegment LLVMCreateGenericValueOfFloat$address() {
        return LLVMCreateGenericValueOfFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMCreateGenericValueOfFloat(LLVMTypeRef Ty, double N)
     * }
     */
    public static MemorySegment LLVMCreateGenericValueOfFloat(MemorySegment Ty, double N) {
        var mh$ = LLVMCreateGenericValueOfFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateGenericValueOfFloat", Ty, N);
            }
            return (MemorySegment)mh$.invokeExact(Ty, N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGenericValueIntWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGenericValueIntWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGenericValueIntWidth(LLVMGenericValueRef GenValRef)
     * }
     */
    public static FunctionDescriptor LLVMGenericValueIntWidth$descriptor() {
        return LLVMGenericValueIntWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGenericValueIntWidth(LLVMGenericValueRef GenValRef)
     * }
     */
    public static MethodHandle LLVMGenericValueIntWidth$handle() {
        return LLVMGenericValueIntWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGenericValueIntWidth(LLVMGenericValueRef GenValRef)
     * }
     */
    public static MemorySegment LLVMGenericValueIntWidth$address() {
        return LLVMGenericValueIntWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGenericValueIntWidth(LLVMGenericValueRef GenValRef)
     * }
     */
    public static int LLVMGenericValueIntWidth(MemorySegment GenValRef) {
        var mh$ = LLVMGenericValueIntWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGenericValueIntWidth", GenValRef);
            }
            return (int)mh$.invokeExact(GenValRef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGenericValueToInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG_LONG,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGenericValueToInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long LLVMGenericValueToInt(LLVMGenericValueRef GenVal, LLVMBool IsSigned)
     * }
     */
    public static FunctionDescriptor LLVMGenericValueToInt$descriptor() {
        return LLVMGenericValueToInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long LLVMGenericValueToInt(LLVMGenericValueRef GenVal, LLVMBool IsSigned)
     * }
     */
    public static MethodHandle LLVMGenericValueToInt$handle() {
        return LLVMGenericValueToInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long LLVMGenericValueToInt(LLVMGenericValueRef GenVal, LLVMBool IsSigned)
     * }
     */
    public static MemorySegment LLVMGenericValueToInt$address() {
        return LLVMGenericValueToInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long LLVMGenericValueToInt(LLVMGenericValueRef GenVal, LLVMBool IsSigned)
     * }
     */
    public static long LLVMGenericValueToInt(MemorySegment GenVal, int IsSigned) {
        var mh$ = LLVMGenericValueToInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGenericValueToInt", GenVal, IsSigned);
            }
            return (long)mh$.invokeExact(GenVal, IsSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGenericValueToPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGenericValueToPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *LLVMGenericValueToPointer(LLVMGenericValueRef GenVal)
     * }
     */
    public static FunctionDescriptor LLVMGenericValueToPointer$descriptor() {
        return LLVMGenericValueToPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *LLVMGenericValueToPointer(LLVMGenericValueRef GenVal)
     * }
     */
    public static MethodHandle LLVMGenericValueToPointer$handle() {
        return LLVMGenericValueToPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *LLVMGenericValueToPointer(LLVMGenericValueRef GenVal)
     * }
     */
    public static MemorySegment LLVMGenericValueToPointer$address() {
        return LLVMGenericValueToPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *LLVMGenericValueToPointer(LLVMGenericValueRef GenVal)
     * }
     */
    public static MemorySegment LLVMGenericValueToPointer(MemorySegment GenVal) {
        var mh$ = LLVMGenericValueToPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGenericValueToPointer", GenVal);
            }
            return (MemorySegment)mh$.invokeExact(GenVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGenericValueToFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_DOUBLE,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGenericValueToFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LLVMGenericValueToFloat(LLVMTypeRef TyRef, LLVMGenericValueRef GenVal)
     * }
     */
    public static FunctionDescriptor LLVMGenericValueToFloat$descriptor() {
        return LLVMGenericValueToFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LLVMGenericValueToFloat(LLVMTypeRef TyRef, LLVMGenericValueRef GenVal)
     * }
     */
    public static MethodHandle LLVMGenericValueToFloat$handle() {
        return LLVMGenericValueToFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LLVMGenericValueToFloat(LLVMTypeRef TyRef, LLVMGenericValueRef GenVal)
     * }
     */
    public static MemorySegment LLVMGenericValueToFloat$address() {
        return LLVMGenericValueToFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LLVMGenericValueToFloat(LLVMTypeRef TyRef, LLVMGenericValueRef GenVal)
     * }
     */
    public static double LLVMGenericValueToFloat(MemorySegment TyRef, MemorySegment GenVal) {
        var mh$ = LLVMGenericValueToFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGenericValueToFloat", TyRef, GenVal);
            }
            return (double)mh$.invokeExact(TyRef, GenVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeGenericValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeGenericValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeGenericValue(LLVMGenericValueRef GenVal)
     * }
     */
    public static FunctionDescriptor LLVMDisposeGenericValue$descriptor() {
        return LLVMDisposeGenericValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeGenericValue(LLVMGenericValueRef GenVal)
     * }
     */
    public static MethodHandle LLVMDisposeGenericValue$handle() {
        return LLVMDisposeGenericValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeGenericValue(LLVMGenericValueRef GenVal)
     * }
     */
    public static MemorySegment LLVMDisposeGenericValue$address() {
        return LLVMDisposeGenericValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeGenericValue(LLVMGenericValueRef GenVal)
     * }
     */
    public static void LLVMDisposeGenericValue(MemorySegment GenVal) {
        var mh$ = LLVMDisposeGenericValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeGenericValue", GenVal);
            }
            mh$.invokeExact(GenVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateExecutionEngineForModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateExecutionEngineForModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateExecutionEngineForModule(LLVMExecutionEngineRef *OutEE, LLVMModuleRef M, char **OutError)
     * }
     */
    public static FunctionDescriptor LLVMCreateExecutionEngineForModule$descriptor() {
        return LLVMCreateExecutionEngineForModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateExecutionEngineForModule(LLVMExecutionEngineRef *OutEE, LLVMModuleRef M, char **OutError)
     * }
     */
    public static MethodHandle LLVMCreateExecutionEngineForModule$handle() {
        return LLVMCreateExecutionEngineForModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateExecutionEngineForModule(LLVMExecutionEngineRef *OutEE, LLVMModuleRef M, char **OutError)
     * }
     */
    public static MemorySegment LLVMCreateExecutionEngineForModule$address() {
        return LLVMCreateExecutionEngineForModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCreateExecutionEngineForModule(LLVMExecutionEngineRef *OutEE, LLVMModuleRef M, char **OutError)
     * }
     */
    public static int LLVMCreateExecutionEngineForModule(MemorySegment OutEE, MemorySegment M, MemorySegment OutError) {
        var mh$ = LLVMCreateExecutionEngineForModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateExecutionEngineForModule", OutEE, M, OutError);
            }
            return (int)mh$.invokeExact(OutEE, M, OutError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateInterpreterForModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateInterpreterForModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateInterpreterForModule(LLVMExecutionEngineRef *OutInterp, LLVMModuleRef M, char **OutError)
     * }
     */
    public static FunctionDescriptor LLVMCreateInterpreterForModule$descriptor() {
        return LLVMCreateInterpreterForModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateInterpreterForModule(LLVMExecutionEngineRef *OutInterp, LLVMModuleRef M, char **OutError)
     * }
     */
    public static MethodHandle LLVMCreateInterpreterForModule$handle() {
        return LLVMCreateInterpreterForModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateInterpreterForModule(LLVMExecutionEngineRef *OutInterp, LLVMModuleRef M, char **OutError)
     * }
     */
    public static MemorySegment LLVMCreateInterpreterForModule$address() {
        return LLVMCreateInterpreterForModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCreateInterpreterForModule(LLVMExecutionEngineRef *OutInterp, LLVMModuleRef M, char **OutError)
     * }
     */
    public static int LLVMCreateInterpreterForModule(MemorySegment OutInterp, MemorySegment M, MemorySegment OutError) {
        var mh$ = LLVMCreateInterpreterForModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateInterpreterForModule", OutInterp, M, OutError);
            }
            return (int)mh$.invokeExact(OutInterp, M, OutError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateJITCompilerForModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateJITCompilerForModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateJITCompilerForModule(LLVMExecutionEngineRef *OutJIT, LLVMModuleRef M, unsigned int OptLevel, char **OutError)
     * }
     */
    public static FunctionDescriptor LLVMCreateJITCompilerForModule$descriptor() {
        return LLVMCreateJITCompilerForModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateJITCompilerForModule(LLVMExecutionEngineRef *OutJIT, LLVMModuleRef M, unsigned int OptLevel, char **OutError)
     * }
     */
    public static MethodHandle LLVMCreateJITCompilerForModule$handle() {
        return LLVMCreateJITCompilerForModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateJITCompilerForModule(LLVMExecutionEngineRef *OutJIT, LLVMModuleRef M, unsigned int OptLevel, char **OutError)
     * }
     */
    public static MemorySegment LLVMCreateJITCompilerForModule$address() {
        return LLVMCreateJITCompilerForModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCreateJITCompilerForModule(LLVMExecutionEngineRef *OutJIT, LLVMModuleRef M, unsigned int OptLevel, char **OutError)
     * }
     */
    public static int LLVMCreateJITCompilerForModule(MemorySegment OutJIT, MemorySegment M, int OptLevel, MemorySegment OutError) {
        var mh$ = LLVMCreateJITCompilerForModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateJITCompilerForModule", OutJIT, M, OptLevel, OutError);
            }
            return (int)mh$.invokeExact(OutJIT, M, OptLevel, OutError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeMCJITCompilerOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeMCJITCompilerOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInitializeMCJITCompilerOptions(struct LLVMMCJITCompilerOptions *Options, size_t SizeOfOptions)
     * }
     */
    public static FunctionDescriptor LLVMInitializeMCJITCompilerOptions$descriptor() {
        return LLVMInitializeMCJITCompilerOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInitializeMCJITCompilerOptions(struct LLVMMCJITCompilerOptions *Options, size_t SizeOfOptions)
     * }
     */
    public static MethodHandle LLVMInitializeMCJITCompilerOptions$handle() {
        return LLVMInitializeMCJITCompilerOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInitializeMCJITCompilerOptions(struct LLVMMCJITCompilerOptions *Options, size_t SizeOfOptions)
     * }
     */
    public static MemorySegment LLVMInitializeMCJITCompilerOptions$address() {
        return LLVMInitializeMCJITCompilerOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInitializeMCJITCompilerOptions(struct LLVMMCJITCompilerOptions *Options, size_t SizeOfOptions)
     * }
     */
    public static void LLVMInitializeMCJITCompilerOptions(MemorySegment Options, long SizeOfOptions) {
        var mh$ = LLVMInitializeMCJITCompilerOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeMCJITCompilerOptions", Options, SizeOfOptions);
            }
            mh$.invokeExact(Options, SizeOfOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMCJITCompilerForModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMCJITCompilerForModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMCJITCompilerForModule(LLVMExecutionEngineRef *OutJIT, LLVMModuleRef M, struct LLVMMCJITCompilerOptions *Options, size_t SizeOfOptions, char **OutError)
     * }
     */
    public static FunctionDescriptor LLVMCreateMCJITCompilerForModule$descriptor() {
        return LLVMCreateMCJITCompilerForModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMCJITCompilerForModule(LLVMExecutionEngineRef *OutJIT, LLVMModuleRef M, struct LLVMMCJITCompilerOptions *Options, size_t SizeOfOptions, char **OutError)
     * }
     */
    public static MethodHandle LLVMCreateMCJITCompilerForModule$handle() {
        return LLVMCreateMCJITCompilerForModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMCJITCompilerForModule(LLVMExecutionEngineRef *OutJIT, LLVMModuleRef M, struct LLVMMCJITCompilerOptions *Options, size_t SizeOfOptions, char **OutError)
     * }
     */
    public static MemorySegment LLVMCreateMCJITCompilerForModule$address() {
        return LLVMCreateMCJITCompilerForModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMCJITCompilerForModule(LLVMExecutionEngineRef *OutJIT, LLVMModuleRef M, struct LLVMMCJITCompilerOptions *Options, size_t SizeOfOptions, char **OutError)
     * }
     */
    public static int LLVMCreateMCJITCompilerForModule(MemorySegment OutJIT, MemorySegment M, MemorySegment Options, long SizeOfOptions, MemorySegment OutError) {
        var mh$ = LLVMCreateMCJITCompilerForModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMCJITCompilerForModule", OutJIT, M, Options, SizeOfOptions, OutError);
            }
            return (int)mh$.invokeExact(OutJIT, M, Options, SizeOfOptions, OutError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeExecutionEngine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeExecutionEngine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeExecutionEngine(LLVMExecutionEngineRef EE)
     * }
     */
    public static FunctionDescriptor LLVMDisposeExecutionEngine$descriptor() {
        return LLVMDisposeExecutionEngine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeExecutionEngine(LLVMExecutionEngineRef EE)
     * }
     */
    public static MethodHandle LLVMDisposeExecutionEngine$handle() {
        return LLVMDisposeExecutionEngine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeExecutionEngine(LLVMExecutionEngineRef EE)
     * }
     */
    public static MemorySegment LLVMDisposeExecutionEngine$address() {
        return LLVMDisposeExecutionEngine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeExecutionEngine(LLVMExecutionEngineRef EE)
     * }
     */
    public static void LLVMDisposeExecutionEngine(MemorySegment EE) {
        var mh$ = LLVMDisposeExecutionEngine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeExecutionEngine", EE);
            }
            mh$.invokeExact(EE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRunStaticConstructors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRunStaticConstructors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRunStaticConstructors(LLVMExecutionEngineRef EE)
     * }
     */
    public static FunctionDescriptor LLVMRunStaticConstructors$descriptor() {
        return LLVMRunStaticConstructors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRunStaticConstructors(LLVMExecutionEngineRef EE)
     * }
     */
    public static MethodHandle LLVMRunStaticConstructors$handle() {
        return LLVMRunStaticConstructors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRunStaticConstructors(LLVMExecutionEngineRef EE)
     * }
     */
    public static MemorySegment LLVMRunStaticConstructors$address() {
        return LLVMRunStaticConstructors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRunStaticConstructors(LLVMExecutionEngineRef EE)
     * }
     */
    public static void LLVMRunStaticConstructors(MemorySegment EE) {
        var mh$ = LLVMRunStaticConstructors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRunStaticConstructors", EE);
            }
            mh$.invokeExact(EE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRunStaticDestructors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRunStaticDestructors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRunStaticDestructors(LLVMExecutionEngineRef EE)
     * }
     */
    public static FunctionDescriptor LLVMRunStaticDestructors$descriptor() {
        return LLVMRunStaticDestructors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRunStaticDestructors(LLVMExecutionEngineRef EE)
     * }
     */
    public static MethodHandle LLVMRunStaticDestructors$handle() {
        return LLVMRunStaticDestructors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRunStaticDestructors(LLVMExecutionEngineRef EE)
     * }
     */
    public static MemorySegment LLVMRunStaticDestructors$address() {
        return LLVMRunStaticDestructors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRunStaticDestructors(LLVMExecutionEngineRef EE)
     * }
     */
    public static void LLVMRunStaticDestructors(MemorySegment EE) {
        var mh$ = LLVMRunStaticDestructors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRunStaticDestructors", EE);
            }
            mh$.invokeExact(EE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRunFunctionAsMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRunFunctionAsMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LLVMRunFunctionAsMain(LLVMExecutionEngineRef EE, LLVMValueRef F, unsigned int ArgC, const char *const *ArgV, const char *const *EnvP)
     * }
     */
    public static FunctionDescriptor LLVMRunFunctionAsMain$descriptor() {
        return LLVMRunFunctionAsMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LLVMRunFunctionAsMain(LLVMExecutionEngineRef EE, LLVMValueRef F, unsigned int ArgC, const char *const *ArgV, const char *const *EnvP)
     * }
     */
    public static MethodHandle LLVMRunFunctionAsMain$handle() {
        return LLVMRunFunctionAsMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LLVMRunFunctionAsMain(LLVMExecutionEngineRef EE, LLVMValueRef F, unsigned int ArgC, const char *const *ArgV, const char *const *EnvP)
     * }
     */
    public static MemorySegment LLVMRunFunctionAsMain$address() {
        return LLVMRunFunctionAsMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LLVMRunFunctionAsMain(LLVMExecutionEngineRef EE, LLVMValueRef F, unsigned int ArgC, const char *const *ArgV, const char *const *EnvP)
     * }
     */
    public static int LLVMRunFunctionAsMain(MemorySegment EE, MemorySegment F, int ArgC, MemorySegment ArgV, MemorySegment EnvP) {
        var mh$ = LLVMRunFunctionAsMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRunFunctionAsMain", EE, F, ArgC, ArgV, EnvP);
            }
            return (int)mh$.invokeExact(EE, F, ArgC, ArgV, EnvP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRunFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRunFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMRunFunction(LLVMExecutionEngineRef EE, LLVMValueRef F, unsigned int NumArgs, LLVMGenericValueRef *Args)
     * }
     */
    public static FunctionDescriptor LLVMRunFunction$descriptor() {
        return LLVMRunFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMRunFunction(LLVMExecutionEngineRef EE, LLVMValueRef F, unsigned int NumArgs, LLVMGenericValueRef *Args)
     * }
     */
    public static MethodHandle LLVMRunFunction$handle() {
        return LLVMRunFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMRunFunction(LLVMExecutionEngineRef EE, LLVMValueRef F, unsigned int NumArgs, LLVMGenericValueRef *Args)
     * }
     */
    public static MemorySegment LLVMRunFunction$address() {
        return LLVMRunFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMGenericValueRef LLVMRunFunction(LLVMExecutionEngineRef EE, LLVMValueRef F, unsigned int NumArgs, LLVMGenericValueRef *Args)
     * }
     */
    public static MemorySegment LLVMRunFunction(MemorySegment EE, MemorySegment F, int NumArgs, MemorySegment Args) {
        var mh$ = LLVMRunFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRunFunction", EE, F, NumArgs, Args);
            }
            return (MemorySegment)mh$.invokeExact(EE, F, NumArgs, Args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFreeMachineCodeForFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFreeMachineCodeForFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMFreeMachineCodeForFunction(LLVMExecutionEngineRef EE, LLVMValueRef F)
     * }
     */
    public static FunctionDescriptor LLVMFreeMachineCodeForFunction$descriptor() {
        return LLVMFreeMachineCodeForFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMFreeMachineCodeForFunction(LLVMExecutionEngineRef EE, LLVMValueRef F)
     * }
     */
    public static MethodHandle LLVMFreeMachineCodeForFunction$handle() {
        return LLVMFreeMachineCodeForFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMFreeMachineCodeForFunction(LLVMExecutionEngineRef EE, LLVMValueRef F)
     * }
     */
    public static MemorySegment LLVMFreeMachineCodeForFunction$address() {
        return LLVMFreeMachineCodeForFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMFreeMachineCodeForFunction(LLVMExecutionEngineRef EE, LLVMValueRef F)
     * }
     */
    public static void LLVMFreeMachineCodeForFunction(MemorySegment EE, MemorySegment F) {
        var mh$ = LLVMFreeMachineCodeForFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFreeMachineCodeForFunction", EE, F);
            }
            mh$.invokeExact(EE, F);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddModule(LLVMExecutionEngineRef EE, LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMAddModule$descriptor() {
        return LLVMAddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddModule(LLVMExecutionEngineRef EE, LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMAddModule$handle() {
        return LLVMAddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddModule(LLVMExecutionEngineRef EE, LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMAddModule$address() {
        return LLVMAddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddModule(LLVMExecutionEngineRef EE, LLVMModuleRef M)
     * }
     */
    public static void LLVMAddModule(MemorySegment EE, MemorySegment M) {
        var mh$ = LLVMAddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddModule", EE, M);
            }
            mh$.invokeExact(EE, M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMRemoveModule(LLVMExecutionEngineRef EE, LLVMModuleRef M, LLVMModuleRef *OutMod, char **OutError)
     * }
     */
    public static FunctionDescriptor LLVMRemoveModule$descriptor() {
        return LLVMRemoveModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMRemoveModule(LLVMExecutionEngineRef EE, LLVMModuleRef M, LLVMModuleRef *OutMod, char **OutError)
     * }
     */
    public static MethodHandle LLVMRemoveModule$handle() {
        return LLVMRemoveModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMRemoveModule(LLVMExecutionEngineRef EE, LLVMModuleRef M, LLVMModuleRef *OutMod, char **OutError)
     * }
     */
    public static MemorySegment LLVMRemoveModule$address() {
        return LLVMRemoveModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMRemoveModule(LLVMExecutionEngineRef EE, LLVMModuleRef M, LLVMModuleRef *OutMod, char **OutError)
     * }
     */
    public static int LLVMRemoveModule(MemorySegment EE, MemorySegment M, MemorySegment OutMod, MemorySegment OutError) {
        var mh$ = LLVMRemoveModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveModule", EE, M, OutMod, OutError);
            }
            return (int)mh$.invokeExact(EE, M, OutMod, OutError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFindFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFindFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMFindFunction(LLVMExecutionEngineRef EE, const char *Name, LLVMValueRef *OutFn)
     * }
     */
    public static FunctionDescriptor LLVMFindFunction$descriptor() {
        return LLVMFindFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMFindFunction(LLVMExecutionEngineRef EE, const char *Name, LLVMValueRef *OutFn)
     * }
     */
    public static MethodHandle LLVMFindFunction$handle() {
        return LLVMFindFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMFindFunction(LLVMExecutionEngineRef EE, const char *Name, LLVMValueRef *OutFn)
     * }
     */
    public static MemorySegment LLVMFindFunction$address() {
        return LLVMFindFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMFindFunction(LLVMExecutionEngineRef EE, const char *Name, LLVMValueRef *OutFn)
     * }
     */
    public static int LLVMFindFunction(MemorySegment EE, MemorySegment Name, MemorySegment OutFn) {
        var mh$ = LLVMFindFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFindFunction", EE, Name, OutFn);
            }
            return (int)mh$.invokeExact(EE, Name, OutFn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRecompileAndRelinkFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRecompileAndRelinkFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *LLVMRecompileAndRelinkFunction(LLVMExecutionEngineRef EE, LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMRecompileAndRelinkFunction$descriptor() {
        return LLVMRecompileAndRelinkFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *LLVMRecompileAndRelinkFunction(LLVMExecutionEngineRef EE, LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMRecompileAndRelinkFunction$handle() {
        return LLVMRecompileAndRelinkFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *LLVMRecompileAndRelinkFunction(LLVMExecutionEngineRef EE, LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMRecompileAndRelinkFunction$address() {
        return LLVMRecompileAndRelinkFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *LLVMRecompileAndRelinkFunction(LLVMExecutionEngineRef EE, LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMRecompileAndRelinkFunction(MemorySegment EE, MemorySegment Fn) {
        var mh$ = LLVMRecompileAndRelinkFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRecompileAndRelinkFunction", EE, Fn);
            }
            return (MemorySegment)mh$.invokeExact(EE, Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetExecutionEngineTargetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetExecutionEngineTargetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMGetExecutionEngineTargetData(LLVMExecutionEngineRef EE)
     * }
     */
    public static FunctionDescriptor LLVMGetExecutionEngineTargetData$descriptor() {
        return LLVMGetExecutionEngineTargetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMGetExecutionEngineTargetData(LLVMExecutionEngineRef EE)
     * }
     */
    public static MethodHandle LLVMGetExecutionEngineTargetData$handle() {
        return LLVMGetExecutionEngineTargetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMGetExecutionEngineTargetData(LLVMExecutionEngineRef EE)
     * }
     */
    public static MemorySegment LLVMGetExecutionEngineTargetData$address() {
        return LLVMGetExecutionEngineTargetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetDataRef LLVMGetExecutionEngineTargetData(LLVMExecutionEngineRef EE)
     * }
     */
    public static MemorySegment LLVMGetExecutionEngineTargetData(MemorySegment EE) {
        var mh$ = LLVMGetExecutionEngineTargetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetExecutionEngineTargetData", EE);
            }
            return (MemorySegment)mh$.invokeExact(EE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetExecutionEngineTargetMachine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetExecutionEngineTargetMachine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMGetExecutionEngineTargetMachine(LLVMExecutionEngineRef EE)
     * }
     */
    public static FunctionDescriptor LLVMGetExecutionEngineTargetMachine$descriptor() {
        return LLVMGetExecutionEngineTargetMachine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMGetExecutionEngineTargetMachine(LLVMExecutionEngineRef EE)
     * }
     */
    public static MethodHandle LLVMGetExecutionEngineTargetMachine$handle() {
        return LLVMGetExecutionEngineTargetMachine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMGetExecutionEngineTargetMachine(LLVMExecutionEngineRef EE)
     * }
     */
    public static MemorySegment LLVMGetExecutionEngineTargetMachine$address() {
        return LLVMGetExecutionEngineTargetMachine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTargetMachineRef LLVMGetExecutionEngineTargetMachine(LLVMExecutionEngineRef EE)
     * }
     */
    public static MemorySegment LLVMGetExecutionEngineTargetMachine(MemorySegment EE) {
        var mh$ = LLVMGetExecutionEngineTargetMachine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetExecutionEngineTargetMachine", EE);
            }
            return (MemorySegment)mh$.invokeExact(EE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddGlobalMapping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddGlobalMapping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddGlobalMapping(LLVMExecutionEngineRef EE, LLVMValueRef Global, void *Addr)
     * }
     */
    public static FunctionDescriptor LLVMAddGlobalMapping$descriptor() {
        return LLVMAddGlobalMapping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddGlobalMapping(LLVMExecutionEngineRef EE, LLVMValueRef Global, void *Addr)
     * }
     */
    public static MethodHandle LLVMAddGlobalMapping$handle() {
        return LLVMAddGlobalMapping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddGlobalMapping(LLVMExecutionEngineRef EE, LLVMValueRef Global, void *Addr)
     * }
     */
    public static MemorySegment LLVMAddGlobalMapping$address() {
        return LLVMAddGlobalMapping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddGlobalMapping(LLVMExecutionEngineRef EE, LLVMValueRef Global, void *Addr)
     * }
     */
    public static void LLVMAddGlobalMapping(MemorySegment EE, MemorySegment Global, MemorySegment Addr) {
        var mh$ = LLVMAddGlobalMapping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddGlobalMapping", EE, Global, Addr);
            }
            mh$.invokeExact(EE, Global, Addr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPointerToGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPointerToGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *LLVMGetPointerToGlobal(LLVMExecutionEngineRef EE, LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGetPointerToGlobal$descriptor() {
        return LLVMGetPointerToGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *LLVMGetPointerToGlobal(LLVMExecutionEngineRef EE, LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGetPointerToGlobal$handle() {
        return LLVMGetPointerToGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *LLVMGetPointerToGlobal(LLVMExecutionEngineRef EE, LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetPointerToGlobal$address() {
        return LLVMGetPointerToGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *LLVMGetPointerToGlobal(LLVMExecutionEngineRef EE, LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetPointerToGlobal(MemorySegment EE, MemorySegment Global) {
        var mh$ = LLVMGetPointerToGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPointerToGlobal", EE, Global);
            }
            return (MemorySegment)mh$.invokeExact(EE, Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetGlobalValueAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetGlobalValueAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t LLVMGetGlobalValueAddress(LLVMExecutionEngineRef EE, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMGetGlobalValueAddress$descriptor() {
        return LLVMGetGlobalValueAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t LLVMGetGlobalValueAddress(LLVMExecutionEngineRef EE, const char *Name)
     * }
     */
    public static MethodHandle LLVMGetGlobalValueAddress$handle() {
        return LLVMGetGlobalValueAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t LLVMGetGlobalValueAddress(LLVMExecutionEngineRef EE, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetGlobalValueAddress$address() {
        return LLVMGetGlobalValueAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t LLVMGetGlobalValueAddress(LLVMExecutionEngineRef EE, const char *Name)
     * }
     */
    public static long LLVMGetGlobalValueAddress(MemorySegment EE, MemorySegment Name) {
        var mh$ = LLVMGetGlobalValueAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetGlobalValueAddress", EE, Name);
            }
            return (long)mh$.invokeExact(EE, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t LLVMGetFunctionAddress(LLVMExecutionEngineRef EE, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMGetFunctionAddress$descriptor() {
        return LLVMGetFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t LLVMGetFunctionAddress(LLVMExecutionEngineRef EE, const char *Name)
     * }
     */
    public static MethodHandle LLVMGetFunctionAddress$handle() {
        return LLVMGetFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t LLVMGetFunctionAddress(LLVMExecutionEngineRef EE, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetFunctionAddress$address() {
        return LLVMGetFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t LLVMGetFunctionAddress(LLVMExecutionEngineRef EE, const char *Name)
     * }
     */
    public static long LLVMGetFunctionAddress(MemorySegment EE, MemorySegment Name) {
        var mh$ = LLVMGetFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFunctionAddress", EE, Name);
            }
            return (long)mh$.invokeExact(EE, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMExecutionEngineGetErrMsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMExecutionEngineGetErrMsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMExecutionEngineGetErrMsg(LLVMExecutionEngineRef EE, char **OutError)
     * }
     */
    public static FunctionDescriptor LLVMExecutionEngineGetErrMsg$descriptor() {
        return LLVMExecutionEngineGetErrMsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMExecutionEngineGetErrMsg(LLVMExecutionEngineRef EE, char **OutError)
     * }
     */
    public static MethodHandle LLVMExecutionEngineGetErrMsg$handle() {
        return LLVMExecutionEngineGetErrMsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMExecutionEngineGetErrMsg(LLVMExecutionEngineRef EE, char **OutError)
     * }
     */
    public static MemorySegment LLVMExecutionEngineGetErrMsg$address() {
        return LLVMExecutionEngineGetErrMsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMExecutionEngineGetErrMsg(LLVMExecutionEngineRef EE, char **OutError)
     * }
     */
    public static int LLVMExecutionEngineGetErrMsg(MemorySegment EE, MemorySegment OutError) {
        var mh$ = LLVMExecutionEngineGetErrMsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMExecutionEngineGetErrMsg", EE, OutError);
            }
            return (int)mh$.invokeExact(EE, OutError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateSimpleMCJITMemoryManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateSimpleMCJITMemoryManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMCJITMemoryManagerRef LLVMCreateSimpleMCJITMemoryManager(void *Opaque, LLVMMemoryManagerAllocateCodeSectionCallback AllocateCodeSection, LLVMMemoryManagerAllocateDataSectionCallback AllocateDataSection, LLVMMemoryManagerFinalizeMemoryCallback FinalizeMemory, LLVMMemoryManagerDestroyCallback Destroy)
     * }
     */
    public static FunctionDescriptor LLVMCreateSimpleMCJITMemoryManager$descriptor() {
        return LLVMCreateSimpleMCJITMemoryManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMCJITMemoryManagerRef LLVMCreateSimpleMCJITMemoryManager(void *Opaque, LLVMMemoryManagerAllocateCodeSectionCallback AllocateCodeSection, LLVMMemoryManagerAllocateDataSectionCallback AllocateDataSection, LLVMMemoryManagerFinalizeMemoryCallback FinalizeMemory, LLVMMemoryManagerDestroyCallback Destroy)
     * }
     */
    public static MethodHandle LLVMCreateSimpleMCJITMemoryManager$handle() {
        return LLVMCreateSimpleMCJITMemoryManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMCJITMemoryManagerRef LLVMCreateSimpleMCJITMemoryManager(void *Opaque, LLVMMemoryManagerAllocateCodeSectionCallback AllocateCodeSection, LLVMMemoryManagerAllocateDataSectionCallback AllocateDataSection, LLVMMemoryManagerFinalizeMemoryCallback FinalizeMemory, LLVMMemoryManagerDestroyCallback Destroy)
     * }
     */
    public static MemorySegment LLVMCreateSimpleMCJITMemoryManager$address() {
        return LLVMCreateSimpleMCJITMemoryManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMCJITMemoryManagerRef LLVMCreateSimpleMCJITMemoryManager(void *Opaque, LLVMMemoryManagerAllocateCodeSectionCallback AllocateCodeSection, LLVMMemoryManagerAllocateDataSectionCallback AllocateDataSection, LLVMMemoryManagerFinalizeMemoryCallback FinalizeMemory, LLVMMemoryManagerDestroyCallback Destroy)
     * }
     */
    public static MemorySegment LLVMCreateSimpleMCJITMemoryManager(MemorySegment Opaque, MemorySegment AllocateCodeSection, MemorySegment AllocateDataSection, MemorySegment FinalizeMemory, MemorySegment Destroy) {
        var mh$ = LLVMCreateSimpleMCJITMemoryManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateSimpleMCJITMemoryManager", Opaque, AllocateCodeSection, AllocateDataSection, FinalizeMemory, Destroy);
            }
            return (MemorySegment)mh$.invokeExact(Opaque, AllocateCodeSection, AllocateDataSection, FinalizeMemory, Destroy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeMCJITMemoryManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeMCJITMemoryManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeMCJITMemoryManager(LLVMMCJITMemoryManagerRef MM)
     * }
     */
    public static FunctionDescriptor LLVMDisposeMCJITMemoryManager$descriptor() {
        return LLVMDisposeMCJITMemoryManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeMCJITMemoryManager(LLVMMCJITMemoryManagerRef MM)
     * }
     */
    public static MethodHandle LLVMDisposeMCJITMemoryManager$handle() {
        return LLVMDisposeMCJITMemoryManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeMCJITMemoryManager(LLVMMCJITMemoryManagerRef MM)
     * }
     */
    public static MemorySegment LLVMDisposeMCJITMemoryManager$address() {
        return LLVMDisposeMCJITMemoryManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeMCJITMemoryManager(LLVMMCJITMemoryManagerRef MM)
     * }
     */
    public static void LLVMDisposeMCJITMemoryManager(MemorySegment MM) {
        var mh$ = LLVMDisposeMCJITMemoryManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeMCJITMemoryManager", MM);
            }
            mh$.invokeExact(MM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateGDBRegistrationListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateGDBRegistrationListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateGDBRegistrationListener()
     * }
     */
    public static FunctionDescriptor LLVMCreateGDBRegistrationListener$descriptor() {
        return LLVMCreateGDBRegistrationListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateGDBRegistrationListener()
     * }
     */
    public static MethodHandle LLVMCreateGDBRegistrationListener$handle() {
        return LLVMCreateGDBRegistrationListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateGDBRegistrationListener()
     * }
     */
    public static MemorySegment LLVMCreateGDBRegistrationListener$address() {
        return LLVMCreateGDBRegistrationListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateGDBRegistrationListener()
     * }
     */
    public static MemorySegment LLVMCreateGDBRegistrationListener() {
        var mh$ = LLVMCreateGDBRegistrationListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateGDBRegistrationListener");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateIntelJITEventListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateIntelJITEventListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateIntelJITEventListener()
     * }
     */
    public static FunctionDescriptor LLVMCreateIntelJITEventListener$descriptor() {
        return LLVMCreateIntelJITEventListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateIntelJITEventListener()
     * }
     */
    public static MethodHandle LLVMCreateIntelJITEventListener$handle() {
        return LLVMCreateIntelJITEventListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateIntelJITEventListener()
     * }
     */
    public static MemorySegment LLVMCreateIntelJITEventListener$address() {
        return LLVMCreateIntelJITEventListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateIntelJITEventListener()
     * }
     */
    public static MemorySegment LLVMCreateIntelJITEventListener() {
        var mh$ = LLVMCreateIntelJITEventListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateIntelJITEventListener");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateOProfileJITEventListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateOProfileJITEventListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateOProfileJITEventListener()
     * }
     */
    public static FunctionDescriptor LLVMCreateOProfileJITEventListener$descriptor() {
        return LLVMCreateOProfileJITEventListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateOProfileJITEventListener()
     * }
     */
    public static MethodHandle LLVMCreateOProfileJITEventListener$handle() {
        return LLVMCreateOProfileJITEventListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateOProfileJITEventListener()
     * }
     */
    public static MemorySegment LLVMCreateOProfileJITEventListener$address() {
        return LLVMCreateOProfileJITEventListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreateOProfileJITEventListener()
     * }
     */
    public static MemorySegment LLVMCreateOProfileJITEventListener() {
        var mh$ = LLVMCreateOProfileJITEventListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateOProfileJITEventListener");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreatePerfJITEventListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreatePerfJITEventListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreatePerfJITEventListener()
     * }
     */
    public static FunctionDescriptor LLVMCreatePerfJITEventListener$descriptor() {
        return LLVMCreatePerfJITEventListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreatePerfJITEventListener()
     * }
     */
    public static MethodHandle LLVMCreatePerfJITEventListener$handle() {
        return LLVMCreatePerfJITEventListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreatePerfJITEventListener()
     * }
     */
    public static MemorySegment LLVMCreatePerfJITEventListener$address() {
        return LLVMCreatePerfJITEventListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMJITEventListenerRef LLVMCreatePerfJITEventListener()
     * }
     */
    public static MemorySegment LLVMCreatePerfJITEventListener() {
        var mh$ = LLVMCreatePerfJITEventListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreatePerfJITEventListener");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI64_PREFIX "l"
     * }
     */
    public static MemorySegment __PRI64_PREFIX() {
        class Holder {
            static final MemorySegment __PRI64_PREFIX
                = LLVM.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRI64_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRIPTR_PREFIX "l"
     * }
     */
    public static MemorySegment __PRIPTR_PREFIX() {
        class Holder {
            static final MemorySegment __PRIPTR_PREFIX
                = LLVM.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRIPTR_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "d"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "d"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "ld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "d"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "d"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "ld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "d"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "ld"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "ld"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "ld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "i"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "i"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi32 "i"
     * }
     */
    public static MemorySegment PRIi32() {
        class Holder {
            static final MemorySegment PRIi32
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi64 "li"
     * }
     */
    public static MemorySegment PRIi64() {
        class Holder {
            static final MemorySegment PRIi64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIi64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST8 "i"
     * }
     */
    public static MemorySegment PRIiLEAST8() {
        class Holder {
            static final MemorySegment PRIiLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST16 "i"
     * }
     */
    public static MemorySegment PRIiLEAST16() {
        class Holder {
            static final MemorySegment PRIiLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST32 "i"
     * }
     */
    public static MemorySegment PRIiLEAST32() {
        class Holder {
            static final MemorySegment PRIiLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST64 "li"
     * }
     */
    public static MemorySegment PRIiLEAST64() {
        class Holder {
            static final MemorySegment PRIiLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST8 "i"
     * }
     */
    public static MemorySegment PRIiFAST8() {
        class Holder {
            static final MemorySegment PRIiFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST16 "li"
     * }
     */
    public static MemorySegment PRIiFAST16() {
        class Holder {
            static final MemorySegment PRIiFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST32 "li"
     * }
     */
    public static MemorySegment PRIiFAST32() {
        class Holder {
            static final MemorySegment PRIiFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST64 "li"
     * }
     */
    public static MemorySegment PRIiFAST64() {
        class Holder {
            static final MemorySegment PRIiFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo8 "o"
     * }
     */
    public static MemorySegment PRIo8() {
        class Holder {
            static final MemorySegment PRIo8
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo16 "o"
     * }
     */
    public static MemorySegment PRIo16() {
        class Holder {
            static final MemorySegment PRIo16
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo32 "o"
     * }
     */
    public static MemorySegment PRIo32() {
        class Holder {
            static final MemorySegment PRIo32
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo64 "lo"
     * }
     */
    public static MemorySegment PRIo64() {
        class Holder {
            static final MemorySegment PRIo64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIo64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST8 "o"
     * }
     */
    public static MemorySegment PRIoLEAST8() {
        class Holder {
            static final MemorySegment PRIoLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST16 "o"
     * }
     */
    public static MemorySegment PRIoLEAST16() {
        class Holder {
            static final MemorySegment PRIoLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST32 "o"
     * }
     */
    public static MemorySegment PRIoLEAST32() {
        class Holder {
            static final MemorySegment PRIoLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST64 "lo"
     * }
     */
    public static MemorySegment PRIoLEAST64() {
        class Holder {
            static final MemorySegment PRIoLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST8 "o"
     * }
     */
    public static MemorySegment PRIoFAST8() {
        class Holder {
            static final MemorySegment PRIoFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST16 "lo"
     * }
     */
    public static MemorySegment PRIoFAST16() {
        class Holder {
            static final MemorySegment PRIoFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST32 "lo"
     * }
     */
    public static MemorySegment PRIoFAST32() {
        class Holder {
            static final MemorySegment PRIoFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST64 "lo"
     * }
     */
    public static MemorySegment PRIoFAST64() {
        class Holder {
            static final MemorySegment PRIoFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu8 "u"
     * }
     */
    public static MemorySegment PRIu8() {
        class Holder {
            static final MemorySegment PRIu8
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu16 "u"
     * }
     */
    public static MemorySegment PRIu16() {
        class Holder {
            static final MemorySegment PRIu16
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu32 "u"
     * }
     */
    public static MemorySegment PRIu32() {
        class Holder {
            static final MemorySegment PRIu32
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu64 "lu"
     * }
     */
    public static MemorySegment PRIu64() {
        class Holder {
            static final MemorySegment PRIu64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIu64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST8 "u"
     * }
     */
    public static MemorySegment PRIuLEAST8() {
        class Holder {
            static final MemorySegment PRIuLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST16 "u"
     * }
     */
    public static MemorySegment PRIuLEAST16() {
        class Holder {
            static final MemorySegment PRIuLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST32 "u"
     * }
     */
    public static MemorySegment PRIuLEAST32() {
        class Holder {
            static final MemorySegment PRIuLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST64 "lu"
     * }
     */
    public static MemorySegment PRIuLEAST64() {
        class Holder {
            static final MemorySegment PRIuLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST8 "u"
     * }
     */
    public static MemorySegment PRIuFAST8() {
        class Holder {
            static final MemorySegment PRIuFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST16 "lu"
     * }
     */
    public static MemorySegment PRIuFAST16() {
        class Holder {
            static final MemorySegment PRIuFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST32 "lu"
     * }
     */
    public static MemorySegment PRIuFAST32() {
        class Holder {
            static final MemorySegment PRIuFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST64 "lu"
     * }
     */
    public static MemorySegment PRIuFAST64() {
        class Holder {
            static final MemorySegment PRIuFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx8 "x"
     * }
     */
    public static MemorySegment PRIx8() {
        class Holder {
            static final MemorySegment PRIx8
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx16 "x"
     * }
     */
    public static MemorySegment PRIx16() {
        class Holder {
            static final MemorySegment PRIx16
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx32 "x"
     * }
     */
    public static MemorySegment PRIx32() {
        class Holder {
            static final MemorySegment PRIx32
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx64 "lx"
     * }
     */
    public static MemorySegment PRIx64() {
        class Holder {
            static final MemorySegment PRIx64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIx64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST8 "x"
     * }
     */
    public static MemorySegment PRIxLEAST8() {
        class Holder {
            static final MemorySegment PRIxLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST16 "x"
     * }
     */
    public static MemorySegment PRIxLEAST16() {
        class Holder {
            static final MemorySegment PRIxLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST32 "x"
     * }
     */
    public static MemorySegment PRIxLEAST32() {
        class Holder {
            static final MemorySegment PRIxLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST64 "lx"
     * }
     */
    public static MemorySegment PRIxLEAST64() {
        class Holder {
            static final MemorySegment PRIxLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST8 "x"
     * }
     */
    public static MemorySegment PRIxFAST8() {
        class Holder {
            static final MemorySegment PRIxFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST16 "lx"
     * }
     */
    public static MemorySegment PRIxFAST16() {
        class Holder {
            static final MemorySegment PRIxFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST32 "lx"
     * }
     */
    public static MemorySegment PRIxFAST32() {
        class Holder {
            static final MemorySegment PRIxFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST64 "lx"
     * }
     */
    public static MemorySegment PRIxFAST64() {
        class Holder {
            static final MemorySegment PRIxFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX8 "X"
     * }
     */
    public static MemorySegment PRIX8() {
        class Holder {
            static final MemorySegment PRIX8
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX16 "X"
     * }
     */
    public static MemorySegment PRIX16() {
        class Holder {
            static final MemorySegment PRIX16
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX32 "X"
     * }
     */
    public static MemorySegment PRIX32() {
        class Holder {
            static final MemorySegment PRIX32
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX64 "lX"
     * }
     */
    public static MemorySegment PRIX64() {
        class Holder {
            static final MemorySegment PRIX64
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIX64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST8 "X"
     * }
     */
    public static MemorySegment PRIXLEAST8() {
        class Holder {
            static final MemorySegment PRIXLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST16 "X"
     * }
     */
    public static MemorySegment PRIXLEAST16() {
        class Holder {
            static final MemorySegment PRIXLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST32 "X"
     * }
     */
    public static MemorySegment PRIXLEAST32() {
        class Holder {
            static final MemorySegment PRIXLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST64 "lX"
     * }
     */
    public static MemorySegment PRIXLEAST64() {
        class Holder {
            static final MemorySegment PRIXLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST8 "X"
     * }
     */
    public static MemorySegment PRIXFAST8() {
        class Holder {
            static final MemorySegment PRIXFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST16 "lX"
     * }
     */
    public static MemorySegment PRIXFAST16() {
        class Holder {
            static final MemorySegment PRIXFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST32 "lX"
     * }
     */
    public static MemorySegment PRIXFAST32() {
        class Holder {
            static final MemorySegment PRIXFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST64 "lX"
     * }
     */
    public static MemorySegment PRIXFAST64() {
        class Holder {
            static final MemorySegment PRIXFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdMAX "ld"
     * }
     */
    public static MemorySegment PRIdMAX() {
        class Holder {
            static final MemorySegment PRIdMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiMAX "li"
     * }
     */
    public static MemorySegment PRIiMAX() {
        class Holder {
            static final MemorySegment PRIiMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoMAX "lo"
     * }
     */
    public static MemorySegment PRIoMAX() {
        class Holder {
            static final MemorySegment PRIoMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuMAX "lu"
     * }
     */
    public static MemorySegment PRIuMAX() {
        class Holder {
            static final MemorySegment PRIuMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxMAX "lx"
     * }
     */
    public static MemorySegment PRIxMAX() {
        class Holder {
            static final MemorySegment PRIxMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXMAX "lX"
     * }
     */
    public static MemorySegment PRIXMAX() {
        class Holder {
            static final MemorySegment PRIXMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdPTR "ld"
     * }
     */
    public static MemorySegment PRIdPTR() {
        class Holder {
            static final MemorySegment PRIdPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiPTR "li"
     * }
     */
    public static MemorySegment PRIiPTR() {
        class Holder {
            static final MemorySegment PRIiPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoPTR "lo"
     * }
     */
    public static MemorySegment PRIoPTR() {
        class Holder {
            static final MemorySegment PRIoPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuPTR "lu"
     * }
     */
    public static MemorySegment PRIuPTR() {
        class Holder {
            static final MemorySegment PRIuPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxPTR "lx"
     * }
     */
    public static MemorySegment PRIxPTR() {
        class Holder {
            static final MemorySegment PRIxPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXPTR "lX"
     * }
     */
    public static MemorySegment PRIXPTR() {
        class Holder {
            static final MemorySegment PRIXPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd8 "hhd"
     * }
     */
    public static MemorySegment SCNd8() {
        class Holder {
            static final MemorySegment SCNd8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNd8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd16 "hd"
     * }
     */
    public static MemorySegment SCNd16() {
        class Holder {
            static final MemorySegment SCNd16
                = LLVM.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNd16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd32 "d"
     * }
     */
    public static MemorySegment SCNd32() {
        class Holder {
            static final MemorySegment SCNd32
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNd32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd64 "ld"
     * }
     */
    public static MemorySegment SCNd64() {
        class Holder {
            static final MemorySegment SCNd64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNd64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdLEAST8() {
        class Holder {
            static final MemorySegment SCNdLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST16 "hd"
     * }
     */
    public static MemorySegment SCNdLEAST16() {
        class Holder {
            static final MemorySegment SCNdLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST32 "d"
     * }
     */
    public static MemorySegment SCNdLEAST32() {
        class Holder {
            static final MemorySegment SCNdLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST64 "ld"
     * }
     */
    public static MemorySegment SCNdLEAST64() {
        class Holder {
            static final MemorySegment SCNdLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdFAST8() {
        class Holder {
            static final MemorySegment SCNdFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST16 "ld"
     * }
     */
    public static MemorySegment SCNdFAST16() {
        class Holder {
            static final MemorySegment SCNdFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST32 "ld"
     * }
     */
    public static MemorySegment SCNdFAST32() {
        class Holder {
            static final MemorySegment SCNdFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST64 "ld"
     * }
     */
    public static MemorySegment SCNdFAST64() {
        class Holder {
            static final MemorySegment SCNdFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi8 "hhi"
     * }
     */
    public static MemorySegment SCNi8() {
        class Holder {
            static final MemorySegment SCNi8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNi8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi16 "hi"
     * }
     */
    public static MemorySegment SCNi16() {
        class Holder {
            static final MemorySegment SCNi16
                = LLVM.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNi16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi32 "i"
     * }
     */
    public static MemorySegment SCNi32() {
        class Holder {
            static final MemorySegment SCNi32
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNi32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi64 "li"
     * }
     */
    public static MemorySegment SCNi64() {
        class Holder {
            static final MemorySegment SCNi64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNi64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiLEAST8() {
        class Holder {
            static final MemorySegment SCNiLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST16 "hi"
     * }
     */
    public static MemorySegment SCNiLEAST16() {
        class Holder {
            static final MemorySegment SCNiLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST32 "i"
     * }
     */
    public static MemorySegment SCNiLEAST32() {
        class Holder {
            static final MemorySegment SCNiLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST64 "li"
     * }
     */
    public static MemorySegment SCNiLEAST64() {
        class Holder {
            static final MemorySegment SCNiLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiFAST8() {
        class Holder {
            static final MemorySegment SCNiFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST16 "li"
     * }
     */
    public static MemorySegment SCNiFAST16() {
        class Holder {
            static final MemorySegment SCNiFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST32 "li"
     * }
     */
    public static MemorySegment SCNiFAST32() {
        class Holder {
            static final MemorySegment SCNiFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST64 "li"
     * }
     */
    public static MemorySegment SCNiFAST64() {
        class Holder {
            static final MemorySegment SCNiFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu8 "hhu"
     * }
     */
    public static MemorySegment SCNu8() {
        class Holder {
            static final MemorySegment SCNu8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNu8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu16 "hu"
     * }
     */
    public static MemorySegment SCNu16() {
        class Holder {
            static final MemorySegment SCNu16
                = LLVM.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNu16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu32 "u"
     * }
     */
    public static MemorySegment SCNu32() {
        class Holder {
            static final MemorySegment SCNu32
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNu32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu64 "lu"
     * }
     */
    public static MemorySegment SCNu64() {
        class Holder {
            static final MemorySegment SCNu64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNu64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuLEAST8() {
        class Holder {
            static final MemorySegment SCNuLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST16 "hu"
     * }
     */
    public static MemorySegment SCNuLEAST16() {
        class Holder {
            static final MemorySegment SCNuLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST32 "u"
     * }
     */
    public static MemorySegment SCNuLEAST32() {
        class Holder {
            static final MemorySegment SCNuLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST64 "lu"
     * }
     */
    public static MemorySegment SCNuLEAST64() {
        class Holder {
            static final MemorySegment SCNuLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuFAST8() {
        class Holder {
            static final MemorySegment SCNuFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST16 "lu"
     * }
     */
    public static MemorySegment SCNuFAST16() {
        class Holder {
            static final MemorySegment SCNuFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST32 "lu"
     * }
     */
    public static MemorySegment SCNuFAST32() {
        class Holder {
            static final MemorySegment SCNuFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST64 "lu"
     * }
     */
    public static MemorySegment SCNuFAST64() {
        class Holder {
            static final MemorySegment SCNuFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo8 "hho"
     * }
     */
    public static MemorySegment SCNo8() {
        class Holder {
            static final MemorySegment SCNo8
                = LLVM.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNo8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo16 "ho"
     * }
     */
    public static MemorySegment SCNo16() {
        class Holder {
            static final MemorySegment SCNo16
                = LLVM.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNo16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo32 "o"
     * }
     */
    public static MemorySegment SCNo32() {
        class Holder {
            static final MemorySegment SCNo32
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNo32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo64 "lo"
     * }
     */
    public static MemorySegment SCNo64() {
        class Holder {
            static final MemorySegment SCNo64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNo64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST8 "hho"
     * }
     */
    public static MemorySegment SCNoLEAST8() {
        class Holder {
            static final MemorySegment SCNoLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST16 "ho"
     * }
     */
    public static MemorySegment SCNoLEAST16() {
        class Holder {
            static final MemorySegment SCNoLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST32 "o"
     * }
     */
    public static MemorySegment SCNoLEAST32() {
        class Holder {
            static final MemorySegment SCNoLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST64 "lo"
     * }
     */
    public static MemorySegment SCNoLEAST64() {
        class Holder {
            static final MemorySegment SCNoLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST8 "hho"
     * }
     */
    public static MemorySegment SCNoFAST8() {
        class Holder {
            static final MemorySegment SCNoFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST16 "lo"
     * }
     */
    public static MemorySegment SCNoFAST16() {
        class Holder {
            static final MemorySegment SCNoFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST32 "lo"
     * }
     */
    public static MemorySegment SCNoFAST32() {
        class Holder {
            static final MemorySegment SCNoFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST64 "lo"
     * }
     */
    public static MemorySegment SCNoFAST64() {
        class Holder {
            static final MemorySegment SCNoFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx8 "hhx"
     * }
     */
    public static MemorySegment SCNx8() {
        class Holder {
            static final MemorySegment SCNx8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNx8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx16 "hx"
     * }
     */
    public static MemorySegment SCNx16() {
        class Holder {
            static final MemorySegment SCNx16
                = LLVM.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNx16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx32 "x"
     * }
     */
    public static MemorySegment SCNx32() {
        class Holder {
            static final MemorySegment SCNx32
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNx32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx64 "lx"
     * }
     */
    public static MemorySegment SCNx64() {
        class Holder {
            static final MemorySegment SCNx64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNx64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxLEAST8() {
        class Holder {
            static final MemorySegment SCNxLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST16 "hx"
     * }
     */
    public static MemorySegment SCNxLEAST16() {
        class Holder {
            static final MemorySegment SCNxLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST32 "x"
     * }
     */
    public static MemorySegment SCNxLEAST32() {
        class Holder {
            static final MemorySegment SCNxLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST64 "lx"
     * }
     */
    public static MemorySegment SCNxLEAST64() {
        class Holder {
            static final MemorySegment SCNxLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxFAST8() {
        class Holder {
            static final MemorySegment SCNxFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST16 "lx"
     * }
     */
    public static MemorySegment SCNxFAST16() {
        class Holder {
            static final MemorySegment SCNxFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST32 "lx"
     * }
     */
    public static MemorySegment SCNxFAST32() {
        class Holder {
            static final MemorySegment SCNxFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST64 "lx"
     * }
     */
    public static MemorySegment SCNxFAST64() {
        class Holder {
            static final MemorySegment SCNxFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdMAX "ld"
     * }
     */
    public static MemorySegment SCNdMAX() {
        class Holder {
            static final MemorySegment SCNdMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiMAX "li"
     * }
     */
    public static MemorySegment SCNiMAX() {
        class Holder {
            static final MemorySegment SCNiMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoMAX "lo"
     * }
     */
    public static MemorySegment SCNoMAX() {
        class Holder {
            static final MemorySegment SCNoMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuMAX "lu"
     * }
     */
    public static MemorySegment SCNuMAX() {
        class Holder {
            static final MemorySegment SCNuMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxMAX "lx"
     * }
     */
    public static MemorySegment SCNxMAX() {
        class Holder {
            static final MemorySegment SCNxMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdPTR "ld"
     * }
     */
    public static MemorySegment SCNdPTR() {
        class Holder {
            static final MemorySegment SCNdPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiPTR "li"
     * }
     */
    public static MemorySegment SCNiPTR() {
        class Holder {
            static final MemorySegment SCNiPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoPTR "lo"
     * }
     */
    public static MemorySegment SCNoPTR() {
        class Holder {
            static final MemorySegment SCNoPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuPTR "lu"
     * }
     */
    public static MemorySegment SCNuPTR() {
        class Holder {
            static final MemorySegment SCNuPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxPTR "lx"
     * }
     */
    public static MemorySegment SCNxPTR() {
        class Holder {
            static final MemorySegment SCNxPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxPTR;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
    /**
     * {@snippet lang=c :
     * #define LLVM_DEFAULT_TARGET_TRIPLE "x86_64-pc-linux-gnu"
     * }
     */
    public static MemorySegment LLVM_DEFAULT_TARGET_TRIPLE() {
        class Holder {
            static final MemorySegment LLVM_DEFAULT_TARGET_TRIPLE
                = LLVM.LIBRARY_ARENA.allocateFrom("x86_64-pc-linux-gnu");
        }
        return Holder.LLVM_DEFAULT_TARGET_TRIPLE;
    }
    /**
     * {@snippet lang=c :
     * #define LLVM_HOST_TRIPLE "x86_64-pc-linux-gnu"
     * }
     */
    public static MemorySegment LLVM_HOST_TRIPLE() {
        class Holder {
            static final MemorySegment LLVM_HOST_TRIPLE
                = LLVM.LIBRARY_ARENA.allocateFrom("x86_64-pc-linux-gnu");
        }
        return Holder.LLVM_HOST_TRIPLE;
    }
    /**
     * {@snippet lang=c :
     * #define LLVM_VERSION_STRING "20.0.0"
     * }
     */
    public static MemorySegment LLVM_VERSION_STRING() {
        class Holder {
            static final MemorySegment LLVM_VERSION_STRING
                = LLVM.LIBRARY_ARENA.allocateFrom("20.0.0");
        }
        return Holder.LLVM_VERSION_STRING;
    }
}

