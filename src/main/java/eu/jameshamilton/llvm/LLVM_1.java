// Generated by jextract

package eu.jameshamilton.llvm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class LLVM_1 {

    LLVM_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("LLVM-20"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _INTTYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _INTTYPES_H 1
     * }
     */
    public static int _INTTYPES_H() {
        return _INTTYPES_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C2X_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C2X_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C2X_STRTOL() {
        return __GLIBC_USE_C2X_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)39L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 39
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _BITS_STDINT_LEAST_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_LEAST_H 1
     * }
     */
    public static int _BITS_STDINT_LEAST_H() {
        return _BITS_STDINT_LEAST_H;
    }
    private static final int ____gwchar_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____gwchar_t_defined 1
     * }
     */
    public static int ____gwchar_t_defined() {
        return ____gwchar_t_defined;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }

    private static class LLVMInstallFatalErrorHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstallFatalErrorHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInstallFatalErrorHandler(LLVMFatalErrorHandler Handler)
     * }
     */
    public static FunctionDescriptor LLVMInstallFatalErrorHandler$descriptor() {
        return LLVMInstallFatalErrorHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInstallFatalErrorHandler(LLVMFatalErrorHandler Handler)
     * }
     */
    public static MethodHandle LLVMInstallFatalErrorHandler$handle() {
        return LLVMInstallFatalErrorHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInstallFatalErrorHandler(LLVMFatalErrorHandler Handler)
     * }
     */
    public static MemorySegment LLVMInstallFatalErrorHandler$address() {
        return LLVMInstallFatalErrorHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInstallFatalErrorHandler(LLVMFatalErrorHandler Handler)
     * }
     */
    public static void LLVMInstallFatalErrorHandler(MemorySegment Handler) {
        var mh$ = LLVMInstallFatalErrorHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstallFatalErrorHandler", Handler);
            }
            mh$.invokeExact(Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMResetFatalErrorHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMResetFatalErrorHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMResetFatalErrorHandler()
     * }
     */
    public static FunctionDescriptor LLVMResetFatalErrorHandler$descriptor() {
        return LLVMResetFatalErrorHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMResetFatalErrorHandler()
     * }
     */
    public static MethodHandle LLVMResetFatalErrorHandler$handle() {
        return LLVMResetFatalErrorHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMResetFatalErrorHandler()
     * }
     */
    public static MemorySegment LLVMResetFatalErrorHandler$address() {
        return LLVMResetFatalErrorHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMResetFatalErrorHandler()
     * }
     */
    public static void LLVMResetFatalErrorHandler() {
        var mh$ = LLVMResetFatalErrorHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMResetFatalErrorHandler");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMEnablePrettyStackTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMEnablePrettyStackTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMEnablePrettyStackTrace()
     * }
     */
    public static FunctionDescriptor LLVMEnablePrettyStackTrace$descriptor() {
        return LLVMEnablePrettyStackTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMEnablePrettyStackTrace()
     * }
     */
    public static MethodHandle LLVMEnablePrettyStackTrace$handle() {
        return LLVMEnablePrettyStackTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMEnablePrettyStackTrace()
     * }
     */
    public static MemorySegment LLVMEnablePrettyStackTrace$address() {
        return LLVMEnablePrettyStackTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMEnablePrettyStackTrace()
     * }
     */
    public static void LLVMEnablePrettyStackTrace() {
        var mh$ = LLVMEnablePrettyStackTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMEnablePrettyStackTrace");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __gwchar_t
     * }
     */
    public static final OfInt __gwchar_t = LLVM.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static long imaxabs(long __n) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", __n);
            }
            return (long)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            LLVM.C_LONG,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = LLVM.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = LLVM.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = LLVM.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = LLVM.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int LLVMBool
     * }
     */
    public static final OfInt LLVMBool = LLVM.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueMemoryBuffer *LLVMMemoryBufferRef
     * }
     */
    public static final AddressLayout LLVMMemoryBufferRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueContext *LLVMContextRef
     * }
     */
    public static final AddressLayout LLVMContextRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueModule *LLVMModuleRef
     * }
     */
    public static final AddressLayout LLVMModuleRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueType *LLVMTypeRef
     * }
     */
    public static final AddressLayout LLVMTypeRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueValue *LLVMValueRef
     * }
     */
    public static final AddressLayout LLVMValueRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueBasicBlock *LLVMBasicBlockRef
     * }
     */
    public static final AddressLayout LLVMBasicBlockRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueMetadata *LLVMMetadataRef
     * }
     */
    public static final AddressLayout LLVMMetadataRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueNamedMDNode *LLVMNamedMDNodeRef
     * }
     */
    public static final AddressLayout LLVMNamedMDNodeRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueBuilder *LLVMBuilderRef
     * }
     */
    public static final AddressLayout LLVMBuilderRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueDIBuilder *LLVMDIBuilderRef
     * }
     */
    public static final AddressLayout LLVMDIBuilderRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueModuleProvider *LLVMModuleProviderRef
     * }
     */
    public static final AddressLayout LLVMModuleProviderRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaquePassManager *LLVMPassManagerRef
     * }
     */
    public static final AddressLayout LLVMPassManagerRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueUse *LLVMUseRef
     * }
     */
    public static final AddressLayout LLVMUseRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueOperandBundle *LLVMOperandBundleRef
     * }
     */
    public static final AddressLayout LLVMOperandBundleRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueAttributeRef *LLVMAttributeRef
     * }
     */
    public static final AddressLayout LLVMAttributeRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueDiagnosticInfo *LLVMDiagnosticInfoRef
     * }
     */
    public static final AddressLayout LLVMDiagnosticInfoRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMComdat *LLVMComdatRef
     * }
     */
    public static final AddressLayout LLVMComdatRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueJITEventListener *LLVMJITEventListenerRef
     * }
     */
    public static final AddressLayout LLVMJITEventListenerRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueBinary *LLVMBinaryRef
     * }
     */
    public static final AddressLayout LLVMBinaryRef = LLVM.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct LLVMOpaqueDbgRecord *LLVMDbgRecordRef
     * }
     */
    public static final AddressLayout LLVMDbgRecordRef = LLVM.C_POINTER;
    private static final int LLVMRet = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRet = 1
     * }
     */
    public static int LLVMRet() {
        return LLVMRet;
    }
    private static final int LLVMBr = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMBr = 2
     * }
     */
    public static int LLVMBr() {
        return LLVMBr;
    }
    private static final int LLVMSwitch = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSwitch = 3
     * }
     */
    public static int LLVMSwitch() {
        return LLVMSwitch;
    }
    private static final int LLVMIndirectBr = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIndirectBr = 4
     * }
     */
    public static int LLVMIndirectBr() {
        return LLVMIndirectBr;
    }
    private static final int LLVMInvoke = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInvoke = 5
     * }
     */
    public static int LLVMInvoke() {
        return LLVMInvoke;
    }
    private static final int LLVMUnreachable = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMUnreachable = 7
     * }
     */
    public static int LLVMUnreachable() {
        return LLVMUnreachable;
    }
    private static final int LLVMCallBr = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCallBr = 67
     * }
     */
    public static int LLVMCallBr() {
        return LLVMCallBr;
    }
    private static final int LLVMFNeg = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFNeg = 66
     * }
     */
    public static int LLVMFNeg() {
        return LLVMFNeg;
    }
    private static final int LLVMAdd = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAdd = 8
     * }
     */
    public static int LLVMAdd() {
        return LLVMAdd;
    }
    private static final int LLVMFAdd = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFAdd = 9
     * }
     */
    public static int LLVMFAdd() {
        return LLVMFAdd;
    }
    private static final int LLVMSub = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSub = 10
     * }
     */
    public static int LLVMSub() {
        return LLVMSub;
    }
    private static final int LLVMFSub = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFSub = 11
     * }
     */
    public static int LLVMFSub() {
        return LLVMFSub;
    }
    private static final int LLVMMul = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMMul = 12
     * }
     */
    public static int LLVMMul() {
        return LLVMMul;
    }
    private static final int LLVMFMul = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFMul = 13
     * }
     */
    public static int LLVMFMul() {
        return LLVMFMul;
    }
    private static final int LLVMUDiv = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMUDiv = 14
     * }
     */
    public static int LLVMUDiv() {
        return LLVMUDiv;
    }
    private static final int LLVMSDiv = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSDiv = 15
     * }
     */
    public static int LLVMSDiv() {
        return LLVMSDiv;
    }
    private static final int LLVMFDiv = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFDiv = 16
     * }
     */
    public static int LLVMFDiv() {
        return LLVMFDiv;
    }
    private static final int LLVMURem = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMURem = 17
     * }
     */
    public static int LLVMURem() {
        return LLVMURem;
    }
    private static final int LLVMSRem = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSRem = 18
     * }
     */
    public static int LLVMSRem() {
        return LLVMSRem;
    }
    private static final int LLVMFRem = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFRem = 19
     * }
     */
    public static int LLVMFRem() {
        return LLVMFRem;
    }
    private static final int LLVMShl = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMShl = 20
     * }
     */
    public static int LLVMShl() {
        return LLVMShl;
    }
    private static final int LLVMLShr = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLShr = 21
     * }
     */
    public static int LLVMLShr() {
        return LLVMLShr;
    }
    private static final int LLVMAShr = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAShr = 22
     * }
     */
    public static int LLVMAShr() {
        return LLVMAShr;
    }
    private static final int LLVMAnd = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAnd = 23
     * }
     */
    public static int LLVMAnd() {
        return LLVMAnd;
    }
    private static final int LLVMOr = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMOr = 24
     * }
     */
    public static int LLVMOr() {
        return LLVMOr;
    }
    private static final int LLVMXor = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMXor = 25
     * }
     */
    public static int LLVMXor() {
        return LLVMXor;
    }
    private static final int LLVMAlloca = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAlloca = 26
     * }
     */
    public static int LLVMAlloca() {
        return LLVMAlloca;
    }
    private static final int LLVMLoad = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLoad = 27
     * }
     */
    public static int LLVMLoad() {
        return LLVMLoad;
    }
    private static final int LLVMStore = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMStore = 28
     * }
     */
    public static int LLVMStore() {
        return LLVMStore;
    }
    private static final int LLVMGetElementPtr = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGetElementPtr = 29
     * }
     */
    public static int LLVMGetElementPtr() {
        return LLVMGetElementPtr;
    }
    private static final int LLVMTrunc = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMTrunc = 30
     * }
     */
    public static int LLVMTrunc() {
        return LLVMTrunc;
    }
    private static final int LLVMZExt = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMZExt = 31
     * }
     */
    public static int LLVMZExt() {
        return LLVMZExt;
    }
    private static final int LLVMSExt = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSExt = 32
     * }
     */
    public static int LLVMSExt() {
        return LLVMSExt;
    }
    private static final int LLVMFPToUI = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFPToUI = 33
     * }
     */
    public static int LLVMFPToUI() {
        return LLVMFPToUI;
    }
    private static final int LLVMFPToSI = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFPToSI = 34
     * }
     */
    public static int LLVMFPToSI() {
        return LLVMFPToSI;
    }
    private static final int LLVMUIToFP = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMUIToFP = 35
     * }
     */
    public static int LLVMUIToFP() {
        return LLVMUIToFP;
    }
    private static final int LLVMSIToFP = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSIToFP = 36
     * }
     */
    public static int LLVMSIToFP() {
        return LLVMSIToFP;
    }
    private static final int LLVMFPTrunc = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFPTrunc = 37
     * }
     */
    public static int LLVMFPTrunc() {
        return LLVMFPTrunc;
    }
    private static final int LLVMFPExt = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFPExt = 38
     * }
     */
    public static int LLVMFPExt() {
        return LLVMFPExt;
    }
    private static final int LLVMPtrToInt = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPtrToInt = 39
     * }
     */
    public static int LLVMPtrToInt() {
        return LLVMPtrToInt;
    }
    private static final int LLVMIntToPtr = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntToPtr = 40
     * }
     */
    public static int LLVMIntToPtr() {
        return LLVMIntToPtr;
    }
    private static final int LLVMBitCast = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMBitCast = 41
     * }
     */
    public static int LLVMBitCast() {
        return LLVMBitCast;
    }
    private static final int LLVMAddrSpaceCast = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAddrSpaceCast = 60
     * }
     */
    public static int LLVMAddrSpaceCast() {
        return LLVMAddrSpaceCast;
    }
    private static final int LLVMICmp = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMICmp = 42
     * }
     */
    public static int LLVMICmp() {
        return LLVMICmp;
    }
    private static final int LLVMFCmp = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFCmp = 43
     * }
     */
    public static int LLVMFCmp() {
        return LLVMFCmp;
    }
    private static final int LLVMPHI = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPHI = 44
     * }
     */
    public static int LLVMPHI() {
        return LLVMPHI;
    }
    private static final int LLVMCall = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCall = 45
     * }
     */
    public static int LLVMCall() {
        return LLVMCall;
    }
    private static final int LLVMSelect = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSelect = 46
     * }
     */
    public static int LLVMSelect() {
        return LLVMSelect;
    }
    private static final int LLVMUserOp1 = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMUserOp1 = 47
     * }
     */
    public static int LLVMUserOp1() {
        return LLVMUserOp1;
    }
    private static final int LLVMUserOp2 = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMUserOp2 = 48
     * }
     */
    public static int LLVMUserOp2() {
        return LLVMUserOp2;
    }
    private static final int LLVMVAArg = (int)49L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMVAArg = 49
     * }
     */
    public static int LLVMVAArg() {
        return LLVMVAArg;
    }
    private static final int LLVMExtractElement = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMExtractElement = 50
     * }
     */
    public static int LLVMExtractElement() {
        return LLVMExtractElement;
    }
    private static final int LLVMInsertElement = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInsertElement = 51
     * }
     */
    public static int LLVMInsertElement() {
        return LLVMInsertElement;
    }
    private static final int LLVMShuffleVector = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMShuffleVector = 52
     * }
     */
    public static int LLVMShuffleVector() {
        return LLVMShuffleVector;
    }
    private static final int LLVMExtractValue = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMExtractValue = 53
     * }
     */
    public static int LLVMExtractValue() {
        return LLVMExtractValue;
    }
    private static final int LLVMInsertValue = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInsertValue = 54
     * }
     */
    public static int LLVMInsertValue() {
        return LLVMInsertValue;
    }
    private static final int LLVMFreeze = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFreeze = 68
     * }
     */
    public static int LLVMFreeze() {
        return LLVMFreeze;
    }
    private static final int LLVMFence = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFence = 55
     * }
     */
    public static int LLVMFence() {
        return LLVMFence;
    }
    private static final int LLVMAtomicCmpXchg = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicCmpXchg = 56
     * }
     */
    public static int LLVMAtomicCmpXchg() {
        return LLVMAtomicCmpXchg;
    }
    private static final int LLVMAtomicRMW = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMW = 57
     * }
     */
    public static int LLVMAtomicRMW() {
        return LLVMAtomicRMW;
    }
    private static final int LLVMResume = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMResume = 58
     * }
     */
    public static int LLVMResume() {
        return LLVMResume;
    }
    private static final int LLVMLandingPad = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLandingPad = 59
     * }
     */
    public static int LLVMLandingPad() {
        return LLVMLandingPad;
    }
    private static final int LLVMCleanupRet = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCleanupRet = 61
     * }
     */
    public static int LLVMCleanupRet() {
        return LLVMCleanupRet;
    }
    private static final int LLVMCatchRet = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCatchRet = 62
     * }
     */
    public static int LLVMCatchRet() {
        return LLVMCatchRet;
    }
    private static final int LLVMCatchPad = (int)63L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCatchPad = 63
     * }
     */
    public static int LLVMCatchPad() {
        return LLVMCatchPad;
    }
    private static final int LLVMCleanupPad = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCleanupPad = 64
     * }
     */
    public static int LLVMCleanupPad() {
        return LLVMCleanupPad;
    }
    private static final int LLVMCatchSwitch = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCatchSwitch = 65
     * }
     */
    public static int LLVMCatchSwitch() {
        return LLVMCatchSwitch;
    }
    private static final int LLVMVoidTypeKind = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMVoidTypeKind = 0
     * }
     */
    public static int LLVMVoidTypeKind() {
        return LLVMVoidTypeKind;
    }
    private static final int LLVMHalfTypeKind = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMHalfTypeKind = 1
     * }
     */
    public static int LLVMHalfTypeKind() {
        return LLVMHalfTypeKind;
    }
    private static final int LLVMFloatTypeKind = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFloatTypeKind = 2
     * }
     */
    public static int LLVMFloatTypeKind() {
        return LLVMFloatTypeKind;
    }
    private static final int LLVMDoubleTypeKind = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDoubleTypeKind = 3
     * }
     */
    public static int LLVMDoubleTypeKind() {
        return LLVMDoubleTypeKind;
    }
    private static final int LLVMX86_FP80TypeKind = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX86_FP80TypeKind = 4
     * }
     */
    public static int LLVMX86_FP80TypeKind() {
        return LLVMX86_FP80TypeKind;
    }
    private static final int LLVMFP128TypeKind = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFP128TypeKind = 5
     * }
     */
    public static int LLVMFP128TypeKind() {
        return LLVMFP128TypeKind;
    }
    private static final int LLVMPPC_FP128TypeKind = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPPC_FP128TypeKind = 6
     * }
     */
    public static int LLVMPPC_FP128TypeKind() {
        return LLVMPPC_FP128TypeKind;
    }
    private static final int LLVMLabelTypeKind = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLabelTypeKind = 7
     * }
     */
    public static int LLVMLabelTypeKind() {
        return LLVMLabelTypeKind;
    }
    private static final int LLVMIntegerTypeKind = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntegerTypeKind = 8
     * }
     */
    public static int LLVMIntegerTypeKind() {
        return LLVMIntegerTypeKind;
    }
    private static final int LLVMFunctionTypeKind = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFunctionTypeKind = 9
     * }
     */
    public static int LLVMFunctionTypeKind() {
        return LLVMFunctionTypeKind;
    }
    private static final int LLVMStructTypeKind = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMStructTypeKind = 10
     * }
     */
    public static int LLVMStructTypeKind() {
        return LLVMStructTypeKind;
    }
    private static final int LLVMArrayTypeKind = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMArrayTypeKind = 11
     * }
     */
    public static int LLVMArrayTypeKind() {
        return LLVMArrayTypeKind;
    }
    private static final int LLVMPointerTypeKind = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPointerTypeKind = 12
     * }
     */
    public static int LLVMPointerTypeKind() {
        return LLVMPointerTypeKind;
    }
    private static final int LLVMVectorTypeKind = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMVectorTypeKind = 13
     * }
     */
    public static int LLVMVectorTypeKind() {
        return LLVMVectorTypeKind;
    }
    private static final int LLVMMetadataTypeKind = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMMetadataTypeKind = 14
     * }
     */
    public static int LLVMMetadataTypeKind() {
        return LLVMMetadataTypeKind;
    }
    private static final int LLVMTokenTypeKind = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMTokenTypeKind = 16
     * }
     */
    public static int LLVMTokenTypeKind() {
        return LLVMTokenTypeKind;
    }
    private static final int LLVMScalableVectorTypeKind = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMScalableVectorTypeKind = 17
     * }
     */
    public static int LLVMScalableVectorTypeKind() {
        return LLVMScalableVectorTypeKind;
    }
    private static final int LLVMBFloatTypeKind = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMBFloatTypeKind = 18
     * }
     */
    public static int LLVMBFloatTypeKind() {
        return LLVMBFloatTypeKind;
    }
    private static final int LLVMX86_AMXTypeKind = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX86_AMXTypeKind = 19
     * }
     */
    public static int LLVMX86_AMXTypeKind() {
        return LLVMX86_AMXTypeKind;
    }
    private static final int LLVMTargetExtTypeKind = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMTargetExtTypeKind = 20
     * }
     */
    public static int LLVMTargetExtTypeKind() {
        return LLVMTargetExtTypeKind;
    }
    private static final int LLVMExternalLinkage = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMExternalLinkage = 0
     * }
     */
    public static int LLVMExternalLinkage() {
        return LLVMExternalLinkage;
    }
    private static final int LLVMAvailableExternallyLinkage = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAvailableExternallyLinkage = 1
     * }
     */
    public static int LLVMAvailableExternallyLinkage() {
        return LLVMAvailableExternallyLinkage;
    }
    private static final int LLVMLinkOnceAnyLinkage = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLinkOnceAnyLinkage = 2
     * }
     */
    public static int LLVMLinkOnceAnyLinkage() {
        return LLVMLinkOnceAnyLinkage;
    }
    private static final int LLVMLinkOnceODRLinkage = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLinkOnceODRLinkage = 3
     * }
     */
    public static int LLVMLinkOnceODRLinkage() {
        return LLVMLinkOnceODRLinkage;
    }
    private static final int LLVMLinkOnceODRAutoHideLinkage = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLinkOnceODRAutoHideLinkage = 4
     * }
     */
    public static int LLVMLinkOnceODRAutoHideLinkage() {
        return LLVMLinkOnceODRAutoHideLinkage;
    }
    private static final int LLVMWeakAnyLinkage = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMWeakAnyLinkage = 5
     * }
     */
    public static int LLVMWeakAnyLinkage() {
        return LLVMWeakAnyLinkage;
    }
    private static final int LLVMWeakODRLinkage = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMWeakODRLinkage = 6
     * }
     */
    public static int LLVMWeakODRLinkage() {
        return LLVMWeakODRLinkage;
    }
    private static final int LLVMAppendingLinkage = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAppendingLinkage = 7
     * }
     */
    public static int LLVMAppendingLinkage() {
        return LLVMAppendingLinkage;
    }
    private static final int LLVMInternalLinkage = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInternalLinkage = 8
     * }
     */
    public static int LLVMInternalLinkage() {
        return LLVMInternalLinkage;
    }
    private static final int LLVMPrivateLinkage = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPrivateLinkage = 9
     * }
     */
    public static int LLVMPrivateLinkage() {
        return LLVMPrivateLinkage;
    }
    private static final int LLVMDLLImportLinkage = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDLLImportLinkage = 10
     * }
     */
    public static int LLVMDLLImportLinkage() {
        return LLVMDLLImportLinkage;
    }
    private static final int LLVMDLLExportLinkage = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDLLExportLinkage = 11
     * }
     */
    public static int LLVMDLLExportLinkage() {
        return LLVMDLLExportLinkage;
    }
    private static final int LLVMExternalWeakLinkage = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMExternalWeakLinkage = 12
     * }
     */
    public static int LLVMExternalWeakLinkage() {
        return LLVMExternalWeakLinkage;
    }
    private static final int LLVMGhostLinkage = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGhostLinkage = 13
     * }
     */
    public static int LLVMGhostLinkage() {
        return LLVMGhostLinkage;
    }
    private static final int LLVMCommonLinkage = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCommonLinkage = 14
     * }
     */
    public static int LLVMCommonLinkage() {
        return LLVMCommonLinkage;
    }
    private static final int LLVMLinkerPrivateLinkage = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLinkerPrivateLinkage = 15
     * }
     */
    public static int LLVMLinkerPrivateLinkage() {
        return LLVMLinkerPrivateLinkage;
    }
    private static final int LLVMLinkerPrivateWeakLinkage = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLinkerPrivateWeakLinkage = 16
     * }
     */
    public static int LLVMLinkerPrivateWeakLinkage() {
        return LLVMLinkerPrivateWeakLinkage;
    }
    private static final int LLVMDefaultVisibility = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDefaultVisibility = 0
     * }
     */
    public static int LLVMDefaultVisibility() {
        return LLVMDefaultVisibility;
    }
    private static final int LLVMHiddenVisibility = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMHiddenVisibility = 1
     * }
     */
    public static int LLVMHiddenVisibility() {
        return LLVMHiddenVisibility;
    }
    private static final int LLVMProtectedVisibility = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMProtectedVisibility = 2
     * }
     */
    public static int LLVMProtectedVisibility() {
        return LLVMProtectedVisibility;
    }
    private static final int LLVMNoUnnamedAddr = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMNoUnnamedAddr = 0
     * }
     */
    public static int LLVMNoUnnamedAddr() {
        return LLVMNoUnnamedAddr;
    }
    private static final int LLVMLocalUnnamedAddr = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLocalUnnamedAddr = 1
     * }
     */
    public static int LLVMLocalUnnamedAddr() {
        return LLVMLocalUnnamedAddr;
    }
    private static final int LLVMGlobalUnnamedAddr = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGlobalUnnamedAddr = 2
     * }
     */
    public static int LLVMGlobalUnnamedAddr() {
        return LLVMGlobalUnnamedAddr;
    }
    private static final int LLVMDefaultStorageClass = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDefaultStorageClass = 0
     * }
     */
    public static int LLVMDefaultStorageClass() {
        return LLVMDefaultStorageClass;
    }
    private static final int LLVMDLLImportStorageClass = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDLLImportStorageClass = 1
     * }
     */
    public static int LLVMDLLImportStorageClass() {
        return LLVMDLLImportStorageClass;
    }
    private static final int LLVMDLLExportStorageClass = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDLLExportStorageClass = 2
     * }
     */
    public static int LLVMDLLExportStorageClass() {
        return LLVMDLLExportStorageClass;
    }
    private static final int LLVMCCallConv = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCCallConv = 0
     * }
     */
    public static int LLVMCCallConv() {
        return LLVMCCallConv;
    }
    private static final int LLVMFastCallConv = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastCallConv = 8
     * }
     */
    public static int LLVMFastCallConv() {
        return LLVMFastCallConv;
    }
    private static final int LLVMColdCallConv = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMColdCallConv = 9
     * }
     */
    public static int LLVMColdCallConv() {
        return LLVMColdCallConv;
    }
    private static final int LLVMGHCCallConv = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGHCCallConv = 10
     * }
     */
    public static int LLVMGHCCallConv() {
        return LLVMGHCCallConv;
    }
    private static final int LLVMHiPECallConv = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMHiPECallConv = 11
     * }
     */
    public static int LLVMHiPECallConv() {
        return LLVMHiPECallConv;
    }
    private static final int LLVMAnyRegCallConv = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAnyRegCallConv = 13
     * }
     */
    public static int LLVMAnyRegCallConv() {
        return LLVMAnyRegCallConv;
    }
    private static final int LLVMPreserveMostCallConv = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPreserveMostCallConv = 14
     * }
     */
    public static int LLVMPreserveMostCallConv() {
        return LLVMPreserveMostCallConv;
    }
    private static final int LLVMPreserveAllCallConv = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPreserveAllCallConv = 15
     * }
     */
    public static int LLVMPreserveAllCallConv() {
        return LLVMPreserveAllCallConv;
    }
    private static final int LLVMSwiftCallConv = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSwiftCallConv = 16
     * }
     */
    public static int LLVMSwiftCallConv() {
        return LLVMSwiftCallConv;
    }
    private static final int LLVMCXXFASTTLSCallConv = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMCXXFASTTLSCallConv = 17
     * }
     */
    public static int LLVMCXXFASTTLSCallConv() {
        return LLVMCXXFASTTLSCallConv;
    }
    private static final int LLVMX86StdcallCallConv = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX86StdcallCallConv = 64
     * }
     */
    public static int LLVMX86StdcallCallConv() {
        return LLVMX86StdcallCallConv;
    }
    private static final int LLVMX86FastcallCallConv = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX86FastcallCallConv = 65
     * }
     */
    public static int LLVMX86FastcallCallConv() {
        return LLVMX86FastcallCallConv;
    }
    private static final int LLVMARMAPCSCallConv = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMARMAPCSCallConv = 66
     * }
     */
    public static int LLVMARMAPCSCallConv() {
        return LLVMARMAPCSCallConv;
    }
    private static final int LLVMARMAAPCSCallConv = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMARMAAPCSCallConv = 67
     * }
     */
    public static int LLVMARMAAPCSCallConv() {
        return LLVMARMAAPCSCallConv;
    }
    private static final int LLVMARMAAPCSVFPCallConv = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMARMAAPCSVFPCallConv = 68
     * }
     */
    public static int LLVMARMAAPCSVFPCallConv() {
        return LLVMARMAAPCSVFPCallConv;
    }
    private static final int LLVMMSP430INTRCallConv = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMMSP430INTRCallConv = 69
     * }
     */
    public static int LLVMMSP430INTRCallConv() {
        return LLVMMSP430INTRCallConv;
    }
    private static final int LLVMX86ThisCallCallConv = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX86ThisCallCallConv = 70
     * }
     */
    public static int LLVMX86ThisCallCallConv() {
        return LLVMX86ThisCallCallConv;
    }
    private static final int LLVMPTXKernelCallConv = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPTXKernelCallConv = 71
     * }
     */
    public static int LLVMPTXKernelCallConv() {
        return LLVMPTXKernelCallConv;
    }
    private static final int LLVMPTXDeviceCallConv = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPTXDeviceCallConv = 72
     * }
     */
    public static int LLVMPTXDeviceCallConv() {
        return LLVMPTXDeviceCallConv;
    }
    private static final int LLVMSPIRFUNCCallConv = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSPIRFUNCCallConv = 75
     * }
     */
    public static int LLVMSPIRFUNCCallConv() {
        return LLVMSPIRFUNCCallConv;
    }
    private static final int LLVMSPIRKERNELCallConv = (int)76L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMSPIRKERNELCallConv = 76
     * }
     */
    public static int LLVMSPIRKERNELCallConv() {
        return LLVMSPIRKERNELCallConv;
    }
    private static final int LLVMIntelOCLBICallConv = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntelOCLBICallConv = 77
     * }
     */
    public static int LLVMIntelOCLBICallConv() {
        return LLVMIntelOCLBICallConv;
    }
    private static final int LLVMX8664SysVCallConv = (int)78L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX8664SysVCallConv = 78
     * }
     */
    public static int LLVMX8664SysVCallConv() {
        return LLVMX8664SysVCallConv;
    }
    private static final int LLVMWin64CallConv = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMWin64CallConv = 79
     * }
     */
    public static int LLVMWin64CallConv() {
        return LLVMWin64CallConv;
    }
    private static final int LLVMX86VectorCallCallConv = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX86VectorCallCallConv = 80
     * }
     */
    public static int LLVMX86VectorCallCallConv() {
        return LLVMX86VectorCallCallConv;
    }
    private static final int LLVMHHVMCallConv = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMHHVMCallConv = 81
     * }
     */
    public static int LLVMHHVMCallConv() {
        return LLVMHHVMCallConv;
    }
    private static final int LLVMHHVMCCallConv = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMHHVMCCallConv = 82
     * }
     */
    public static int LLVMHHVMCCallConv() {
        return LLVMHHVMCCallConv;
    }
    private static final int LLVMX86INTRCallConv = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX86INTRCallConv = 83
     * }
     */
    public static int LLVMX86INTRCallConv() {
        return LLVMX86INTRCallConv;
    }
    private static final int LLVMAVRINTRCallConv = (int)84L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAVRINTRCallConv = 84
     * }
     */
    public static int LLVMAVRINTRCallConv() {
        return LLVMAVRINTRCallConv;
    }
    private static final int LLVMAVRSIGNALCallConv = (int)85L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAVRSIGNALCallConv = 85
     * }
     */
    public static int LLVMAVRSIGNALCallConv() {
        return LLVMAVRSIGNALCallConv;
    }
    private static final int LLVMAVRBUILTINCallConv = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAVRBUILTINCallConv = 86
     * }
     */
    public static int LLVMAVRBUILTINCallConv() {
        return LLVMAVRBUILTINCallConv;
    }
    private static final int LLVMAMDGPUVSCallConv = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAMDGPUVSCallConv = 87
     * }
     */
    public static int LLVMAMDGPUVSCallConv() {
        return LLVMAMDGPUVSCallConv;
    }
    private static final int LLVMAMDGPUGSCallConv = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAMDGPUGSCallConv = 88
     * }
     */
    public static int LLVMAMDGPUGSCallConv() {
        return LLVMAMDGPUGSCallConv;
    }
    private static final int LLVMAMDGPUPSCallConv = (int)89L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAMDGPUPSCallConv = 89
     * }
     */
    public static int LLVMAMDGPUPSCallConv() {
        return LLVMAMDGPUPSCallConv;
    }
    private static final int LLVMAMDGPUCSCallConv = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAMDGPUCSCallConv = 90
     * }
     */
    public static int LLVMAMDGPUCSCallConv() {
        return LLVMAMDGPUCSCallConv;
    }
    private static final int LLVMAMDGPUKERNELCallConv = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAMDGPUKERNELCallConv = 91
     * }
     */
    public static int LLVMAMDGPUKERNELCallConv() {
        return LLVMAMDGPUKERNELCallConv;
    }
    private static final int LLVMX86RegCallCallConv = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMX86RegCallCallConv = 92
     * }
     */
    public static int LLVMX86RegCallCallConv() {
        return LLVMX86RegCallCallConv;
    }
    private static final int LLVMAMDGPUHSCallConv = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAMDGPUHSCallConv = 93
     * }
     */
    public static int LLVMAMDGPUHSCallConv() {
        return LLVMAMDGPUHSCallConv;
    }
    private static final int LLVMMSP430BUILTINCallConv = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMMSP430BUILTINCallConv = 94
     * }
     */
    public static int LLVMMSP430BUILTINCallConv() {
        return LLVMMSP430BUILTINCallConv;
    }
    private static final int LLVMAMDGPULSCallConv = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAMDGPULSCallConv = 95
     * }
     */
    public static int LLVMAMDGPULSCallConv() {
        return LLVMAMDGPULSCallConv;
    }
    private static final int LLVMAMDGPUESCallConv = (int)96L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAMDGPUESCallConv = 96
     * }
     */
    public static int LLVMAMDGPUESCallConv() {
        return LLVMAMDGPUESCallConv;
    }
    private static final int LLVMArgumentValueKind = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMArgumentValueKind = 0
     * }
     */
    public static int LLVMArgumentValueKind() {
        return LLVMArgumentValueKind;
    }
    private static final int LLVMBasicBlockValueKind = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMBasicBlockValueKind = 1
     * }
     */
    public static int LLVMBasicBlockValueKind() {
        return LLVMBasicBlockValueKind;
    }
    private static final int LLVMMemoryUseValueKind = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMMemoryUseValueKind = 2
     * }
     */
    public static int LLVMMemoryUseValueKind() {
        return LLVMMemoryUseValueKind;
    }
    private static final int LLVMMemoryDefValueKind = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMMemoryDefValueKind = 3
     * }
     */
    public static int LLVMMemoryDefValueKind() {
        return LLVMMemoryDefValueKind;
    }
    private static final int LLVMMemoryPhiValueKind = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMMemoryPhiValueKind = 4
     * }
     */
    public static int LLVMMemoryPhiValueKind() {
        return LLVMMemoryPhiValueKind;
    }
    private static final int LLVMFunctionValueKind = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFunctionValueKind = 5
     * }
     */
    public static int LLVMFunctionValueKind() {
        return LLVMFunctionValueKind;
    }
    private static final int LLVMGlobalAliasValueKind = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGlobalAliasValueKind = 6
     * }
     */
    public static int LLVMGlobalAliasValueKind() {
        return LLVMGlobalAliasValueKind;
    }
    private static final int LLVMGlobalIFuncValueKind = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGlobalIFuncValueKind = 7
     * }
     */
    public static int LLVMGlobalIFuncValueKind() {
        return LLVMGlobalIFuncValueKind;
    }
    private static final int LLVMGlobalVariableValueKind = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGlobalVariableValueKind = 8
     * }
     */
    public static int LLVMGlobalVariableValueKind() {
        return LLVMGlobalVariableValueKind;
    }
    private static final int LLVMBlockAddressValueKind = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMBlockAddressValueKind = 9
     * }
     */
    public static int LLVMBlockAddressValueKind() {
        return LLVMBlockAddressValueKind;
    }
    private static final int LLVMConstantExprValueKind = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantExprValueKind = 10
     * }
     */
    public static int LLVMConstantExprValueKind() {
        return LLVMConstantExprValueKind;
    }
    private static final int LLVMConstantArrayValueKind = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantArrayValueKind = 11
     * }
     */
    public static int LLVMConstantArrayValueKind() {
        return LLVMConstantArrayValueKind;
    }
    private static final int LLVMConstantStructValueKind = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantStructValueKind = 12
     * }
     */
    public static int LLVMConstantStructValueKind() {
        return LLVMConstantStructValueKind;
    }
    private static final int LLVMConstantVectorValueKind = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantVectorValueKind = 13
     * }
     */
    public static int LLVMConstantVectorValueKind() {
        return LLVMConstantVectorValueKind;
    }
    private static final int LLVMUndefValueValueKind = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMUndefValueValueKind = 14
     * }
     */
    public static int LLVMUndefValueValueKind() {
        return LLVMUndefValueValueKind;
    }
    private static final int LLVMConstantAggregateZeroValueKind = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantAggregateZeroValueKind = 15
     * }
     */
    public static int LLVMConstantAggregateZeroValueKind() {
        return LLVMConstantAggregateZeroValueKind;
    }
    private static final int LLVMConstantDataArrayValueKind = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantDataArrayValueKind = 16
     * }
     */
    public static int LLVMConstantDataArrayValueKind() {
        return LLVMConstantDataArrayValueKind;
    }
    private static final int LLVMConstantDataVectorValueKind = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantDataVectorValueKind = 17
     * }
     */
    public static int LLVMConstantDataVectorValueKind() {
        return LLVMConstantDataVectorValueKind;
    }
    private static final int LLVMConstantIntValueKind = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantIntValueKind = 18
     * }
     */
    public static int LLVMConstantIntValueKind() {
        return LLVMConstantIntValueKind;
    }
    private static final int LLVMConstantFPValueKind = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantFPValueKind = 19
     * }
     */
    public static int LLVMConstantFPValueKind() {
        return LLVMConstantFPValueKind;
    }
    private static final int LLVMConstantPointerNullValueKind = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantPointerNullValueKind = 20
     * }
     */
    public static int LLVMConstantPointerNullValueKind() {
        return LLVMConstantPointerNullValueKind;
    }
    private static final int LLVMConstantTokenNoneValueKind = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantTokenNoneValueKind = 21
     * }
     */
    public static int LLVMConstantTokenNoneValueKind() {
        return LLVMConstantTokenNoneValueKind;
    }
    private static final int LLVMMetadataAsValueValueKind = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMMetadataAsValueValueKind = 22
     * }
     */
    public static int LLVMMetadataAsValueValueKind() {
        return LLVMMetadataAsValueValueKind;
    }
    private static final int LLVMInlineAsmValueKind = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInlineAsmValueKind = 23
     * }
     */
    public static int LLVMInlineAsmValueKind() {
        return LLVMInlineAsmValueKind;
    }
    private static final int LLVMInstructionValueKind = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInstructionValueKind = 24
     * }
     */
    public static int LLVMInstructionValueKind() {
        return LLVMInstructionValueKind;
    }
    private static final int LLVMPoisonValueValueKind = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMPoisonValueValueKind = 25
     * }
     */
    public static int LLVMPoisonValueValueKind() {
        return LLVMPoisonValueValueKind;
    }
    private static final int LLVMConstantTargetNoneValueKind = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantTargetNoneValueKind = 26
     * }
     */
    public static int LLVMConstantTargetNoneValueKind() {
        return LLVMConstantTargetNoneValueKind;
    }
    private static final int LLVMConstantPtrAuthValueKind = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMConstantPtrAuthValueKind = 27
     * }
     */
    public static int LLVMConstantPtrAuthValueKind() {
        return LLVMConstantPtrAuthValueKind;
    }
    private static final int LLVMIntEQ = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntEQ = 32
     * }
     */
    public static int LLVMIntEQ() {
        return LLVMIntEQ;
    }
    private static final int LLVMIntNE = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntNE = 33
     * }
     */
    public static int LLVMIntNE() {
        return LLVMIntNE;
    }
    private static final int LLVMIntUGT = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntUGT = 34
     * }
     */
    public static int LLVMIntUGT() {
        return LLVMIntUGT;
    }
    private static final int LLVMIntUGE = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntUGE = 35
     * }
     */
    public static int LLVMIntUGE() {
        return LLVMIntUGE;
    }
    private static final int LLVMIntULT = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntULT = 36
     * }
     */
    public static int LLVMIntULT() {
        return LLVMIntULT;
    }
    private static final int LLVMIntULE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntULE = 37
     * }
     */
    public static int LLVMIntULE() {
        return LLVMIntULE;
    }
    private static final int LLVMIntSGT = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntSGT = 38
     * }
     */
    public static int LLVMIntSGT() {
        return LLVMIntSGT;
    }
    private static final int LLVMIntSGE = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntSGE = 39
     * }
     */
    public static int LLVMIntSGE() {
        return LLVMIntSGE;
    }
    private static final int LLVMIntSLT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntSLT = 40
     * }
     */
    public static int LLVMIntSLT() {
        return LLVMIntSLT;
    }
    private static final int LLVMIntSLE = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMIntSLE = 41
     * }
     */
    public static int LLVMIntSLE() {
        return LLVMIntSLE;
    }
    private static final int LLVMRealPredicateFalse = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealPredicateFalse = 0
     * }
     */
    public static int LLVMRealPredicateFalse() {
        return LLVMRealPredicateFalse;
    }
    private static final int LLVMRealOEQ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealOEQ = 1
     * }
     */
    public static int LLVMRealOEQ() {
        return LLVMRealOEQ;
    }
    private static final int LLVMRealOGT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealOGT = 2
     * }
     */
    public static int LLVMRealOGT() {
        return LLVMRealOGT;
    }
    private static final int LLVMRealOGE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealOGE = 3
     * }
     */
    public static int LLVMRealOGE() {
        return LLVMRealOGE;
    }
    private static final int LLVMRealOLT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealOLT = 4
     * }
     */
    public static int LLVMRealOLT() {
        return LLVMRealOLT;
    }
    private static final int LLVMRealOLE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealOLE = 5
     * }
     */
    public static int LLVMRealOLE() {
        return LLVMRealOLE;
    }
    private static final int LLVMRealONE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealONE = 6
     * }
     */
    public static int LLVMRealONE() {
        return LLVMRealONE;
    }
    private static final int LLVMRealORD = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealORD = 7
     * }
     */
    public static int LLVMRealORD() {
        return LLVMRealORD;
    }
    private static final int LLVMRealUNO = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealUNO = 8
     * }
     */
    public static int LLVMRealUNO() {
        return LLVMRealUNO;
    }
    private static final int LLVMRealUEQ = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealUEQ = 9
     * }
     */
    public static int LLVMRealUEQ() {
        return LLVMRealUEQ;
    }
    private static final int LLVMRealUGT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealUGT = 10
     * }
     */
    public static int LLVMRealUGT() {
        return LLVMRealUGT;
    }
    private static final int LLVMRealUGE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealUGE = 11
     * }
     */
    public static int LLVMRealUGE() {
        return LLVMRealUGE;
    }
    private static final int LLVMRealULT = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealULT = 12
     * }
     */
    public static int LLVMRealULT() {
        return LLVMRealULT;
    }
    private static final int LLVMRealULE = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealULE = 13
     * }
     */
    public static int LLVMRealULE() {
        return LLVMRealULE;
    }
    private static final int LLVMRealUNE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealUNE = 14
     * }
     */
    public static int LLVMRealUNE() {
        return LLVMRealUNE;
    }
    private static final int LLVMRealPredicateTrue = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMRealPredicateTrue = 15
     * }
     */
    public static int LLVMRealPredicateTrue() {
        return LLVMRealPredicateTrue;
    }
    private static final int LLVMLandingPadCatch = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLandingPadCatch = 0
     * }
     */
    public static int LLVMLandingPadCatch() {
        return LLVMLandingPadCatch;
    }
    private static final int LLVMLandingPadFilter = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLandingPadFilter = 1
     * }
     */
    public static int LLVMLandingPadFilter() {
        return LLVMLandingPadFilter;
    }
    private static final int LLVMNotThreadLocal = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMNotThreadLocal = 0
     * }
     */
    public static int LLVMNotThreadLocal() {
        return LLVMNotThreadLocal;
    }
    private static final int LLVMGeneralDynamicTLSModel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGeneralDynamicTLSModel = 1
     * }
     */
    public static int LLVMGeneralDynamicTLSModel() {
        return LLVMGeneralDynamicTLSModel;
    }
    private static final int LLVMLocalDynamicTLSModel = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLocalDynamicTLSModel = 2
     * }
     */
    public static int LLVMLocalDynamicTLSModel() {
        return LLVMLocalDynamicTLSModel;
    }
    private static final int LLVMInitialExecTLSModel = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInitialExecTLSModel = 3
     * }
     */
    public static int LLVMInitialExecTLSModel() {
        return LLVMInitialExecTLSModel;
    }
    private static final int LLVMLocalExecTLSModel = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMLocalExecTLSModel = 4
     * }
     */
    public static int LLVMLocalExecTLSModel() {
        return LLVMLocalExecTLSModel;
    }
    private static final int LLVMAtomicOrderingNotAtomic = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicOrderingNotAtomic = 0
     * }
     */
    public static int LLVMAtomicOrderingNotAtomic() {
        return LLVMAtomicOrderingNotAtomic;
    }
    private static final int LLVMAtomicOrderingUnordered = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicOrderingUnordered = 1
     * }
     */
    public static int LLVMAtomicOrderingUnordered() {
        return LLVMAtomicOrderingUnordered;
    }
    private static final int LLVMAtomicOrderingMonotonic = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicOrderingMonotonic = 2
     * }
     */
    public static int LLVMAtomicOrderingMonotonic() {
        return LLVMAtomicOrderingMonotonic;
    }
    private static final int LLVMAtomicOrderingAcquire = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicOrderingAcquire = 4
     * }
     */
    public static int LLVMAtomicOrderingAcquire() {
        return LLVMAtomicOrderingAcquire;
    }
    private static final int LLVMAtomicOrderingRelease = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicOrderingRelease = 5
     * }
     */
    public static int LLVMAtomicOrderingRelease() {
        return LLVMAtomicOrderingRelease;
    }
    private static final int LLVMAtomicOrderingAcquireRelease = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicOrderingAcquireRelease = 6
     * }
     */
    public static int LLVMAtomicOrderingAcquireRelease() {
        return LLVMAtomicOrderingAcquireRelease;
    }
    private static final int LLVMAtomicOrderingSequentiallyConsistent = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicOrderingSequentiallyConsistent = 7
     * }
     */
    public static int LLVMAtomicOrderingSequentiallyConsistent() {
        return LLVMAtomicOrderingSequentiallyConsistent;
    }
    private static final int LLVMAtomicRMWBinOpXchg = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpXchg = 0
     * }
     */
    public static int LLVMAtomicRMWBinOpXchg() {
        return LLVMAtomicRMWBinOpXchg;
    }
    private static final int LLVMAtomicRMWBinOpAdd = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpAdd = 1
     * }
     */
    public static int LLVMAtomicRMWBinOpAdd() {
        return LLVMAtomicRMWBinOpAdd;
    }
    private static final int LLVMAtomicRMWBinOpSub = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpSub = 2
     * }
     */
    public static int LLVMAtomicRMWBinOpSub() {
        return LLVMAtomicRMWBinOpSub;
    }
    private static final int LLVMAtomicRMWBinOpAnd = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpAnd = 3
     * }
     */
    public static int LLVMAtomicRMWBinOpAnd() {
        return LLVMAtomicRMWBinOpAnd;
    }
    private static final int LLVMAtomicRMWBinOpNand = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpNand = 4
     * }
     */
    public static int LLVMAtomicRMWBinOpNand() {
        return LLVMAtomicRMWBinOpNand;
    }
    private static final int LLVMAtomicRMWBinOpOr = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpOr = 5
     * }
     */
    public static int LLVMAtomicRMWBinOpOr() {
        return LLVMAtomicRMWBinOpOr;
    }
    private static final int LLVMAtomicRMWBinOpXor = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpXor = 6
     * }
     */
    public static int LLVMAtomicRMWBinOpXor() {
        return LLVMAtomicRMWBinOpXor;
    }
    private static final int LLVMAtomicRMWBinOpMax = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpMax = 7
     * }
     */
    public static int LLVMAtomicRMWBinOpMax() {
        return LLVMAtomicRMWBinOpMax;
    }
    private static final int LLVMAtomicRMWBinOpMin = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpMin = 8
     * }
     */
    public static int LLVMAtomicRMWBinOpMin() {
        return LLVMAtomicRMWBinOpMin;
    }
    private static final int LLVMAtomicRMWBinOpUMax = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpUMax = 9
     * }
     */
    public static int LLVMAtomicRMWBinOpUMax() {
        return LLVMAtomicRMWBinOpUMax;
    }
    private static final int LLVMAtomicRMWBinOpUMin = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpUMin = 10
     * }
     */
    public static int LLVMAtomicRMWBinOpUMin() {
        return LLVMAtomicRMWBinOpUMin;
    }
    private static final int LLVMAtomicRMWBinOpFAdd = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpFAdd = 11
     * }
     */
    public static int LLVMAtomicRMWBinOpFAdd() {
        return LLVMAtomicRMWBinOpFAdd;
    }
    private static final int LLVMAtomicRMWBinOpFSub = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpFSub = 12
     * }
     */
    public static int LLVMAtomicRMWBinOpFSub() {
        return LLVMAtomicRMWBinOpFSub;
    }
    private static final int LLVMAtomicRMWBinOpFMax = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpFMax = 13
     * }
     */
    public static int LLVMAtomicRMWBinOpFMax() {
        return LLVMAtomicRMWBinOpFMax;
    }
    private static final int LLVMAtomicRMWBinOpFMin = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpFMin = 14
     * }
     */
    public static int LLVMAtomicRMWBinOpFMin() {
        return LLVMAtomicRMWBinOpFMin;
    }
    private static final int LLVMAtomicRMWBinOpUIncWrap = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpUIncWrap = 15
     * }
     */
    public static int LLVMAtomicRMWBinOpUIncWrap() {
        return LLVMAtomicRMWBinOpUIncWrap;
    }
    private static final int LLVMAtomicRMWBinOpUDecWrap = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpUDecWrap = 16
     * }
     */
    public static int LLVMAtomicRMWBinOpUDecWrap() {
        return LLVMAtomicRMWBinOpUDecWrap;
    }
    private static final int LLVMAtomicRMWBinOpUSubCond = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpUSubCond = 17
     * }
     */
    public static int LLVMAtomicRMWBinOpUSubCond() {
        return LLVMAtomicRMWBinOpUSubCond;
    }
    private static final int LLVMAtomicRMWBinOpUSubSat = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAtomicRMWBinOpUSubSat = 18
     * }
     */
    public static int LLVMAtomicRMWBinOpUSubSat() {
        return LLVMAtomicRMWBinOpUSubSat;
    }
    private static final int LLVMDSError = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDSError = 0
     * }
     */
    public static int LLVMDSError() {
        return LLVMDSError;
    }
    private static final int LLVMDSWarning = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDSWarning = 1
     * }
     */
    public static int LLVMDSWarning() {
        return LLVMDSWarning;
    }
    private static final int LLVMDSRemark = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDSRemark = 2
     * }
     */
    public static int LLVMDSRemark() {
        return LLVMDSRemark;
    }
    private static final int LLVMDSNote = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMDSNote = 3
     * }
     */
    public static int LLVMDSNote() {
        return LLVMDSNote;
    }
    private static final int LLVMInlineAsmDialectATT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInlineAsmDialectATT = 0
     * }
     */
    public static int LLVMInlineAsmDialectATT() {
        return LLVMInlineAsmDialectATT;
    }
    private static final int LLVMInlineAsmDialectIntel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMInlineAsmDialectIntel = 1
     * }
     */
    public static int LLVMInlineAsmDialectIntel() {
        return LLVMInlineAsmDialectIntel;
    }
    private static final int LLVMModuleFlagBehaviorError = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMModuleFlagBehaviorError = 0
     * }
     */
    public static int LLVMModuleFlagBehaviorError() {
        return LLVMModuleFlagBehaviorError;
    }
    private static final int LLVMModuleFlagBehaviorWarning = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMModuleFlagBehaviorWarning = 1
     * }
     */
    public static int LLVMModuleFlagBehaviorWarning() {
        return LLVMModuleFlagBehaviorWarning;
    }
    private static final int LLVMModuleFlagBehaviorRequire = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMModuleFlagBehaviorRequire = 2
     * }
     */
    public static int LLVMModuleFlagBehaviorRequire() {
        return LLVMModuleFlagBehaviorRequire;
    }
    private static final int LLVMModuleFlagBehaviorOverride = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMModuleFlagBehaviorOverride = 3
     * }
     */
    public static int LLVMModuleFlagBehaviorOverride() {
        return LLVMModuleFlagBehaviorOverride;
    }
    private static final int LLVMModuleFlagBehaviorAppend = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMModuleFlagBehaviorAppend = 4
     * }
     */
    public static int LLVMModuleFlagBehaviorAppend() {
        return LLVMModuleFlagBehaviorAppend;
    }
    private static final int LLVMModuleFlagBehaviorAppendUnique = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMModuleFlagBehaviorAppendUnique = 5
     * }
     */
    public static int LLVMModuleFlagBehaviorAppendUnique() {
        return LLVMModuleFlagBehaviorAppendUnique;
    }
    private static final int LLVMAttributeReturnIndex = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAttributeReturnIndex = 0
     * }
     */
    public static int LLVMAttributeReturnIndex() {
        return LLVMAttributeReturnIndex;
    }
    private static final int LLVMAttributeFunctionIndex = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMAttributeFunctionIndex = -1
     * }
     */
    public static int LLVMAttributeFunctionIndex() {
        return LLVMAttributeFunctionIndex;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int LLVMAttributeIndex
     * }
     */
    public static final OfInt LLVMAttributeIndex = LLVM.C_INT;
    private static final int LLVMTailCallKindNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMTailCallKindNone = 0
     * }
     */
    public static int LLVMTailCallKindNone() {
        return LLVMTailCallKindNone;
    }
    private static final int LLVMTailCallKindTail = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMTailCallKindTail = 1
     * }
     */
    public static int LLVMTailCallKindTail() {
        return LLVMTailCallKindTail;
    }
    private static final int LLVMTailCallKindMustTail = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMTailCallKindMustTail = 2
     * }
     */
    public static int LLVMTailCallKindMustTail() {
        return LLVMTailCallKindMustTail;
    }
    private static final int LLVMTailCallKindNoTail = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMTailCallKindNoTail = 3
     * }
     */
    public static int LLVMTailCallKindNoTail() {
        return LLVMTailCallKindNoTail;
    }
    private static final int LLVMFastMathAllowReassoc = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathAllowReassoc = 1
     * }
     */
    public static int LLVMFastMathAllowReassoc() {
        return LLVMFastMathAllowReassoc;
    }
    private static final int LLVMFastMathNoNaNs = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathNoNaNs = 2
     * }
     */
    public static int LLVMFastMathNoNaNs() {
        return LLVMFastMathNoNaNs;
    }
    private static final int LLVMFastMathNoInfs = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathNoInfs = 4
     * }
     */
    public static int LLVMFastMathNoInfs() {
        return LLVMFastMathNoInfs;
    }
    private static final int LLVMFastMathNoSignedZeros = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathNoSignedZeros = 8
     * }
     */
    public static int LLVMFastMathNoSignedZeros() {
        return LLVMFastMathNoSignedZeros;
    }
    private static final int LLVMFastMathAllowReciprocal = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathAllowReciprocal = 16
     * }
     */
    public static int LLVMFastMathAllowReciprocal() {
        return LLVMFastMathAllowReciprocal;
    }
    private static final int LLVMFastMathAllowContract = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathAllowContract = 32
     * }
     */
    public static int LLVMFastMathAllowContract() {
        return LLVMFastMathAllowContract;
    }
    private static final int LLVMFastMathApproxFunc = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathApproxFunc = 64
     * }
     */
    public static int LLVMFastMathApproxFunc() {
        return LLVMFastMathApproxFunc;
    }
    private static final int LLVMFastMathNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathNone = 0
     * }
     */
    public static int LLVMFastMathNone() {
        return LLVMFastMathNone;
    }
    private static final int LLVMFastMathAll = (int)127L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMFastMathAll = 127
     * }
     */
    public static int LLVMFastMathAll() {
        return LLVMFastMathAll;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int LLVMFastMathFlags
     * }
     */
    public static final OfInt LLVMFastMathFlags = LLVM.C_INT;
    private static final int LLVMGEPFlagInBounds = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGEPFlagInBounds = 1
     * }
     */
    public static int LLVMGEPFlagInBounds() {
        return LLVMGEPFlagInBounds;
    }
    private static final int LLVMGEPFlagNUSW = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGEPFlagNUSW = 2
     * }
     */
    public static int LLVMGEPFlagNUSW() {
        return LLVMGEPFlagNUSW;
    }
    private static final int LLVMGEPFlagNUW = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LLVMGEPFlagNUW = 4
     * }
     */
    public static int LLVMGEPFlagNUW() {
        return LLVMGEPFlagNUW;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int LLVMGEPNoWrapFlags
     * }
     */
    public static final OfInt LLVMGEPNoWrapFlags = LLVM.C_INT;

    private static class LLVMShutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMShutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMShutdown()
     * }
     */
    public static FunctionDescriptor LLVMShutdown$descriptor() {
        return LLVMShutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMShutdown()
     * }
     */
    public static MethodHandle LLVMShutdown$handle() {
        return LLVMShutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMShutdown()
     * }
     */
    public static MemorySegment LLVMShutdown$address() {
        return LLVMShutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMShutdown()
     * }
     */
    public static void LLVMShutdown() {
        var mh$ = LLVMShutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMShutdown");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetVersion(unsigned int *Major, unsigned int *Minor, unsigned int *Patch)
     * }
     */
    public static FunctionDescriptor LLVMGetVersion$descriptor() {
        return LLVMGetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetVersion(unsigned int *Major, unsigned int *Minor, unsigned int *Patch)
     * }
     */
    public static MethodHandle LLVMGetVersion$handle() {
        return LLVMGetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetVersion(unsigned int *Major, unsigned int *Minor, unsigned int *Patch)
     * }
     */
    public static MemorySegment LLVMGetVersion$address() {
        return LLVMGetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetVersion(unsigned int *Major, unsigned int *Minor, unsigned int *Patch)
     * }
     */
    public static void LLVMGetVersion(MemorySegment Major, MemorySegment Minor, MemorySegment Patch) {
        var mh$ = LLVMGetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetVersion", Major, Minor, Patch);
            }
            mh$.invokeExact(Major, Minor, Patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMCreateMessage(const char *Message)
     * }
     */
    public static FunctionDescriptor LLVMCreateMessage$descriptor() {
        return LLVMCreateMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMCreateMessage(const char *Message)
     * }
     */
    public static MethodHandle LLVMCreateMessage$handle() {
        return LLVMCreateMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMCreateMessage(const char *Message)
     * }
     */
    public static MemorySegment LLVMCreateMessage$address() {
        return LLVMCreateMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMCreateMessage(const char *Message)
     * }
     */
    public static MemorySegment LLVMCreateMessage(MemorySegment Message) {
        var mh$ = LLVMCreateMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMessage", Message);
            }
            return (MemorySegment)mh$.invokeExact(Message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeMessage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeMessage(char *Message)
     * }
     */
    public static FunctionDescriptor LLVMDisposeMessage$descriptor() {
        return LLVMDisposeMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeMessage(char *Message)
     * }
     */
    public static MethodHandle LLVMDisposeMessage$handle() {
        return LLVMDisposeMessage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeMessage(char *Message)
     * }
     */
    public static MemorySegment LLVMDisposeMessage$address() {
        return LLVMDisposeMessage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeMessage(char *Message)
     * }
     */
    public static void LLVMDisposeMessage(MemorySegment Message) {
        var mh$ = LLVMDisposeMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeMessage", Message);
            }
            mh$.invokeExact(Message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMContextCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMContextCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMContextCreate()
     * }
     */
    public static FunctionDescriptor LLVMContextCreate$descriptor() {
        return LLVMContextCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMContextCreate()
     * }
     */
    public static MethodHandle LLVMContextCreate$handle() {
        return LLVMContextCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMContextCreate()
     * }
     */
    public static MemorySegment LLVMContextCreate$address() {
        return LLVMContextCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMContextRef LLVMContextCreate()
     * }
     */
    public static MemorySegment LLVMContextCreate() {
        var mh$ = LLVMContextCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMContextCreate");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetGlobalContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetGlobalContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetGlobalContext()
     * }
     */
    public static FunctionDescriptor LLVMGetGlobalContext$descriptor() {
        return LLVMGetGlobalContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetGlobalContext()
     * }
     */
    public static MethodHandle LLVMGetGlobalContext$handle() {
        return LLVMGetGlobalContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetGlobalContext()
     * }
     */
    public static MemorySegment LLVMGetGlobalContext$address() {
        return LLVMGetGlobalContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetGlobalContext()
     * }
     */
    public static MemorySegment LLVMGetGlobalContext() {
        var mh$ = LLVMGetGlobalContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetGlobalContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMContextSetDiagnosticHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMContextSetDiagnosticHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMContextSetDiagnosticHandler(LLVMContextRef C, LLVMDiagnosticHandler Handler, void *DiagnosticContext)
     * }
     */
    public static FunctionDescriptor LLVMContextSetDiagnosticHandler$descriptor() {
        return LLVMContextSetDiagnosticHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMContextSetDiagnosticHandler(LLVMContextRef C, LLVMDiagnosticHandler Handler, void *DiagnosticContext)
     * }
     */
    public static MethodHandle LLVMContextSetDiagnosticHandler$handle() {
        return LLVMContextSetDiagnosticHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMContextSetDiagnosticHandler(LLVMContextRef C, LLVMDiagnosticHandler Handler, void *DiagnosticContext)
     * }
     */
    public static MemorySegment LLVMContextSetDiagnosticHandler$address() {
        return LLVMContextSetDiagnosticHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMContextSetDiagnosticHandler(LLVMContextRef C, LLVMDiagnosticHandler Handler, void *DiagnosticContext)
     * }
     */
    public static void LLVMContextSetDiagnosticHandler(MemorySegment C, MemorySegment Handler, MemorySegment DiagnosticContext) {
        var mh$ = LLVMContextSetDiagnosticHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMContextSetDiagnosticHandler", C, Handler, DiagnosticContext);
            }
            mh$.invokeExact(C, Handler, DiagnosticContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMContextGetDiagnosticHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMContextGetDiagnosticHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDiagnosticHandler LLVMContextGetDiagnosticHandler(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMContextGetDiagnosticHandler$descriptor() {
        return LLVMContextGetDiagnosticHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDiagnosticHandler LLVMContextGetDiagnosticHandler(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMContextGetDiagnosticHandler$handle() {
        return LLVMContextGetDiagnosticHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDiagnosticHandler LLVMContextGetDiagnosticHandler(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMContextGetDiagnosticHandler$address() {
        return LLVMContextGetDiagnosticHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDiagnosticHandler LLVMContextGetDiagnosticHandler(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMContextGetDiagnosticHandler(MemorySegment C) {
        var mh$ = LLVMContextGetDiagnosticHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMContextGetDiagnosticHandler", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMContextGetDiagnosticContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMContextGetDiagnosticContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *LLVMContextGetDiagnosticContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMContextGetDiagnosticContext$descriptor() {
        return LLVMContextGetDiagnosticContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *LLVMContextGetDiagnosticContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMContextGetDiagnosticContext$handle() {
        return LLVMContextGetDiagnosticContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *LLVMContextGetDiagnosticContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMContextGetDiagnosticContext$address() {
        return LLVMContextGetDiagnosticContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *LLVMContextGetDiagnosticContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMContextGetDiagnosticContext(MemorySegment C) {
        var mh$ = LLVMContextGetDiagnosticContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMContextGetDiagnosticContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMContextSetYieldCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMContextSetYieldCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMContextSetYieldCallback(LLVMContextRef C, LLVMYieldCallback Callback, void *OpaqueHandle)
     * }
     */
    public static FunctionDescriptor LLVMContextSetYieldCallback$descriptor() {
        return LLVMContextSetYieldCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMContextSetYieldCallback(LLVMContextRef C, LLVMYieldCallback Callback, void *OpaqueHandle)
     * }
     */
    public static MethodHandle LLVMContextSetYieldCallback$handle() {
        return LLVMContextSetYieldCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMContextSetYieldCallback(LLVMContextRef C, LLVMYieldCallback Callback, void *OpaqueHandle)
     * }
     */
    public static MemorySegment LLVMContextSetYieldCallback$address() {
        return LLVMContextSetYieldCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMContextSetYieldCallback(LLVMContextRef C, LLVMYieldCallback Callback, void *OpaqueHandle)
     * }
     */
    public static void LLVMContextSetYieldCallback(MemorySegment C, MemorySegment Callback, MemorySegment OpaqueHandle) {
        var mh$ = LLVMContextSetYieldCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMContextSetYieldCallback", C, Callback, OpaqueHandle);
            }
            mh$.invokeExact(C, Callback, OpaqueHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMContextShouldDiscardValueNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMContextShouldDiscardValueNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMContextShouldDiscardValueNames(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMContextShouldDiscardValueNames$descriptor() {
        return LLVMContextShouldDiscardValueNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMContextShouldDiscardValueNames(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMContextShouldDiscardValueNames$handle() {
        return LLVMContextShouldDiscardValueNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMContextShouldDiscardValueNames(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMContextShouldDiscardValueNames$address() {
        return LLVMContextShouldDiscardValueNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMContextShouldDiscardValueNames(LLVMContextRef C)
     * }
     */
    public static int LLVMContextShouldDiscardValueNames(MemorySegment C) {
        var mh$ = LLVMContextShouldDiscardValueNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMContextShouldDiscardValueNames", C);
            }
            return (int)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMContextSetDiscardValueNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMContextSetDiscardValueNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMContextSetDiscardValueNames(LLVMContextRef C, LLVMBool Discard)
     * }
     */
    public static FunctionDescriptor LLVMContextSetDiscardValueNames$descriptor() {
        return LLVMContextSetDiscardValueNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMContextSetDiscardValueNames(LLVMContextRef C, LLVMBool Discard)
     * }
     */
    public static MethodHandle LLVMContextSetDiscardValueNames$handle() {
        return LLVMContextSetDiscardValueNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMContextSetDiscardValueNames(LLVMContextRef C, LLVMBool Discard)
     * }
     */
    public static MemorySegment LLVMContextSetDiscardValueNames$address() {
        return LLVMContextSetDiscardValueNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMContextSetDiscardValueNames(LLVMContextRef C, LLVMBool Discard)
     * }
     */
    public static void LLVMContextSetDiscardValueNames(MemorySegment C, int Discard) {
        var mh$ = LLVMContextSetDiscardValueNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMContextSetDiscardValueNames", C, Discard);
            }
            mh$.invokeExact(C, Discard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMContextDispose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMContextDispose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMContextDispose(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMContextDispose$descriptor() {
        return LLVMContextDispose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMContextDispose(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMContextDispose$handle() {
        return LLVMContextDispose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMContextDispose(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMContextDispose$address() {
        return LLVMContextDispose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMContextDispose(LLVMContextRef C)
     * }
     */
    public static void LLVMContextDispose(MemorySegment C) {
        var mh$ = LLVMContextDispose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMContextDispose", C);
            }
            mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDiagInfoDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDiagInfoDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMGetDiagInfoDescription(LLVMDiagnosticInfoRef DI)
     * }
     */
    public static FunctionDescriptor LLVMGetDiagInfoDescription$descriptor() {
        return LLVMGetDiagInfoDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMGetDiagInfoDescription(LLVMDiagnosticInfoRef DI)
     * }
     */
    public static MethodHandle LLVMGetDiagInfoDescription$handle() {
        return LLVMGetDiagInfoDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMGetDiagInfoDescription(LLVMDiagnosticInfoRef DI)
     * }
     */
    public static MemorySegment LLVMGetDiagInfoDescription$address() {
        return LLVMGetDiagInfoDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMGetDiagInfoDescription(LLVMDiagnosticInfoRef DI)
     * }
     */
    public static MemorySegment LLVMGetDiagInfoDescription(MemorySegment DI) {
        var mh$ = LLVMGetDiagInfoDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDiagInfoDescription", DI);
            }
            return (MemorySegment)mh$.invokeExact(DI);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDiagInfoSeverity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDiagInfoSeverity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDiagnosticSeverity LLVMGetDiagInfoSeverity(LLVMDiagnosticInfoRef DI)
     * }
     */
    public static FunctionDescriptor LLVMGetDiagInfoSeverity$descriptor() {
        return LLVMGetDiagInfoSeverity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDiagnosticSeverity LLVMGetDiagInfoSeverity(LLVMDiagnosticInfoRef DI)
     * }
     */
    public static MethodHandle LLVMGetDiagInfoSeverity$handle() {
        return LLVMGetDiagInfoSeverity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDiagnosticSeverity LLVMGetDiagInfoSeverity(LLVMDiagnosticInfoRef DI)
     * }
     */
    public static MemorySegment LLVMGetDiagInfoSeverity$address() {
        return LLVMGetDiagInfoSeverity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDiagnosticSeverity LLVMGetDiagInfoSeverity(LLVMDiagnosticInfoRef DI)
     * }
     */
    public static int LLVMGetDiagInfoSeverity(MemorySegment DI) {
        var mh$ = LLVMGetDiagInfoSeverity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDiagInfoSeverity", DI);
            }
            return (int)mh$.invokeExact(DI);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMDKindIDInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMDKindIDInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDKindIDInContext(LLVMContextRef C, const char *Name, unsigned int SLen)
     * }
     */
    public static FunctionDescriptor LLVMGetMDKindIDInContext$descriptor() {
        return LLVMGetMDKindIDInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDKindIDInContext(LLVMContextRef C, const char *Name, unsigned int SLen)
     * }
     */
    public static MethodHandle LLVMGetMDKindIDInContext$handle() {
        return LLVMGetMDKindIDInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDKindIDInContext(LLVMContextRef C, const char *Name, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMGetMDKindIDInContext$address() {
        return LLVMGetMDKindIDInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetMDKindIDInContext(LLVMContextRef C, const char *Name, unsigned int SLen)
     * }
     */
    public static int LLVMGetMDKindIDInContext(MemorySegment C, MemorySegment Name, int SLen) {
        var mh$ = LLVMGetMDKindIDInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMDKindIDInContext", C, Name, SLen);
            }
            return (int)mh$.invokeExact(C, Name, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMDKindID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMDKindID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDKindID(const char *Name, unsigned int SLen)
     * }
     */
    public static FunctionDescriptor LLVMGetMDKindID$descriptor() {
        return LLVMGetMDKindID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDKindID(const char *Name, unsigned int SLen)
     * }
     */
    public static MethodHandle LLVMGetMDKindID$handle() {
        return LLVMGetMDKindID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDKindID(const char *Name, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMGetMDKindID$address() {
        return LLVMGetMDKindID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetMDKindID(const char *Name, unsigned int SLen)
     * }
     */
    public static int LLVMGetMDKindID(MemorySegment Name, int SLen) {
        var mh$ = LLVMGetMDKindID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMDKindID", Name, SLen);
            }
            return (int)mh$.invokeExact(Name, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetSyncScopeID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetSyncScopeID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetSyncScopeID(LLVMContextRef C, const char *Name, size_t SLen)
     * }
     */
    public static FunctionDescriptor LLVMGetSyncScopeID$descriptor() {
        return LLVMGetSyncScopeID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetSyncScopeID(LLVMContextRef C, const char *Name, size_t SLen)
     * }
     */
    public static MethodHandle LLVMGetSyncScopeID$handle() {
        return LLVMGetSyncScopeID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetSyncScopeID(LLVMContextRef C, const char *Name, size_t SLen)
     * }
     */
    public static MemorySegment LLVMGetSyncScopeID$address() {
        return LLVMGetSyncScopeID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetSyncScopeID(LLVMContextRef C, const char *Name, size_t SLen)
     * }
     */
    public static int LLVMGetSyncScopeID(MemorySegment C, MemorySegment Name, long SLen) {
        var mh$ = LLVMGetSyncScopeID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetSyncScopeID", C, Name, SLen);
            }
            return (int)mh$.invokeExact(C, Name, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetEnumAttributeKindForName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetEnumAttributeKindForName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetEnumAttributeKindForName(const char *Name, size_t SLen)
     * }
     */
    public static FunctionDescriptor LLVMGetEnumAttributeKindForName$descriptor() {
        return LLVMGetEnumAttributeKindForName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetEnumAttributeKindForName(const char *Name, size_t SLen)
     * }
     */
    public static MethodHandle LLVMGetEnumAttributeKindForName$handle() {
        return LLVMGetEnumAttributeKindForName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetEnumAttributeKindForName(const char *Name, size_t SLen)
     * }
     */
    public static MemorySegment LLVMGetEnumAttributeKindForName$address() {
        return LLVMGetEnumAttributeKindForName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetEnumAttributeKindForName(const char *Name, size_t SLen)
     * }
     */
    public static int LLVMGetEnumAttributeKindForName(MemorySegment Name, long SLen) {
        var mh$ = LLVMGetEnumAttributeKindForName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetEnumAttributeKindForName", Name, SLen);
            }
            return (int)mh$.invokeExact(Name, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastEnumAttributeKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastEnumAttributeKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetLastEnumAttributeKind()
     * }
     */
    public static FunctionDescriptor LLVMGetLastEnumAttributeKind$descriptor() {
        return LLVMGetLastEnumAttributeKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetLastEnumAttributeKind()
     * }
     */
    public static MethodHandle LLVMGetLastEnumAttributeKind$handle() {
        return LLVMGetLastEnumAttributeKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetLastEnumAttributeKind()
     * }
     */
    public static MemorySegment LLVMGetLastEnumAttributeKind$address() {
        return LLVMGetLastEnumAttributeKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetLastEnumAttributeKind()
     * }
     */
    public static int LLVMGetLastEnumAttributeKind() {
        var mh$ = LLVMGetLastEnumAttributeKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastEnumAttributeKind");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateEnumAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateEnumAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateEnumAttribute(LLVMContextRef C, unsigned int KindID, uint64_t Val)
     * }
     */
    public static FunctionDescriptor LLVMCreateEnumAttribute$descriptor() {
        return LLVMCreateEnumAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateEnumAttribute(LLVMContextRef C, unsigned int KindID, uint64_t Val)
     * }
     */
    public static MethodHandle LLVMCreateEnumAttribute$handle() {
        return LLVMCreateEnumAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateEnumAttribute(LLVMContextRef C, unsigned int KindID, uint64_t Val)
     * }
     */
    public static MemorySegment LLVMCreateEnumAttribute$address() {
        return LLVMCreateEnumAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateEnumAttribute(LLVMContextRef C, unsigned int KindID, uint64_t Val)
     * }
     */
    public static MemorySegment LLVMCreateEnumAttribute(MemorySegment C, int KindID, long Val) {
        var mh$ = LLVMCreateEnumAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateEnumAttribute", C, KindID, Val);
            }
            return (MemorySegment)mh$.invokeExact(C, KindID, Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetEnumAttributeKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetEnumAttributeKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetEnumAttributeKind(LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMGetEnumAttributeKind$descriptor() {
        return LLVMGetEnumAttributeKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetEnumAttributeKind(LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMGetEnumAttributeKind$handle() {
        return LLVMGetEnumAttributeKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetEnumAttributeKind(LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMGetEnumAttributeKind$address() {
        return LLVMGetEnumAttributeKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetEnumAttributeKind(LLVMAttributeRef A)
     * }
     */
    public static int LLVMGetEnumAttributeKind(MemorySegment A) {
        var mh$ = LLVMGetEnumAttributeKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetEnumAttributeKind", A);
            }
            return (int)mh$.invokeExact(A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetEnumAttributeValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetEnumAttributeValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t LLVMGetEnumAttributeValue(LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMGetEnumAttributeValue$descriptor() {
        return LLVMGetEnumAttributeValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t LLVMGetEnumAttributeValue(LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMGetEnumAttributeValue$handle() {
        return LLVMGetEnumAttributeValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t LLVMGetEnumAttributeValue(LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMGetEnumAttributeValue$address() {
        return LLVMGetEnumAttributeValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t LLVMGetEnumAttributeValue(LLVMAttributeRef A)
     * }
     */
    public static long LLVMGetEnumAttributeValue(MemorySegment A) {
        var mh$ = LLVMGetEnumAttributeValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetEnumAttributeValue", A);
            }
            return (long)mh$.invokeExact(A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateTypeAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateTypeAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateTypeAttribute(LLVMContextRef C, unsigned int KindID, LLVMTypeRef type_ref)
     * }
     */
    public static FunctionDescriptor LLVMCreateTypeAttribute$descriptor() {
        return LLVMCreateTypeAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateTypeAttribute(LLVMContextRef C, unsigned int KindID, LLVMTypeRef type_ref)
     * }
     */
    public static MethodHandle LLVMCreateTypeAttribute$handle() {
        return LLVMCreateTypeAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateTypeAttribute(LLVMContextRef C, unsigned int KindID, LLVMTypeRef type_ref)
     * }
     */
    public static MemorySegment LLVMCreateTypeAttribute$address() {
        return LLVMCreateTypeAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateTypeAttribute(LLVMContextRef C, unsigned int KindID, LLVMTypeRef type_ref)
     * }
     */
    public static MemorySegment LLVMCreateTypeAttribute(MemorySegment C, int KindID, MemorySegment type_ref) {
        var mh$ = LLVMCreateTypeAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateTypeAttribute", C, KindID, type_ref);
            }
            return (MemorySegment)mh$.invokeExact(C, KindID, type_ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTypeAttributeValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTypeAttributeValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeAttributeValue(LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMGetTypeAttributeValue$descriptor() {
        return LLVMGetTypeAttributeValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeAttributeValue(LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMGetTypeAttributeValue$handle() {
        return LLVMGetTypeAttributeValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeAttributeValue(LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMGetTypeAttributeValue$address() {
        return LLVMGetTypeAttributeValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeAttributeValue(LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMGetTypeAttributeValue(MemorySegment A) {
        var mh$ = LLVMGetTypeAttributeValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTypeAttributeValue", A);
            }
            return (MemorySegment)mh$.invokeExact(A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateConstantRangeAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateConstantRangeAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateConstantRangeAttribute(LLVMContextRef C, unsigned int KindID, unsigned int NumBits, const uint64_t LowerWords[], const uint64_t UpperWords[])
     * }
     */
    public static FunctionDescriptor LLVMCreateConstantRangeAttribute$descriptor() {
        return LLVMCreateConstantRangeAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateConstantRangeAttribute(LLVMContextRef C, unsigned int KindID, unsigned int NumBits, const uint64_t LowerWords[], const uint64_t UpperWords[])
     * }
     */
    public static MethodHandle LLVMCreateConstantRangeAttribute$handle() {
        return LLVMCreateConstantRangeAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateConstantRangeAttribute(LLVMContextRef C, unsigned int KindID, unsigned int NumBits, const uint64_t LowerWords[], const uint64_t UpperWords[])
     * }
     */
    public static MemorySegment LLVMCreateConstantRangeAttribute$address() {
        return LLVMCreateConstantRangeAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateConstantRangeAttribute(LLVMContextRef C, unsigned int KindID, unsigned int NumBits, const uint64_t LowerWords[], const uint64_t UpperWords[])
     * }
     */
    public static MemorySegment LLVMCreateConstantRangeAttribute(MemorySegment C, int KindID, int NumBits, MemorySegment LowerWords, MemorySegment UpperWords) {
        var mh$ = LLVMCreateConstantRangeAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateConstantRangeAttribute", C, KindID, NumBits, LowerWords, UpperWords);
            }
            return (MemorySegment)mh$.invokeExact(C, KindID, NumBits, LowerWords, UpperWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateStringAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateStringAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateStringAttribute(LLVMContextRef C, const char *K, unsigned int KLength, const char *V, unsigned int VLength)
     * }
     */
    public static FunctionDescriptor LLVMCreateStringAttribute$descriptor() {
        return LLVMCreateStringAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateStringAttribute(LLVMContextRef C, const char *K, unsigned int KLength, const char *V, unsigned int VLength)
     * }
     */
    public static MethodHandle LLVMCreateStringAttribute$handle() {
        return LLVMCreateStringAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateStringAttribute(LLVMContextRef C, const char *K, unsigned int KLength, const char *V, unsigned int VLength)
     * }
     */
    public static MemorySegment LLVMCreateStringAttribute$address() {
        return LLVMCreateStringAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMCreateStringAttribute(LLVMContextRef C, const char *K, unsigned int KLength, const char *V, unsigned int VLength)
     * }
     */
    public static MemorySegment LLVMCreateStringAttribute(MemorySegment C, MemorySegment K, int KLength, MemorySegment V, int VLength) {
        var mh$ = LLVMCreateStringAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateStringAttribute", C, K, KLength, V, VLength);
            }
            return (MemorySegment)mh$.invokeExact(C, K, KLength, V, VLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetStringAttributeKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetStringAttributeKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetStringAttributeKind(LLVMAttributeRef A, unsigned int *Length)
     * }
     */
    public static FunctionDescriptor LLVMGetStringAttributeKind$descriptor() {
        return LLVMGetStringAttributeKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetStringAttributeKind(LLVMAttributeRef A, unsigned int *Length)
     * }
     */
    public static MethodHandle LLVMGetStringAttributeKind$handle() {
        return LLVMGetStringAttributeKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetStringAttributeKind(LLVMAttributeRef A, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetStringAttributeKind$address() {
        return LLVMGetStringAttributeKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetStringAttributeKind(LLVMAttributeRef A, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetStringAttributeKind(MemorySegment A, MemorySegment Length) {
        var mh$ = LLVMGetStringAttributeKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetStringAttributeKind", A, Length);
            }
            return (MemorySegment)mh$.invokeExact(A, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetStringAttributeValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetStringAttributeValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetStringAttributeValue(LLVMAttributeRef A, unsigned int *Length)
     * }
     */
    public static FunctionDescriptor LLVMGetStringAttributeValue$descriptor() {
        return LLVMGetStringAttributeValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetStringAttributeValue(LLVMAttributeRef A, unsigned int *Length)
     * }
     */
    public static MethodHandle LLVMGetStringAttributeValue$handle() {
        return LLVMGetStringAttributeValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetStringAttributeValue(LLVMAttributeRef A, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetStringAttributeValue$address() {
        return LLVMGetStringAttributeValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetStringAttributeValue(LLVMAttributeRef A, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetStringAttributeValue(MemorySegment A, MemorySegment Length) {
        var mh$ = LLVMGetStringAttributeValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetStringAttributeValue", A, Length);
            }
            return (MemorySegment)mh$.invokeExact(A, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsEnumAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsEnumAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsEnumAttribute(LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMIsEnumAttribute$descriptor() {
        return LLVMIsEnumAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsEnumAttribute(LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMIsEnumAttribute$handle() {
        return LLVMIsEnumAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsEnumAttribute(LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMIsEnumAttribute$address() {
        return LLVMIsEnumAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsEnumAttribute(LLVMAttributeRef A)
     * }
     */
    public static int LLVMIsEnumAttribute(MemorySegment A) {
        var mh$ = LLVMIsEnumAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsEnumAttribute", A);
            }
            return (int)mh$.invokeExact(A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsStringAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsStringAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsStringAttribute(LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMIsStringAttribute$descriptor() {
        return LLVMIsStringAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsStringAttribute(LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMIsStringAttribute$handle() {
        return LLVMIsStringAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsStringAttribute(LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMIsStringAttribute$address() {
        return LLVMIsStringAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsStringAttribute(LLVMAttributeRef A)
     * }
     */
    public static int LLVMIsStringAttribute(MemorySegment A) {
        var mh$ = LLVMIsStringAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsStringAttribute", A);
            }
            return (int)mh$.invokeExact(A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsTypeAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsTypeAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTypeAttribute(LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMIsTypeAttribute$descriptor() {
        return LLVMIsTypeAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTypeAttribute(LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMIsTypeAttribute$handle() {
        return LLVMIsTypeAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTypeAttribute(LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMIsTypeAttribute$address() {
        return LLVMIsTypeAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsTypeAttribute(LLVMAttributeRef A)
     * }
     */
    public static int LLVMIsTypeAttribute(MemorySegment A) {
        var mh$ = LLVMIsTypeAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsTypeAttribute", A);
            }
            return (int)mh$.invokeExact(A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTypeByName2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTypeByName2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeByName2(LLVMContextRef C, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMGetTypeByName2$descriptor() {
        return LLVMGetTypeByName2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeByName2(LLVMContextRef C, const char *Name)
     * }
     */
    public static MethodHandle LLVMGetTypeByName2$handle() {
        return LLVMGetTypeByName2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeByName2(LLVMContextRef C, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetTypeByName2$address() {
        return LLVMGetTypeByName2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeByName2(LLVMContextRef C, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetTypeByName2(MemorySegment C, MemorySegment Name) {
        var mh$ = LLVMGetTypeByName2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTypeByName2", C, Name);
            }
            return (MemorySegment)mh$.invokeExact(C, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMModuleCreateWithName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMModuleCreateWithName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMModuleCreateWithName(const char *ModuleID)
     * }
     */
    public static FunctionDescriptor LLVMModuleCreateWithName$descriptor() {
        return LLVMModuleCreateWithName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMModuleCreateWithName(const char *ModuleID)
     * }
     */
    public static MethodHandle LLVMModuleCreateWithName$handle() {
        return LLVMModuleCreateWithName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMModuleCreateWithName(const char *ModuleID)
     * }
     */
    public static MemorySegment LLVMModuleCreateWithName$address() {
        return LLVMModuleCreateWithName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMModuleRef LLVMModuleCreateWithName(const char *ModuleID)
     * }
     */
    public static MemorySegment LLVMModuleCreateWithName(MemorySegment ModuleID) {
        var mh$ = LLVMModuleCreateWithName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMModuleCreateWithName", ModuleID);
            }
            return (MemorySegment)mh$.invokeExact(ModuleID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMModuleCreateWithNameInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMModuleCreateWithNameInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMModuleCreateWithNameInContext(const char *ModuleID, LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMModuleCreateWithNameInContext$descriptor() {
        return LLVMModuleCreateWithNameInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMModuleCreateWithNameInContext(const char *ModuleID, LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMModuleCreateWithNameInContext$handle() {
        return LLVMModuleCreateWithNameInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMModuleCreateWithNameInContext(const char *ModuleID, LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMModuleCreateWithNameInContext$address() {
        return LLVMModuleCreateWithNameInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMModuleRef LLVMModuleCreateWithNameInContext(const char *ModuleID, LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMModuleCreateWithNameInContext(MemorySegment ModuleID, MemorySegment C) {
        var mh$ = LLVMModuleCreateWithNameInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMModuleCreateWithNameInContext", ModuleID, C);
            }
            return (MemorySegment)mh$.invokeExact(ModuleID, C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCloneModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCloneModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMCloneModule(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMCloneModule$descriptor() {
        return LLVMCloneModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMCloneModule(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMCloneModule$handle() {
        return LLVMCloneModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMCloneModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCloneModule$address() {
        return LLVMCloneModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMModuleRef LLVMCloneModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCloneModule(MemorySegment M) {
        var mh$ = LLVMCloneModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCloneModule", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeModule(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMDisposeModule$descriptor() {
        return LLVMDisposeModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeModule(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMDisposeModule$handle() {
        return LLVMDisposeModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMDisposeModule$address() {
        return LLVMDisposeModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeModule(LLVMModuleRef M)
     * }
     */
    public static void LLVMDisposeModule(MemorySegment M) {
        var mh$ = LLVMDisposeModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeModule", M);
            }
            mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsNewDbgInfoFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsNewDbgInfoFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsNewDbgInfoFormat(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMIsNewDbgInfoFormat$descriptor() {
        return LLVMIsNewDbgInfoFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsNewDbgInfoFormat(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMIsNewDbgInfoFormat$handle() {
        return LLVMIsNewDbgInfoFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsNewDbgInfoFormat(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMIsNewDbgInfoFormat$address() {
        return LLVMIsNewDbgInfoFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsNewDbgInfoFormat(LLVMModuleRef M)
     * }
     */
    public static int LLVMIsNewDbgInfoFormat(MemorySegment M) {
        var mh$ = LLVMIsNewDbgInfoFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsNewDbgInfoFormat", M);
            }
            return (int)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetIsNewDbgInfoFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetIsNewDbgInfoFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetIsNewDbgInfoFormat(LLVMModuleRef M, LLVMBool UseNewFormat)
     * }
     */
    public static FunctionDescriptor LLVMSetIsNewDbgInfoFormat$descriptor() {
        return LLVMSetIsNewDbgInfoFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetIsNewDbgInfoFormat(LLVMModuleRef M, LLVMBool UseNewFormat)
     * }
     */
    public static MethodHandle LLVMSetIsNewDbgInfoFormat$handle() {
        return LLVMSetIsNewDbgInfoFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetIsNewDbgInfoFormat(LLVMModuleRef M, LLVMBool UseNewFormat)
     * }
     */
    public static MemorySegment LLVMSetIsNewDbgInfoFormat$address() {
        return LLVMSetIsNewDbgInfoFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetIsNewDbgInfoFormat(LLVMModuleRef M, LLVMBool UseNewFormat)
     * }
     */
    public static void LLVMSetIsNewDbgInfoFormat(MemorySegment M, int UseNewFormat) {
        var mh$ = LLVMSetIsNewDbgInfoFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetIsNewDbgInfoFormat", M, UseNewFormat);
            }
            mh$.invokeExact(M, UseNewFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetModuleIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetModuleIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetModuleIdentifier(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMGetModuleIdentifier$descriptor() {
        return LLVMGetModuleIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetModuleIdentifier(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MethodHandle LLVMGetModuleIdentifier$handle() {
        return LLVMGetModuleIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetModuleIdentifier(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetModuleIdentifier$address() {
        return LLVMGetModuleIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetModuleIdentifier(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetModuleIdentifier(MemorySegment M, MemorySegment Len) {
        var mh$ = LLVMGetModuleIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetModuleIdentifier", M, Len);
            }
            return (MemorySegment)mh$.invokeExact(M, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetModuleIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetModuleIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetModuleIdentifier(LLVMModuleRef M, const char *Ident, size_t Len)
     * }
     */
    public static FunctionDescriptor LLVMSetModuleIdentifier$descriptor() {
        return LLVMSetModuleIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetModuleIdentifier(LLVMModuleRef M, const char *Ident, size_t Len)
     * }
     */
    public static MethodHandle LLVMSetModuleIdentifier$handle() {
        return LLVMSetModuleIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetModuleIdentifier(LLVMModuleRef M, const char *Ident, size_t Len)
     * }
     */
    public static MemorySegment LLVMSetModuleIdentifier$address() {
        return LLVMSetModuleIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetModuleIdentifier(LLVMModuleRef M, const char *Ident, size_t Len)
     * }
     */
    public static void LLVMSetModuleIdentifier(MemorySegment M, MemorySegment Ident, long Len) {
        var mh$ = LLVMSetModuleIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetModuleIdentifier", M, Ident, Len);
            }
            mh$.invokeExact(M, Ident, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetSourceFileName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetSourceFileName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetSourceFileName(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMGetSourceFileName$descriptor() {
        return LLVMGetSourceFileName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetSourceFileName(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MethodHandle LLVMGetSourceFileName$handle() {
        return LLVMGetSourceFileName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetSourceFileName(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetSourceFileName$address() {
        return LLVMGetSourceFileName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetSourceFileName(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetSourceFileName(MemorySegment M, MemorySegment Len) {
        var mh$ = LLVMGetSourceFileName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetSourceFileName", M, Len);
            }
            return (MemorySegment)mh$.invokeExact(M, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetSourceFileName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetSourceFileName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetSourceFileName(LLVMModuleRef M, const char *Name, size_t Len)
     * }
     */
    public static FunctionDescriptor LLVMSetSourceFileName$descriptor() {
        return LLVMSetSourceFileName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetSourceFileName(LLVMModuleRef M, const char *Name, size_t Len)
     * }
     */
    public static MethodHandle LLVMSetSourceFileName$handle() {
        return LLVMSetSourceFileName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetSourceFileName(LLVMModuleRef M, const char *Name, size_t Len)
     * }
     */
    public static MemorySegment LLVMSetSourceFileName$address() {
        return LLVMSetSourceFileName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetSourceFileName(LLVMModuleRef M, const char *Name, size_t Len)
     * }
     */
    public static void LLVMSetSourceFileName(MemorySegment M, MemorySegment Name, long Len) {
        var mh$ = LLVMSetSourceFileName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetSourceFileName", M, Name, Len);
            }
            mh$.invokeExact(M, Name, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDataLayoutStr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDataLayoutStr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetDataLayoutStr(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetDataLayoutStr$descriptor() {
        return LLVMGetDataLayoutStr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetDataLayoutStr(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetDataLayoutStr$handle() {
        return LLVMGetDataLayoutStr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetDataLayoutStr(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetDataLayoutStr$address() {
        return LLVMGetDataLayoutStr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetDataLayoutStr(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetDataLayoutStr(MemorySegment M) {
        var mh$ = LLVMGetDataLayoutStr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDataLayoutStr", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDataLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDataLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetDataLayout(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetDataLayout$descriptor() {
        return LLVMGetDataLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetDataLayout(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetDataLayout$handle() {
        return LLVMGetDataLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetDataLayout(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetDataLayout$address() {
        return LLVMGetDataLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetDataLayout(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetDataLayout(MemorySegment M) {
        var mh$ = LLVMGetDataLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDataLayout", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetDataLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetDataLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetDataLayout(LLVMModuleRef M, const char *DataLayoutStr)
     * }
     */
    public static FunctionDescriptor LLVMSetDataLayout$descriptor() {
        return LLVMSetDataLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetDataLayout(LLVMModuleRef M, const char *DataLayoutStr)
     * }
     */
    public static MethodHandle LLVMSetDataLayout$handle() {
        return LLVMSetDataLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetDataLayout(LLVMModuleRef M, const char *DataLayoutStr)
     * }
     */
    public static MemorySegment LLVMSetDataLayout$address() {
        return LLVMSetDataLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetDataLayout(LLVMModuleRef M, const char *DataLayoutStr)
     * }
     */
    public static void LLVMSetDataLayout(MemorySegment M, MemorySegment DataLayoutStr) {
        var mh$ = LLVMSetDataLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetDataLayout", M, DataLayoutStr);
            }
            mh$.invokeExact(M, DataLayoutStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetTarget(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetTarget$descriptor() {
        return LLVMGetTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetTarget(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetTarget$handle() {
        return LLVMGetTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetTarget(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetTarget$address() {
        return LLVMGetTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetTarget(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetTarget(MemorySegment M) {
        var mh$ = LLVMGetTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTarget", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTarget(LLVMModuleRef M, const char *Triple)
     * }
     */
    public static FunctionDescriptor LLVMSetTarget$descriptor() {
        return LLVMSetTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTarget(LLVMModuleRef M, const char *Triple)
     * }
     */
    public static MethodHandle LLVMSetTarget$handle() {
        return LLVMSetTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTarget(LLVMModuleRef M, const char *Triple)
     * }
     */
    public static MemorySegment LLVMSetTarget$address() {
        return LLVMSetTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTarget(LLVMModuleRef M, const char *Triple)
     * }
     */
    public static void LLVMSetTarget(MemorySegment M, MemorySegment Triple) {
        var mh$ = LLVMSetTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTarget", M, Triple);
            }
            mh$.invokeExact(M, Triple);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCopyModuleFlagsMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCopyModuleFlagsMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMModuleFlagEntry *LLVMCopyModuleFlagsMetadata(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMCopyModuleFlagsMetadata$descriptor() {
        return LLVMCopyModuleFlagsMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMModuleFlagEntry *LLVMCopyModuleFlagsMetadata(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MethodHandle LLVMCopyModuleFlagsMetadata$handle() {
        return LLVMCopyModuleFlagsMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMModuleFlagEntry *LLVMCopyModuleFlagsMetadata(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MemorySegment LLVMCopyModuleFlagsMetadata$address() {
        return LLVMCopyModuleFlagsMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMModuleFlagEntry *LLVMCopyModuleFlagsMetadata(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MemorySegment LLVMCopyModuleFlagsMetadata(MemorySegment M, MemorySegment Len) {
        var mh$ = LLVMCopyModuleFlagsMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCopyModuleFlagsMetadata", M, Len);
            }
            return (MemorySegment)mh$.invokeExact(M, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeModuleFlagsMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeModuleFlagsMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleFlagsMetadata(LLVMModuleFlagEntry *Entries)
     * }
     */
    public static FunctionDescriptor LLVMDisposeModuleFlagsMetadata$descriptor() {
        return LLVMDisposeModuleFlagsMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleFlagsMetadata(LLVMModuleFlagEntry *Entries)
     * }
     */
    public static MethodHandle LLVMDisposeModuleFlagsMetadata$handle() {
        return LLVMDisposeModuleFlagsMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleFlagsMetadata(LLVMModuleFlagEntry *Entries)
     * }
     */
    public static MemorySegment LLVMDisposeModuleFlagsMetadata$address() {
        return LLVMDisposeModuleFlagsMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeModuleFlagsMetadata(LLVMModuleFlagEntry *Entries)
     * }
     */
    public static void LLVMDisposeModuleFlagsMetadata(MemorySegment Entries) {
        var mh$ = LLVMDisposeModuleFlagsMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeModuleFlagsMetadata", Entries);
            }
            mh$.invokeExact(Entries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMModuleFlagEntriesGetFlagBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMModuleFlagEntriesGetFlagBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMModuleFlagBehavior LLVMModuleFlagEntriesGetFlagBehavior(LLVMModuleFlagEntry *Entries, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMModuleFlagEntriesGetFlagBehavior$descriptor() {
        return LLVMModuleFlagEntriesGetFlagBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMModuleFlagBehavior LLVMModuleFlagEntriesGetFlagBehavior(LLVMModuleFlagEntry *Entries, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMModuleFlagEntriesGetFlagBehavior$handle() {
        return LLVMModuleFlagEntriesGetFlagBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMModuleFlagBehavior LLVMModuleFlagEntriesGetFlagBehavior(LLVMModuleFlagEntry *Entries, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMModuleFlagEntriesGetFlagBehavior$address() {
        return LLVMModuleFlagEntriesGetFlagBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMModuleFlagBehavior LLVMModuleFlagEntriesGetFlagBehavior(LLVMModuleFlagEntry *Entries, unsigned int Index)
     * }
     */
    public static int LLVMModuleFlagEntriesGetFlagBehavior(MemorySegment Entries, int Index) {
        var mh$ = LLVMModuleFlagEntriesGetFlagBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMModuleFlagEntriesGetFlagBehavior", Entries, Index);
            }
            return (int)mh$.invokeExact(Entries, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMModuleFlagEntriesGetKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMModuleFlagEntriesGetKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMModuleFlagEntriesGetKey(LLVMModuleFlagEntry *Entries, unsigned int Index, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMModuleFlagEntriesGetKey$descriptor() {
        return LLVMModuleFlagEntriesGetKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMModuleFlagEntriesGetKey(LLVMModuleFlagEntry *Entries, unsigned int Index, size_t *Len)
     * }
     */
    public static MethodHandle LLVMModuleFlagEntriesGetKey$handle() {
        return LLVMModuleFlagEntriesGetKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMModuleFlagEntriesGetKey(LLVMModuleFlagEntry *Entries, unsigned int Index, size_t *Len)
     * }
     */
    public static MemorySegment LLVMModuleFlagEntriesGetKey$address() {
        return LLVMModuleFlagEntriesGetKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMModuleFlagEntriesGetKey(LLVMModuleFlagEntry *Entries, unsigned int Index, size_t *Len)
     * }
     */
    public static MemorySegment LLVMModuleFlagEntriesGetKey(MemorySegment Entries, int Index, MemorySegment Len) {
        var mh$ = LLVMModuleFlagEntriesGetKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMModuleFlagEntriesGetKey", Entries, Index, Len);
            }
            return (MemorySegment)mh$.invokeExact(Entries, Index, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMModuleFlagEntriesGetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMModuleFlagEntriesGetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMModuleFlagEntriesGetMetadata(LLVMModuleFlagEntry *Entries, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMModuleFlagEntriesGetMetadata$descriptor() {
        return LLVMModuleFlagEntriesGetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMModuleFlagEntriesGetMetadata(LLVMModuleFlagEntry *Entries, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMModuleFlagEntriesGetMetadata$handle() {
        return LLVMModuleFlagEntriesGetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMModuleFlagEntriesGetMetadata(LLVMModuleFlagEntry *Entries, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMModuleFlagEntriesGetMetadata$address() {
        return LLVMModuleFlagEntriesGetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMModuleFlagEntriesGetMetadata(LLVMModuleFlagEntry *Entries, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMModuleFlagEntriesGetMetadata(MemorySegment Entries, int Index) {
        var mh$ = LLVMModuleFlagEntriesGetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMModuleFlagEntriesGetMetadata", Entries, Index);
            }
            return (MemorySegment)mh$.invokeExact(Entries, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetModuleFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetModuleFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetModuleFlag(LLVMModuleRef M, const char *Key, size_t KeyLen)
     * }
     */
    public static FunctionDescriptor LLVMGetModuleFlag$descriptor() {
        return LLVMGetModuleFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetModuleFlag(LLVMModuleRef M, const char *Key, size_t KeyLen)
     * }
     */
    public static MethodHandle LLVMGetModuleFlag$handle() {
        return LLVMGetModuleFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetModuleFlag(LLVMModuleRef M, const char *Key, size_t KeyLen)
     * }
     */
    public static MemorySegment LLVMGetModuleFlag$address() {
        return LLVMGetModuleFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetModuleFlag(LLVMModuleRef M, const char *Key, size_t KeyLen)
     * }
     */
    public static MemorySegment LLVMGetModuleFlag(MemorySegment M, MemorySegment Key, long KeyLen) {
        var mh$ = LLVMGetModuleFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetModuleFlag", M, Key, KeyLen);
            }
            return (MemorySegment)mh$.invokeExact(M, Key, KeyLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddModuleFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddModuleFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddModuleFlag(LLVMModuleRef M, LLVMModuleFlagBehavior Behavior, const char *Key, size_t KeyLen, LLVMMetadataRef Val)
     * }
     */
    public static FunctionDescriptor LLVMAddModuleFlag$descriptor() {
        return LLVMAddModuleFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddModuleFlag(LLVMModuleRef M, LLVMModuleFlagBehavior Behavior, const char *Key, size_t KeyLen, LLVMMetadataRef Val)
     * }
     */
    public static MethodHandle LLVMAddModuleFlag$handle() {
        return LLVMAddModuleFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddModuleFlag(LLVMModuleRef M, LLVMModuleFlagBehavior Behavior, const char *Key, size_t KeyLen, LLVMMetadataRef Val)
     * }
     */
    public static MemorySegment LLVMAddModuleFlag$address() {
        return LLVMAddModuleFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddModuleFlag(LLVMModuleRef M, LLVMModuleFlagBehavior Behavior, const char *Key, size_t KeyLen, LLVMMetadataRef Val)
     * }
     */
    public static void LLVMAddModuleFlag(MemorySegment M, int Behavior, MemorySegment Key, long KeyLen, MemorySegment Val) {
        var mh$ = LLVMAddModuleFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddModuleFlag", M, Behavior, Key, KeyLen, Val);
            }
            mh$.invokeExact(M, Behavior, Key, KeyLen, Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDumpModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDumpModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDumpModule(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMDumpModule$descriptor() {
        return LLVMDumpModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDumpModule(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMDumpModule$handle() {
        return LLVMDumpModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDumpModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMDumpModule$address() {
        return LLVMDumpModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDumpModule(LLVMModuleRef M)
     * }
     */
    public static void LLVMDumpModule(MemorySegment M) {
        var mh$ = LLVMDumpModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDumpModule", M);
            }
            mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPrintModuleToFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPrintModuleToFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMPrintModuleToFile(LLVMModuleRef M, const char *Filename, char **ErrorMessage)
     * }
     */
    public static FunctionDescriptor LLVMPrintModuleToFile$descriptor() {
        return LLVMPrintModuleToFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMPrintModuleToFile(LLVMModuleRef M, const char *Filename, char **ErrorMessage)
     * }
     */
    public static MethodHandle LLVMPrintModuleToFile$handle() {
        return LLVMPrintModuleToFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMPrintModuleToFile(LLVMModuleRef M, const char *Filename, char **ErrorMessage)
     * }
     */
    public static MemorySegment LLVMPrintModuleToFile$address() {
        return LLVMPrintModuleToFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMPrintModuleToFile(LLVMModuleRef M, const char *Filename, char **ErrorMessage)
     * }
     */
    public static int LLVMPrintModuleToFile(MemorySegment M, MemorySegment Filename, MemorySegment ErrorMessage) {
        var mh$ = LLVMPrintModuleToFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPrintModuleToFile", M, Filename, ErrorMessage);
            }
            return (int)mh$.invokeExact(M, Filename, ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPrintModuleToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPrintModuleToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMPrintModuleToString(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMPrintModuleToString$descriptor() {
        return LLVMPrintModuleToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMPrintModuleToString(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMPrintModuleToString$handle() {
        return LLVMPrintModuleToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMPrintModuleToString(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMPrintModuleToString$address() {
        return LLVMPrintModuleToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMPrintModuleToString(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMPrintModuleToString(MemorySegment M) {
        var mh$ = LLVMPrintModuleToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPrintModuleToString", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetModuleInlineAsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetModuleInlineAsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetModuleInlineAsm(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMGetModuleInlineAsm$descriptor() {
        return LLVMGetModuleInlineAsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetModuleInlineAsm(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MethodHandle LLVMGetModuleInlineAsm$handle() {
        return LLVMGetModuleInlineAsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetModuleInlineAsm(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetModuleInlineAsm$address() {
        return LLVMGetModuleInlineAsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetModuleInlineAsm(LLVMModuleRef M, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetModuleInlineAsm(MemorySegment M, MemorySegment Len) {
        var mh$ = LLVMGetModuleInlineAsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetModuleInlineAsm", M, Len);
            }
            return (MemorySegment)mh$.invokeExact(M, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetModuleInlineAsm2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetModuleInlineAsm2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetModuleInlineAsm2(LLVMModuleRef M, const char *Asm, size_t Len)
     * }
     */
    public static FunctionDescriptor LLVMSetModuleInlineAsm2$descriptor() {
        return LLVMSetModuleInlineAsm2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetModuleInlineAsm2(LLVMModuleRef M, const char *Asm, size_t Len)
     * }
     */
    public static MethodHandle LLVMSetModuleInlineAsm2$handle() {
        return LLVMSetModuleInlineAsm2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetModuleInlineAsm2(LLVMModuleRef M, const char *Asm, size_t Len)
     * }
     */
    public static MemorySegment LLVMSetModuleInlineAsm2$address() {
        return LLVMSetModuleInlineAsm2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetModuleInlineAsm2(LLVMModuleRef M, const char *Asm, size_t Len)
     * }
     */
    public static void LLVMSetModuleInlineAsm2(MemorySegment M, MemorySegment Asm, long Len) {
        var mh$ = LLVMSetModuleInlineAsm2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetModuleInlineAsm2", M, Asm, Len);
            }
            mh$.invokeExact(M, Asm, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAppendModuleInlineAsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAppendModuleInlineAsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm, size_t Len)
     * }
     */
    public static FunctionDescriptor LLVMAppendModuleInlineAsm$descriptor() {
        return LLVMAppendModuleInlineAsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm, size_t Len)
     * }
     */
    public static MethodHandle LLVMAppendModuleInlineAsm$handle() {
        return LLVMAppendModuleInlineAsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm, size_t Len)
     * }
     */
    public static MemorySegment LLVMAppendModuleInlineAsm$address() {
        return LLVMAppendModuleInlineAsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAppendModuleInlineAsm(LLVMModuleRef M, const char *Asm, size_t Len)
     * }
     */
    public static void LLVMAppendModuleInlineAsm(MemorySegment M, MemorySegment Asm, long Len) {
        var mh$ = LLVMAppendModuleInlineAsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAppendModuleInlineAsm", M, Asm, Len);
            }
            mh$.invokeExact(M, Asm, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInlineAsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInlineAsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetInlineAsm(LLVMTypeRef Ty, const char *AsmString, size_t AsmStringSize, const char *Constraints, size_t ConstraintsSize, LLVMBool HasSideEffects, LLVMBool IsAlignStack, LLVMInlineAsmDialect Dialect, LLVMBool CanThrow)
     * }
     */
    public static FunctionDescriptor LLVMGetInlineAsm$descriptor() {
        return LLVMGetInlineAsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetInlineAsm(LLVMTypeRef Ty, const char *AsmString, size_t AsmStringSize, const char *Constraints, size_t ConstraintsSize, LLVMBool HasSideEffects, LLVMBool IsAlignStack, LLVMInlineAsmDialect Dialect, LLVMBool CanThrow)
     * }
     */
    public static MethodHandle LLVMGetInlineAsm$handle() {
        return LLVMGetInlineAsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetInlineAsm(LLVMTypeRef Ty, const char *AsmString, size_t AsmStringSize, const char *Constraints, size_t ConstraintsSize, LLVMBool HasSideEffects, LLVMBool IsAlignStack, LLVMInlineAsmDialect Dialect, LLVMBool CanThrow)
     * }
     */
    public static MemorySegment LLVMGetInlineAsm$address() {
        return LLVMGetInlineAsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetInlineAsm(LLVMTypeRef Ty, const char *AsmString, size_t AsmStringSize, const char *Constraints, size_t ConstraintsSize, LLVMBool HasSideEffects, LLVMBool IsAlignStack, LLVMInlineAsmDialect Dialect, LLVMBool CanThrow)
     * }
     */
    public static MemorySegment LLVMGetInlineAsm(MemorySegment Ty, MemorySegment AsmString, long AsmStringSize, MemorySegment Constraints, long ConstraintsSize, int HasSideEffects, int IsAlignStack, int Dialect, int CanThrow) {
        var mh$ = LLVMGetInlineAsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInlineAsm", Ty, AsmString, AsmStringSize, Constraints, ConstraintsSize, HasSideEffects, IsAlignStack, Dialect, CanThrow);
            }
            return (MemorySegment)mh$.invokeExact(Ty, AsmString, AsmStringSize, Constraints, ConstraintsSize, HasSideEffects, IsAlignStack, Dialect, CanThrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInlineAsmAsmString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInlineAsmAsmString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetInlineAsmAsmString(LLVMValueRef InlineAsmVal, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMGetInlineAsmAsmString$descriptor() {
        return LLVMGetInlineAsmAsmString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetInlineAsmAsmString(LLVMValueRef InlineAsmVal, size_t *Len)
     * }
     */
    public static MethodHandle LLVMGetInlineAsmAsmString$handle() {
        return LLVMGetInlineAsmAsmString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetInlineAsmAsmString(LLVMValueRef InlineAsmVal, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmAsmString$address() {
        return LLVMGetInlineAsmAsmString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetInlineAsmAsmString(LLVMValueRef InlineAsmVal, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmAsmString(MemorySegment InlineAsmVal, MemorySegment Len) {
        var mh$ = LLVMGetInlineAsmAsmString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInlineAsmAsmString", InlineAsmVal, Len);
            }
            return (MemorySegment)mh$.invokeExact(InlineAsmVal, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInlineAsmConstraintString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInlineAsmConstraintString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetInlineAsmConstraintString(LLVMValueRef InlineAsmVal, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMGetInlineAsmConstraintString$descriptor() {
        return LLVMGetInlineAsmConstraintString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetInlineAsmConstraintString(LLVMValueRef InlineAsmVal, size_t *Len)
     * }
     */
    public static MethodHandle LLVMGetInlineAsmConstraintString$handle() {
        return LLVMGetInlineAsmConstraintString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetInlineAsmConstraintString(LLVMValueRef InlineAsmVal, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmConstraintString$address() {
        return LLVMGetInlineAsmConstraintString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetInlineAsmConstraintString(LLVMValueRef InlineAsmVal, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmConstraintString(MemorySegment InlineAsmVal, MemorySegment Len) {
        var mh$ = LLVMGetInlineAsmConstraintString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInlineAsmConstraintString", InlineAsmVal, Len);
            }
            return (MemorySegment)mh$.invokeExact(InlineAsmVal, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInlineAsmDialect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInlineAsmDialect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMInlineAsmDialect LLVMGetInlineAsmDialect(LLVMValueRef InlineAsmVal)
     * }
     */
    public static FunctionDescriptor LLVMGetInlineAsmDialect$descriptor() {
        return LLVMGetInlineAsmDialect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMInlineAsmDialect LLVMGetInlineAsmDialect(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MethodHandle LLVMGetInlineAsmDialect$handle() {
        return LLVMGetInlineAsmDialect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMInlineAsmDialect LLVMGetInlineAsmDialect(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmDialect$address() {
        return LLVMGetInlineAsmDialect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMInlineAsmDialect LLVMGetInlineAsmDialect(LLVMValueRef InlineAsmVal)
     * }
     */
    public static int LLVMGetInlineAsmDialect(MemorySegment InlineAsmVal) {
        var mh$ = LLVMGetInlineAsmDialect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInlineAsmDialect", InlineAsmVal);
            }
            return (int)mh$.invokeExact(InlineAsmVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInlineAsmFunctionType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInlineAsmFunctionType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetInlineAsmFunctionType(LLVMValueRef InlineAsmVal)
     * }
     */
    public static FunctionDescriptor LLVMGetInlineAsmFunctionType$descriptor() {
        return LLVMGetInlineAsmFunctionType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetInlineAsmFunctionType(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MethodHandle LLVMGetInlineAsmFunctionType$handle() {
        return LLVMGetInlineAsmFunctionType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetInlineAsmFunctionType(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmFunctionType$address() {
        return LLVMGetInlineAsmFunctionType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetInlineAsmFunctionType(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmFunctionType(MemorySegment InlineAsmVal) {
        var mh$ = LLVMGetInlineAsmFunctionType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInlineAsmFunctionType", InlineAsmVal);
            }
            return (MemorySegment)mh$.invokeExact(InlineAsmVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInlineAsmHasSideEffects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInlineAsmHasSideEffects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmHasSideEffects(LLVMValueRef InlineAsmVal)
     * }
     */
    public static FunctionDescriptor LLVMGetInlineAsmHasSideEffects$descriptor() {
        return LLVMGetInlineAsmHasSideEffects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmHasSideEffects(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MethodHandle LLVMGetInlineAsmHasSideEffects$handle() {
        return LLVMGetInlineAsmHasSideEffects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmHasSideEffects(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmHasSideEffects$address() {
        return LLVMGetInlineAsmHasSideEffects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmHasSideEffects(LLVMValueRef InlineAsmVal)
     * }
     */
    public static int LLVMGetInlineAsmHasSideEffects(MemorySegment InlineAsmVal) {
        var mh$ = LLVMGetInlineAsmHasSideEffects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInlineAsmHasSideEffects", InlineAsmVal);
            }
            return (int)mh$.invokeExact(InlineAsmVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInlineAsmNeedsAlignedStack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInlineAsmNeedsAlignedStack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmNeedsAlignedStack(LLVMValueRef InlineAsmVal)
     * }
     */
    public static FunctionDescriptor LLVMGetInlineAsmNeedsAlignedStack$descriptor() {
        return LLVMGetInlineAsmNeedsAlignedStack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmNeedsAlignedStack(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MethodHandle LLVMGetInlineAsmNeedsAlignedStack$handle() {
        return LLVMGetInlineAsmNeedsAlignedStack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmNeedsAlignedStack(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmNeedsAlignedStack$address() {
        return LLVMGetInlineAsmNeedsAlignedStack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmNeedsAlignedStack(LLVMValueRef InlineAsmVal)
     * }
     */
    public static int LLVMGetInlineAsmNeedsAlignedStack(MemorySegment InlineAsmVal) {
        var mh$ = LLVMGetInlineAsmNeedsAlignedStack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInlineAsmNeedsAlignedStack", InlineAsmVal);
            }
            return (int)mh$.invokeExact(InlineAsmVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInlineAsmCanUnwind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInlineAsmCanUnwind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmCanUnwind(LLVMValueRef InlineAsmVal)
     * }
     */
    public static FunctionDescriptor LLVMGetInlineAsmCanUnwind$descriptor() {
        return LLVMGetInlineAsmCanUnwind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmCanUnwind(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MethodHandle LLVMGetInlineAsmCanUnwind$handle() {
        return LLVMGetInlineAsmCanUnwind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmCanUnwind(LLVMValueRef InlineAsmVal)
     * }
     */
    public static MemorySegment LLVMGetInlineAsmCanUnwind$address() {
        return LLVMGetInlineAsmCanUnwind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetInlineAsmCanUnwind(LLVMValueRef InlineAsmVal)
     * }
     */
    public static int LLVMGetInlineAsmCanUnwind(MemorySegment InlineAsmVal) {
        var mh$ = LLVMGetInlineAsmCanUnwind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInlineAsmCanUnwind", InlineAsmVal);
            }
            return (int)mh$.invokeExact(InlineAsmVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetModuleContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetModuleContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetModuleContext(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetModuleContext$descriptor() {
        return LLVMGetModuleContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetModuleContext(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetModuleContext$handle() {
        return LLVMGetModuleContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetModuleContext(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetModuleContext$address() {
        return LLVMGetModuleContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetModuleContext(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetModuleContext(MemorySegment M) {
        var mh$ = LLVMGetModuleContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetModuleContext", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTypeByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTypeByName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeByName(LLVMModuleRef M, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMGetTypeByName$descriptor() {
        return LLVMGetTypeByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeByName(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MethodHandle LLVMGetTypeByName$handle() {
        return LLVMGetTypeByName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeByName(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetTypeByName$address() {
        return LLVMGetTypeByName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTypeByName(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetTypeByName(MemorySegment M, MemorySegment Name) {
        var mh$ = LLVMGetTypeByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTypeByName", M, Name);
            }
            return (MemorySegment)mh$.invokeExact(M, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstNamedMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstNamedMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetFirstNamedMetadata(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstNamedMetadata$descriptor() {
        return LLVMGetFirstNamedMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetFirstNamedMetadata(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetFirstNamedMetadata$handle() {
        return LLVMGetFirstNamedMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetFirstNamedMetadata(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstNamedMetadata$address() {
        return LLVMGetFirstNamedMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetFirstNamedMetadata(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstNamedMetadata(MemorySegment M) {
        var mh$ = LLVMGetFirstNamedMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstNamedMetadata", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastNamedMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastNamedMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetLastNamedMetadata(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetLastNamedMetadata$descriptor() {
        return LLVMGetLastNamedMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetLastNamedMetadata(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetLastNamedMetadata$handle() {
        return LLVMGetLastNamedMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetLastNamedMetadata(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastNamedMetadata$address() {
        return LLVMGetLastNamedMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetLastNamedMetadata(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastNamedMetadata(MemorySegment M) {
        var mh$ = LLVMGetLastNamedMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastNamedMetadata", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextNamedMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextNamedMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetNextNamedMetadata(LLVMNamedMDNodeRef NamedMDNode)
     * }
     */
    public static FunctionDescriptor LLVMGetNextNamedMetadata$descriptor() {
        return LLVMGetNextNamedMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetNextNamedMetadata(LLVMNamedMDNodeRef NamedMDNode)
     * }
     */
    public static MethodHandle LLVMGetNextNamedMetadata$handle() {
        return LLVMGetNextNamedMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetNextNamedMetadata(LLVMNamedMDNodeRef NamedMDNode)
     * }
     */
    public static MemorySegment LLVMGetNextNamedMetadata$address() {
        return LLVMGetNextNamedMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetNextNamedMetadata(LLVMNamedMDNodeRef NamedMDNode)
     * }
     */
    public static MemorySegment LLVMGetNextNamedMetadata(MemorySegment NamedMDNode) {
        var mh$ = LLVMGetNextNamedMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextNamedMetadata", NamedMDNode);
            }
            return (MemorySegment)mh$.invokeExact(NamedMDNode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousNamedMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousNamedMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetPreviousNamedMetadata(LLVMNamedMDNodeRef NamedMDNode)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousNamedMetadata$descriptor() {
        return LLVMGetPreviousNamedMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetPreviousNamedMetadata(LLVMNamedMDNodeRef NamedMDNode)
     * }
     */
    public static MethodHandle LLVMGetPreviousNamedMetadata$handle() {
        return LLVMGetPreviousNamedMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetPreviousNamedMetadata(LLVMNamedMDNodeRef NamedMDNode)
     * }
     */
    public static MemorySegment LLVMGetPreviousNamedMetadata$address() {
        return LLVMGetPreviousNamedMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetPreviousNamedMetadata(LLVMNamedMDNodeRef NamedMDNode)
     * }
     */
    public static MemorySegment LLVMGetPreviousNamedMetadata(MemorySegment NamedMDNode) {
        var mh$ = LLVMGetPreviousNamedMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousNamedMetadata", NamedMDNode);
            }
            return (MemorySegment)mh$.invokeExact(NamedMDNode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetNamedMetadata(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedMetadata$descriptor() {
        return LLVMGetNamedMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetNamedMetadata(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MethodHandle LLVMGetNamedMetadata$handle() {
        return LLVMGetNamedMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetNamedMetadata(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedMetadata$address() {
        return LLVMGetNamedMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetNamedMetadata(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedMetadata(MemorySegment M, MemorySegment Name, long NameLen) {
        var mh$ = LLVMGetNamedMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedMetadata", M, Name, NameLen);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, NameLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOrInsertNamedMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOrInsertNamedMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetOrInsertNamedMetadata(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static FunctionDescriptor LLVMGetOrInsertNamedMetadata$descriptor() {
        return LLVMGetOrInsertNamedMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetOrInsertNamedMetadata(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MethodHandle LLVMGetOrInsertNamedMetadata$handle() {
        return LLVMGetOrInsertNamedMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetOrInsertNamedMetadata(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetOrInsertNamedMetadata$address() {
        return LLVMGetOrInsertNamedMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMNamedMDNodeRef LLVMGetOrInsertNamedMetadata(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetOrInsertNamedMetadata(MemorySegment M, MemorySegment Name, long NameLen) {
        var mh$ = LLVMGetOrInsertNamedMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOrInsertNamedMetadata", M, Name, NameLen);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, NameLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedMetadataName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedMetadataName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetNamedMetadataName(LLVMNamedMDNodeRef NamedMD, size_t *NameLen)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedMetadataName$descriptor() {
        return LLVMGetNamedMetadataName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetNamedMetadataName(LLVMNamedMDNodeRef NamedMD, size_t *NameLen)
     * }
     */
    public static MethodHandle LLVMGetNamedMetadataName$handle() {
        return LLVMGetNamedMetadataName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetNamedMetadataName(LLVMNamedMDNodeRef NamedMD, size_t *NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedMetadataName$address() {
        return LLVMGetNamedMetadataName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetNamedMetadataName(LLVMNamedMDNodeRef NamedMD, size_t *NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedMetadataName(MemorySegment NamedMD, MemorySegment NameLen) {
        var mh$ = LLVMGetNamedMetadataName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedMetadataName", NamedMD, NameLen);
            }
            return (MemorySegment)mh$.invokeExact(NamedMD, NameLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedMetadataNumOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedMetadataNumOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNamedMetadataNumOperands(LLVMModuleRef M, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedMetadataNumOperands$descriptor() {
        return LLVMGetNamedMetadataNumOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNamedMetadataNumOperands(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MethodHandle LLVMGetNamedMetadataNumOperands$handle() {
        return LLVMGetNamedMetadataNumOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNamedMetadataNumOperands(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetNamedMetadataNumOperands$address() {
        return LLVMGetNamedMetadataNumOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNamedMetadataNumOperands(LLVMModuleRef M, const char *Name)
     * }
     */
    public static int LLVMGetNamedMetadataNumOperands(MemorySegment M, MemorySegment Name) {
        var mh$ = LLVMGetNamedMetadataNumOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedMetadataNumOperands", M, Name);
            }
            return (int)mh$.invokeExact(M, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedMetadataOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedMetadataOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetNamedMetadataOperands(LLVMModuleRef M, const char *Name, LLVMValueRef *Dest)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedMetadataOperands$descriptor() {
        return LLVMGetNamedMetadataOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetNamedMetadataOperands(LLVMModuleRef M, const char *Name, LLVMValueRef *Dest)
     * }
     */
    public static MethodHandle LLVMGetNamedMetadataOperands$handle() {
        return LLVMGetNamedMetadataOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetNamedMetadataOperands(LLVMModuleRef M, const char *Name, LLVMValueRef *Dest)
     * }
     */
    public static MemorySegment LLVMGetNamedMetadataOperands$address() {
        return LLVMGetNamedMetadataOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetNamedMetadataOperands(LLVMModuleRef M, const char *Name, LLVMValueRef *Dest)
     * }
     */
    public static void LLVMGetNamedMetadataOperands(MemorySegment M, MemorySegment Name, MemorySegment Dest) {
        var mh$ = LLVMGetNamedMetadataOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedMetadataOperands", M, Name, Dest);
            }
            mh$.invokeExact(M, Name, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddNamedMetadataOperand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddNamedMetadataOperand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddNamedMetadataOperand(LLVMModuleRef M, const char *Name, LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMAddNamedMetadataOperand$descriptor() {
        return LLVMAddNamedMetadataOperand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddNamedMetadataOperand(LLVMModuleRef M, const char *Name, LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMAddNamedMetadataOperand$handle() {
        return LLVMAddNamedMetadataOperand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddNamedMetadataOperand(LLVMModuleRef M, const char *Name, LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMAddNamedMetadataOperand$address() {
        return LLVMAddNamedMetadataOperand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddNamedMetadataOperand(LLVMModuleRef M, const char *Name, LLVMValueRef Val)
     * }
     */
    public static void LLVMAddNamedMetadataOperand(MemorySegment M, MemorySegment Name, MemorySegment Val) {
        var mh$ = LLVMAddNamedMetadataOperand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddNamedMetadataOperand", M, Name, Val);
            }
            mh$.invokeExact(M, Name, Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDebugLocDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDebugLocDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetDebugLocDirectory(LLVMValueRef Val, unsigned int *Length)
     * }
     */
    public static FunctionDescriptor LLVMGetDebugLocDirectory$descriptor() {
        return LLVMGetDebugLocDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetDebugLocDirectory(LLVMValueRef Val, unsigned int *Length)
     * }
     */
    public static MethodHandle LLVMGetDebugLocDirectory$handle() {
        return LLVMGetDebugLocDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetDebugLocDirectory(LLVMValueRef Val, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetDebugLocDirectory$address() {
        return LLVMGetDebugLocDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetDebugLocDirectory(LLVMValueRef Val, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetDebugLocDirectory(MemorySegment Val, MemorySegment Length) {
        var mh$ = LLVMGetDebugLocDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDebugLocDirectory", Val, Length);
            }
            return (MemorySegment)mh$.invokeExact(Val, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDebugLocFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDebugLocFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetDebugLocFilename(LLVMValueRef Val, unsigned int *Length)
     * }
     */
    public static FunctionDescriptor LLVMGetDebugLocFilename$descriptor() {
        return LLVMGetDebugLocFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetDebugLocFilename(LLVMValueRef Val, unsigned int *Length)
     * }
     */
    public static MethodHandle LLVMGetDebugLocFilename$handle() {
        return LLVMGetDebugLocFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetDebugLocFilename(LLVMValueRef Val, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetDebugLocFilename$address() {
        return LLVMGetDebugLocFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetDebugLocFilename(LLVMValueRef Val, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetDebugLocFilename(MemorySegment Val, MemorySegment Length) {
        var mh$ = LLVMGetDebugLocFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDebugLocFilename", Val, Length);
            }
            return (MemorySegment)mh$.invokeExact(Val, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDebugLocLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDebugLocLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetDebugLocLine(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMGetDebugLocLine$descriptor() {
        return LLVMGetDebugLocLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetDebugLocLine(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMGetDebugLocLine$handle() {
        return LLVMGetDebugLocLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetDebugLocLine(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetDebugLocLine$address() {
        return LLVMGetDebugLocLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetDebugLocLine(LLVMValueRef Val)
     * }
     */
    public static int LLVMGetDebugLocLine(MemorySegment Val) {
        var mh$ = LLVMGetDebugLocLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDebugLocLine", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDebugLocColumn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDebugLocColumn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetDebugLocColumn(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMGetDebugLocColumn$descriptor() {
        return LLVMGetDebugLocColumn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetDebugLocColumn(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMGetDebugLocColumn$handle() {
        return LLVMGetDebugLocColumn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetDebugLocColumn(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetDebugLocColumn$address() {
        return LLVMGetDebugLocColumn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetDebugLocColumn(LLVMValueRef Val)
     * }
     */
    public static int LLVMGetDebugLocColumn(MemorySegment Val) {
        var mh$ = LLVMGetDebugLocColumn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDebugLocColumn", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddFunction(LLVMModuleRef M, const char *Name, LLVMTypeRef FunctionTy)
     * }
     */
    public static FunctionDescriptor LLVMAddFunction$descriptor() {
        return LLVMAddFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddFunction(LLVMModuleRef M, const char *Name, LLVMTypeRef FunctionTy)
     * }
     */
    public static MethodHandle LLVMAddFunction$handle() {
        return LLVMAddFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddFunction(LLVMModuleRef M, const char *Name, LLVMTypeRef FunctionTy)
     * }
     */
    public static MemorySegment LLVMAddFunction$address() {
        return LLVMAddFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddFunction(LLVMModuleRef M, const char *Name, LLVMTypeRef FunctionTy)
     * }
     */
    public static MemorySegment LLVMAddFunction(MemorySegment M, MemorySegment Name, MemorySegment FunctionTy) {
        var mh$ = LLVMAddFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddFunction", M, Name, FunctionTy);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, FunctionTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedFunction(LLVMModuleRef M, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedFunction$descriptor() {
        return LLVMGetNamedFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedFunction(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MethodHandle LLVMGetNamedFunction$handle() {
        return LLVMGetNamedFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedFunction(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetNamedFunction$address() {
        return LLVMGetNamedFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedFunction(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetNamedFunction(MemorySegment M, MemorySegment Name) {
        var mh$ = LLVMGetNamedFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedFunction", M, Name);
            }
            return (MemorySegment)mh$.invokeExact(M, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedFunctionWithLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedFunctionWithLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedFunctionWithLength(LLVMModuleRef M, const char *Name, size_t Length)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedFunctionWithLength$descriptor() {
        return LLVMGetNamedFunctionWithLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedFunctionWithLength(LLVMModuleRef M, const char *Name, size_t Length)
     * }
     */
    public static MethodHandle LLVMGetNamedFunctionWithLength$handle() {
        return LLVMGetNamedFunctionWithLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedFunctionWithLength(LLVMModuleRef M, const char *Name, size_t Length)
     * }
     */
    public static MemorySegment LLVMGetNamedFunctionWithLength$address() {
        return LLVMGetNamedFunctionWithLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedFunctionWithLength(LLVMModuleRef M, const char *Name, size_t Length)
     * }
     */
    public static MemorySegment LLVMGetNamedFunctionWithLength(MemorySegment M, MemorySegment Name, long Length) {
        var mh$ = LLVMGetNamedFunctionWithLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedFunctionWithLength", M, Name, Length);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstFunction(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstFunction$descriptor() {
        return LLVMGetFirstFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstFunction(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetFirstFunction$handle() {
        return LLVMGetFirstFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstFunction(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstFunction$address() {
        return LLVMGetFirstFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstFunction(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstFunction(MemorySegment M) {
        var mh$ = LLVMGetFirstFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstFunction", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastFunction(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetLastFunction$descriptor() {
        return LLVMGetLastFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastFunction(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetLastFunction$handle() {
        return LLVMGetLastFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastFunction(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastFunction$address() {
        return LLVMGetLastFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastFunction(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastFunction(MemorySegment M) {
        var mh$ = LLVMGetLastFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastFunction", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextFunction(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetNextFunction$descriptor() {
        return LLVMGetNextFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextFunction(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetNextFunction$handle() {
        return LLVMGetNextFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextFunction(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetNextFunction$address() {
        return LLVMGetNextFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextFunction(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetNextFunction(MemorySegment Fn) {
        var mh$ = LLVMGetNextFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextFunction", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousFunction(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousFunction$descriptor() {
        return LLVMGetPreviousFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousFunction(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetPreviousFunction$handle() {
        return LLVMGetPreviousFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousFunction(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetPreviousFunction$address() {
        return LLVMGetPreviousFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousFunction(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetPreviousFunction(MemorySegment Fn) {
        var mh$ = LLVMGetPreviousFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousFunction", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetModuleInlineAsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetModuleInlineAsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetModuleInlineAsm(LLVMModuleRef M, const char *Asm)
     * }
     */
    public static FunctionDescriptor LLVMSetModuleInlineAsm$descriptor() {
        return LLVMSetModuleInlineAsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetModuleInlineAsm(LLVMModuleRef M, const char *Asm)
     * }
     */
    public static MethodHandle LLVMSetModuleInlineAsm$handle() {
        return LLVMSetModuleInlineAsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetModuleInlineAsm(LLVMModuleRef M, const char *Asm)
     * }
     */
    public static MemorySegment LLVMSetModuleInlineAsm$address() {
        return LLVMSetModuleInlineAsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetModuleInlineAsm(LLVMModuleRef M, const char *Asm)
     * }
     */
    public static void LLVMSetModuleInlineAsm(MemorySegment M, MemorySegment Asm) {
        var mh$ = LLVMSetModuleInlineAsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetModuleInlineAsm", M, Asm);
            }
            mh$.invokeExact(M, Asm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTypeKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTypeKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeKind LLVMGetTypeKind(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMGetTypeKind$descriptor() {
        return LLVMGetTypeKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeKind LLVMGetTypeKind(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMGetTypeKind$handle() {
        return LLVMGetTypeKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeKind LLVMGetTypeKind(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetTypeKind$address() {
        return LLVMGetTypeKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeKind LLVMGetTypeKind(LLVMTypeRef Ty)
     * }
     */
    public static int LLVMGetTypeKind(MemorySegment Ty) {
        var mh$ = LLVMGetTypeKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTypeKind", Ty);
            }
            return (int)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTypeIsSized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTypeIsSized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMTypeIsSized(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMTypeIsSized$descriptor() {
        return LLVMTypeIsSized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMTypeIsSized(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMTypeIsSized$handle() {
        return LLVMTypeIsSized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMTypeIsSized(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMTypeIsSized$address() {
        return LLVMTypeIsSized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMTypeIsSized(LLVMTypeRef Ty)
     * }
     */
    public static int LLVMTypeIsSized(MemorySegment Ty) {
        var mh$ = LLVMTypeIsSized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTypeIsSized", Ty);
            }
            return (int)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTypeContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTypeContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetTypeContext(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMGetTypeContext$descriptor() {
        return LLVMGetTypeContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetTypeContext(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMGetTypeContext$handle() {
        return LLVMGetTypeContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetTypeContext(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetTypeContext$address() {
        return LLVMGetTypeContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetTypeContext(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetTypeContext(MemorySegment Ty) {
        var mh$ = LLVMGetTypeContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTypeContext", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDumpType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDumpType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDumpType(LLVMTypeRef Val)
     * }
     */
    public static FunctionDescriptor LLVMDumpType$descriptor() {
        return LLVMDumpType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDumpType(LLVMTypeRef Val)
     * }
     */
    public static MethodHandle LLVMDumpType$handle() {
        return LLVMDumpType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDumpType(LLVMTypeRef Val)
     * }
     */
    public static MemorySegment LLVMDumpType$address() {
        return LLVMDumpType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDumpType(LLVMTypeRef Val)
     * }
     */
    public static void LLVMDumpType(MemorySegment Val) {
        var mh$ = LLVMDumpType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDumpType", Val);
            }
            mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPrintTypeToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPrintTypeToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMPrintTypeToString(LLVMTypeRef Val)
     * }
     */
    public static FunctionDescriptor LLVMPrintTypeToString$descriptor() {
        return LLVMPrintTypeToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMPrintTypeToString(LLVMTypeRef Val)
     * }
     */
    public static MethodHandle LLVMPrintTypeToString$handle() {
        return LLVMPrintTypeToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMPrintTypeToString(LLVMTypeRef Val)
     * }
     */
    public static MemorySegment LLVMPrintTypeToString$address() {
        return LLVMPrintTypeToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMPrintTypeToString(LLVMTypeRef Val)
     * }
     */
    public static MemorySegment LLVMPrintTypeToString(MemorySegment Val) {
        var mh$ = LLVMPrintTypeToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPrintTypeToString", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt1TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt1TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt1TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMInt1TypeInContext$descriptor() {
        return LLVMInt1TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt1TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMInt1TypeInContext$handle() {
        return LLVMInt1TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt1TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt1TypeInContext$address() {
        return LLVMInt1TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt1TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt1TypeInContext(MemorySegment C) {
        var mh$ = LLVMInt1TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt1TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt8TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt8TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt8TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMInt8TypeInContext$descriptor() {
        return LLVMInt8TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt8TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMInt8TypeInContext$handle() {
        return LLVMInt8TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt8TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt8TypeInContext$address() {
        return LLVMInt8TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt8TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt8TypeInContext(MemorySegment C) {
        var mh$ = LLVMInt8TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt8TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt16TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt16TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt16TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMInt16TypeInContext$descriptor() {
        return LLVMInt16TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt16TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMInt16TypeInContext$handle() {
        return LLVMInt16TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt16TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt16TypeInContext$address() {
        return LLVMInt16TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt16TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt16TypeInContext(MemorySegment C) {
        var mh$ = LLVMInt16TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt16TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt32TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt32TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt32TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMInt32TypeInContext$descriptor() {
        return LLVMInt32TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt32TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMInt32TypeInContext$handle() {
        return LLVMInt32TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt32TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt32TypeInContext$address() {
        return LLVMInt32TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt32TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt32TypeInContext(MemorySegment C) {
        var mh$ = LLVMInt32TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt32TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt64TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt64TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt64TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMInt64TypeInContext$descriptor() {
        return LLVMInt64TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt64TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMInt64TypeInContext$handle() {
        return LLVMInt64TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt64TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt64TypeInContext$address() {
        return LLVMInt64TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt64TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt64TypeInContext(MemorySegment C) {
        var mh$ = LLVMInt64TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt64TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt128TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt128TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt128TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMInt128TypeInContext$descriptor() {
        return LLVMInt128TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMInt128TypeInContext$handle() {
        return LLVMInt128TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt128TypeInContext$address() {
        return LLVMInt128TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMInt128TypeInContext(MemorySegment C) {
        var mh$ = LLVMInt128TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt128TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntTypeInContext(LLVMContextRef C, unsigned int NumBits)
     * }
     */
    public static FunctionDescriptor LLVMIntTypeInContext$descriptor() {
        return LLVMIntTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntTypeInContext(LLVMContextRef C, unsigned int NumBits)
     * }
     */
    public static MethodHandle LLVMIntTypeInContext$handle() {
        return LLVMIntTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntTypeInContext(LLVMContextRef C, unsigned int NumBits)
     * }
     */
    public static MemorySegment LLVMIntTypeInContext$address() {
        return LLVMIntTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntTypeInContext(LLVMContextRef C, unsigned int NumBits)
     * }
     */
    public static MemorySegment LLVMIntTypeInContext(MemorySegment C, int NumBits) {
        var mh$ = LLVMIntTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntTypeInContext", C, NumBits);
            }
            return (MemorySegment)mh$.invokeExact(C, NumBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt1Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt1Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt1Type()
     * }
     */
    public static FunctionDescriptor LLVMInt1Type$descriptor() {
        return LLVMInt1Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt1Type()
     * }
     */
    public static MethodHandle LLVMInt1Type$handle() {
        return LLVMInt1Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt1Type()
     * }
     */
    public static MemorySegment LLVMInt1Type$address() {
        return LLVMInt1Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt1Type()
     * }
     */
    public static MemorySegment LLVMInt1Type() {
        var mh$ = LLVMInt1Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt1Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt8Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt8Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt8Type()
     * }
     */
    public static FunctionDescriptor LLVMInt8Type$descriptor() {
        return LLVMInt8Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt8Type()
     * }
     */
    public static MethodHandle LLVMInt8Type$handle() {
        return LLVMInt8Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt8Type()
     * }
     */
    public static MemorySegment LLVMInt8Type$address() {
        return LLVMInt8Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt8Type()
     * }
     */
    public static MemorySegment LLVMInt8Type() {
        var mh$ = LLVMInt8Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt8Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt16Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt16Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt16Type()
     * }
     */
    public static FunctionDescriptor LLVMInt16Type$descriptor() {
        return LLVMInt16Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt16Type()
     * }
     */
    public static MethodHandle LLVMInt16Type$handle() {
        return LLVMInt16Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt16Type()
     * }
     */
    public static MemorySegment LLVMInt16Type$address() {
        return LLVMInt16Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt16Type()
     * }
     */
    public static MemorySegment LLVMInt16Type() {
        var mh$ = LLVMInt16Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt16Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt32Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt32Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt32Type()
     * }
     */
    public static FunctionDescriptor LLVMInt32Type$descriptor() {
        return LLVMInt32Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt32Type()
     * }
     */
    public static MethodHandle LLVMInt32Type$handle() {
        return LLVMInt32Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt32Type()
     * }
     */
    public static MemorySegment LLVMInt32Type$address() {
        return LLVMInt32Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt32Type()
     * }
     */
    public static MemorySegment LLVMInt32Type() {
        var mh$ = LLVMInt32Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt32Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt64Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt64Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt64Type()
     * }
     */
    public static FunctionDescriptor LLVMInt64Type$descriptor() {
        return LLVMInt64Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt64Type()
     * }
     */
    public static MethodHandle LLVMInt64Type$handle() {
        return LLVMInt64Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt64Type()
     * }
     */
    public static MemorySegment LLVMInt64Type$address() {
        return LLVMInt64Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt64Type()
     * }
     */
    public static MemorySegment LLVMInt64Type() {
        var mh$ = LLVMInt64Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt64Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInt128Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInt128Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt128Type()
     * }
     */
    public static FunctionDescriptor LLVMInt128Type$descriptor() {
        return LLVMInt128Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt128Type()
     * }
     */
    public static MethodHandle LLVMInt128Type$handle() {
        return LLVMInt128Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt128Type()
     * }
     */
    public static MemorySegment LLVMInt128Type$address() {
        return LLVMInt128Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMInt128Type()
     * }
     */
    public static MemorySegment LLVMInt128Type() {
        var mh$ = LLVMInt128Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInt128Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntType(unsigned int NumBits)
     * }
     */
    public static FunctionDescriptor LLVMIntType$descriptor() {
        return LLVMIntType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntType(unsigned int NumBits)
     * }
     */
    public static MethodHandle LLVMIntType$handle() {
        return LLVMIntType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntType(unsigned int NumBits)
     * }
     */
    public static MemorySegment LLVMIntType$address() {
        return LLVMIntType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntType(unsigned int NumBits)
     * }
     */
    public static MemorySegment LLVMIntType(int NumBits) {
        var mh$ = LLVMIntType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntType", NumBits);
            }
            return (MemorySegment)mh$.invokeExact(NumBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIntTypeWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIntTypeWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetIntTypeWidth(LLVMTypeRef IntegerTy)
     * }
     */
    public static FunctionDescriptor LLVMGetIntTypeWidth$descriptor() {
        return LLVMGetIntTypeWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetIntTypeWidth(LLVMTypeRef IntegerTy)
     * }
     */
    public static MethodHandle LLVMGetIntTypeWidth$handle() {
        return LLVMGetIntTypeWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetIntTypeWidth(LLVMTypeRef IntegerTy)
     * }
     */
    public static MemorySegment LLVMGetIntTypeWidth$address() {
        return LLVMGetIntTypeWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetIntTypeWidth(LLVMTypeRef IntegerTy)
     * }
     */
    public static int LLVMGetIntTypeWidth(MemorySegment IntegerTy) {
        var mh$ = LLVMGetIntTypeWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIntTypeWidth", IntegerTy);
            }
            return (int)mh$.invokeExact(IntegerTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMHalfTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMHalfTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMHalfTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMHalfTypeInContext$descriptor() {
        return LLVMHalfTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMHalfTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMHalfTypeInContext$handle() {
        return LLVMHalfTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMHalfTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMHalfTypeInContext$address() {
        return LLVMHalfTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMHalfTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMHalfTypeInContext(MemorySegment C) {
        var mh$ = LLVMHalfTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMHalfTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBFloatTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBFloatTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMBFloatTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMBFloatTypeInContext$descriptor() {
        return LLVMBFloatTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMBFloatTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMBFloatTypeInContext$handle() {
        return LLVMBFloatTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMBFloatTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMBFloatTypeInContext$address() {
        return LLVMBFloatTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMBFloatTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMBFloatTypeInContext(MemorySegment C) {
        var mh$ = LLVMBFloatTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBFloatTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFloatTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFloatTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFloatTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMFloatTypeInContext$descriptor() {
        return LLVMFloatTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFloatTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMFloatTypeInContext$handle() {
        return LLVMFloatTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFloatTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMFloatTypeInContext$address() {
        return LLVMFloatTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFloatTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMFloatTypeInContext(MemorySegment C) {
        var mh$ = LLVMFloatTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFloatTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDoubleTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDoubleTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMDoubleTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMDoubleTypeInContext$descriptor() {
        return LLVMDoubleTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMDoubleTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMDoubleTypeInContext$handle() {
        return LLVMDoubleTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMDoubleTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMDoubleTypeInContext$address() {
        return LLVMDoubleTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMDoubleTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMDoubleTypeInContext(MemorySegment C) {
        var mh$ = LLVMDoubleTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDoubleTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMX86FP80TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMX86FP80TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86FP80TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMX86FP80TypeInContext$descriptor() {
        return LLVMX86FP80TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86FP80TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMX86FP80TypeInContext$handle() {
        return LLVMX86FP80TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86FP80TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMX86FP80TypeInContext$address() {
        return LLVMX86FP80TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86FP80TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMX86FP80TypeInContext(MemorySegment C) {
        var mh$ = LLVMX86FP80TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMX86FP80TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFP128TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFP128TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFP128TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMFP128TypeInContext$descriptor() {
        return LLVMFP128TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFP128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMFP128TypeInContext$handle() {
        return LLVMFP128TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFP128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMFP128TypeInContext$address() {
        return LLVMFP128TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFP128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMFP128TypeInContext(MemorySegment C) {
        var mh$ = LLVMFP128TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFP128TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPPCFP128TypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPPCFP128TypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMPPCFP128TypeInContext$descriptor() {
        return LLVMPPCFP128TypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMPPCFP128TypeInContext$handle() {
        return LLVMPPCFP128TypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMPPCFP128TypeInContext$address() {
        return LLVMPPCFP128TypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMPPCFP128TypeInContext(MemorySegment C) {
        var mh$ = LLVMPPCFP128TypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPPCFP128TypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMHalfType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMHalfType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMHalfType()
     * }
     */
    public static FunctionDescriptor LLVMHalfType$descriptor() {
        return LLVMHalfType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMHalfType()
     * }
     */
    public static MethodHandle LLVMHalfType$handle() {
        return LLVMHalfType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMHalfType()
     * }
     */
    public static MemorySegment LLVMHalfType$address() {
        return LLVMHalfType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMHalfType()
     * }
     */
    public static MemorySegment LLVMHalfType() {
        var mh$ = LLVMHalfType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMHalfType");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBFloatType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBFloatType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMBFloatType()
     * }
     */
    public static FunctionDescriptor LLVMBFloatType$descriptor() {
        return LLVMBFloatType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMBFloatType()
     * }
     */
    public static MethodHandle LLVMBFloatType$handle() {
        return LLVMBFloatType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMBFloatType()
     * }
     */
    public static MemorySegment LLVMBFloatType$address() {
        return LLVMBFloatType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMBFloatType()
     * }
     */
    public static MemorySegment LLVMBFloatType() {
        var mh$ = LLVMBFloatType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBFloatType");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFloatType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFloatType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFloatType()
     * }
     */
    public static FunctionDescriptor LLVMFloatType$descriptor() {
        return LLVMFloatType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFloatType()
     * }
     */
    public static MethodHandle LLVMFloatType$handle() {
        return LLVMFloatType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFloatType()
     * }
     */
    public static MemorySegment LLVMFloatType$address() {
        return LLVMFloatType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFloatType()
     * }
     */
    public static MemorySegment LLVMFloatType() {
        var mh$ = LLVMFloatType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFloatType");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDoubleType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDoubleType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMDoubleType()
     * }
     */
    public static FunctionDescriptor LLVMDoubleType$descriptor() {
        return LLVMDoubleType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMDoubleType()
     * }
     */
    public static MethodHandle LLVMDoubleType$handle() {
        return LLVMDoubleType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMDoubleType()
     * }
     */
    public static MemorySegment LLVMDoubleType$address() {
        return LLVMDoubleType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMDoubleType()
     * }
     */
    public static MemorySegment LLVMDoubleType() {
        var mh$ = LLVMDoubleType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDoubleType");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMX86FP80Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMX86FP80Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86FP80Type()
     * }
     */
    public static FunctionDescriptor LLVMX86FP80Type$descriptor() {
        return LLVMX86FP80Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86FP80Type()
     * }
     */
    public static MethodHandle LLVMX86FP80Type$handle() {
        return LLVMX86FP80Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86FP80Type()
     * }
     */
    public static MemorySegment LLVMX86FP80Type$address() {
        return LLVMX86FP80Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86FP80Type()
     * }
     */
    public static MemorySegment LLVMX86FP80Type() {
        var mh$ = LLVMX86FP80Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMX86FP80Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFP128Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFP128Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFP128Type()
     * }
     */
    public static FunctionDescriptor LLVMFP128Type$descriptor() {
        return LLVMFP128Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFP128Type()
     * }
     */
    public static MethodHandle LLVMFP128Type$handle() {
        return LLVMFP128Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFP128Type()
     * }
     */
    public static MemorySegment LLVMFP128Type$address() {
        return LLVMFP128Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFP128Type()
     * }
     */
    public static MemorySegment LLVMFP128Type() {
        var mh$ = LLVMFP128Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFP128Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPPCFP128Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPPCFP128Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPPCFP128Type()
     * }
     */
    public static FunctionDescriptor LLVMPPCFP128Type$descriptor() {
        return LLVMPPCFP128Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPPCFP128Type()
     * }
     */
    public static MethodHandle LLVMPPCFP128Type$handle() {
        return LLVMPPCFP128Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPPCFP128Type()
     * }
     */
    public static MemorySegment LLVMPPCFP128Type$address() {
        return LLVMPPCFP128Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPPCFP128Type()
     * }
     */
    public static MemorySegment LLVMPPCFP128Type() {
        var mh$ = LLVMPPCFP128Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPPCFP128Type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFunctionType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFunctionType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFunctionType(LLVMTypeRef ReturnType, LLVMTypeRef *ParamTypes, unsigned int ParamCount, LLVMBool IsVarArg)
     * }
     */
    public static FunctionDescriptor LLVMFunctionType$descriptor() {
        return LLVMFunctionType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFunctionType(LLVMTypeRef ReturnType, LLVMTypeRef *ParamTypes, unsigned int ParamCount, LLVMBool IsVarArg)
     * }
     */
    public static MethodHandle LLVMFunctionType$handle() {
        return LLVMFunctionType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFunctionType(LLVMTypeRef ReturnType, LLVMTypeRef *ParamTypes, unsigned int ParamCount, LLVMBool IsVarArg)
     * }
     */
    public static MemorySegment LLVMFunctionType$address() {
        return LLVMFunctionType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMFunctionType(LLVMTypeRef ReturnType, LLVMTypeRef *ParamTypes, unsigned int ParamCount, LLVMBool IsVarArg)
     * }
     */
    public static MemorySegment LLVMFunctionType(MemorySegment ReturnType, MemorySegment ParamTypes, int ParamCount, int IsVarArg) {
        var mh$ = LLVMFunctionType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFunctionType", ReturnType, ParamTypes, ParamCount, IsVarArg);
            }
            return (MemorySegment)mh$.invokeExact(ReturnType, ParamTypes, ParamCount, IsVarArg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsFunctionVarArg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsFunctionVarArg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsFunctionVarArg(LLVMTypeRef FunctionTy)
     * }
     */
    public static FunctionDescriptor LLVMIsFunctionVarArg$descriptor() {
        return LLVMIsFunctionVarArg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsFunctionVarArg(LLVMTypeRef FunctionTy)
     * }
     */
    public static MethodHandle LLVMIsFunctionVarArg$handle() {
        return LLVMIsFunctionVarArg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsFunctionVarArg(LLVMTypeRef FunctionTy)
     * }
     */
    public static MemorySegment LLVMIsFunctionVarArg$address() {
        return LLVMIsFunctionVarArg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsFunctionVarArg(LLVMTypeRef FunctionTy)
     * }
     */
    public static int LLVMIsFunctionVarArg(MemorySegment FunctionTy) {
        var mh$ = LLVMIsFunctionVarArg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsFunctionVarArg", FunctionTy);
            }
            return (int)mh$.invokeExact(FunctionTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetReturnType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetReturnType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetReturnType(LLVMTypeRef FunctionTy)
     * }
     */
    public static FunctionDescriptor LLVMGetReturnType$descriptor() {
        return LLVMGetReturnType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetReturnType(LLVMTypeRef FunctionTy)
     * }
     */
    public static MethodHandle LLVMGetReturnType$handle() {
        return LLVMGetReturnType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetReturnType(LLVMTypeRef FunctionTy)
     * }
     */
    public static MemorySegment LLVMGetReturnType$address() {
        return LLVMGetReturnType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetReturnType(LLVMTypeRef FunctionTy)
     * }
     */
    public static MemorySegment LLVMGetReturnType(MemorySegment FunctionTy) {
        var mh$ = LLVMGetReturnType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetReturnType", FunctionTy);
            }
            return (MemorySegment)mh$.invokeExact(FunctionTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCountParamTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCountParamTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParamTypes(LLVMTypeRef FunctionTy)
     * }
     */
    public static FunctionDescriptor LLVMCountParamTypes$descriptor() {
        return LLVMCountParamTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParamTypes(LLVMTypeRef FunctionTy)
     * }
     */
    public static MethodHandle LLVMCountParamTypes$handle() {
        return LLVMCountParamTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParamTypes(LLVMTypeRef FunctionTy)
     * }
     */
    public static MemorySegment LLVMCountParamTypes$address() {
        return LLVMCountParamTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCountParamTypes(LLVMTypeRef FunctionTy)
     * }
     */
    public static int LLVMCountParamTypes(MemorySegment FunctionTy) {
        var mh$ = LLVMCountParamTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCountParamTypes", FunctionTy);
            }
            return (int)mh$.invokeExact(FunctionTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParamTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParamTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetParamTypes(LLVMTypeRef FunctionTy, LLVMTypeRef *Dest)
     * }
     */
    public static FunctionDescriptor LLVMGetParamTypes$descriptor() {
        return LLVMGetParamTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetParamTypes(LLVMTypeRef FunctionTy, LLVMTypeRef *Dest)
     * }
     */
    public static MethodHandle LLVMGetParamTypes$handle() {
        return LLVMGetParamTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetParamTypes(LLVMTypeRef FunctionTy, LLVMTypeRef *Dest)
     * }
     */
    public static MemorySegment LLVMGetParamTypes$address() {
        return LLVMGetParamTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetParamTypes(LLVMTypeRef FunctionTy, LLVMTypeRef *Dest)
     * }
     */
    public static void LLVMGetParamTypes(MemorySegment FunctionTy, MemorySegment Dest) {
        var mh$ = LLVMGetParamTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParamTypes", FunctionTy, Dest);
            }
            mh$.invokeExact(FunctionTy, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStructTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStructTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructTypeInContext(LLVMContextRef C, LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static FunctionDescriptor LLVMStructTypeInContext$descriptor() {
        return LLVMStructTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructTypeInContext(LLVMContextRef C, LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static MethodHandle LLVMStructTypeInContext$handle() {
        return LLVMStructTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructTypeInContext(LLVMContextRef C, LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMStructTypeInContext$address() {
        return LLVMStructTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructTypeInContext(LLVMContextRef C, LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMStructTypeInContext(MemorySegment C, MemorySegment ElementTypes, int ElementCount, int Packed) {
        var mh$ = LLVMStructTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStructTypeInContext", C, ElementTypes, ElementCount, Packed);
            }
            return (MemorySegment)mh$.invokeExact(C, ElementTypes, ElementCount, Packed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStructType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStructType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructType(LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static FunctionDescriptor LLVMStructType$descriptor() {
        return LLVMStructType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructType(LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static MethodHandle LLVMStructType$handle() {
        return LLVMStructType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructType(LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMStructType$address() {
        return LLVMStructType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructType(LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMStructType(MemorySegment ElementTypes, int ElementCount, int Packed) {
        var mh$ = LLVMStructType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStructType", ElementTypes, ElementCount, Packed);
            }
            return (MemorySegment)mh$.invokeExact(ElementTypes, ElementCount, Packed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStructCreateNamed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStructCreateNamed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructCreateNamed(LLVMContextRef C, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMStructCreateNamed$descriptor() {
        return LLVMStructCreateNamed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructCreateNamed(LLVMContextRef C, const char *Name)
     * }
     */
    public static MethodHandle LLVMStructCreateNamed$handle() {
        return LLVMStructCreateNamed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructCreateNamed(LLVMContextRef C, const char *Name)
     * }
     */
    public static MemorySegment LLVMStructCreateNamed$address() {
        return LLVMStructCreateNamed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructCreateNamed(LLVMContextRef C, const char *Name)
     * }
     */
    public static MemorySegment LLVMStructCreateNamed(MemorySegment C, MemorySegment Name) {
        var mh$ = LLVMStructCreateNamed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStructCreateNamed", C, Name);
            }
            return (MemorySegment)mh$.invokeExact(C, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetStructName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetStructName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetStructName(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMGetStructName$descriptor() {
        return LLVMGetStructName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetStructName(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMGetStructName$handle() {
        return LLVMGetStructName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetStructName(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetStructName$address() {
        return LLVMGetStructName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetStructName(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetStructName(MemorySegment Ty) {
        var mh$ = LLVMGetStructName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetStructName", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStructSetBody {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStructSetBody");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMStructSetBody(LLVMTypeRef StructTy, LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static FunctionDescriptor LLVMStructSetBody$descriptor() {
        return LLVMStructSetBody.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMStructSetBody(LLVMTypeRef StructTy, LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static MethodHandle LLVMStructSetBody$handle() {
        return LLVMStructSetBody.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMStructSetBody(LLVMTypeRef StructTy, LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMStructSetBody$address() {
        return LLVMStructSetBody.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMStructSetBody(LLVMTypeRef StructTy, LLVMTypeRef *ElementTypes, unsigned int ElementCount, LLVMBool Packed)
     * }
     */
    public static void LLVMStructSetBody(MemorySegment StructTy, MemorySegment ElementTypes, int ElementCount, int Packed) {
        var mh$ = LLVMStructSetBody.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStructSetBody", StructTy, ElementTypes, ElementCount, Packed);
            }
            mh$.invokeExact(StructTy, ElementTypes, ElementCount, Packed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCountStructElementTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCountStructElementTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCountStructElementTypes(LLVMTypeRef StructTy)
     * }
     */
    public static FunctionDescriptor LLVMCountStructElementTypes$descriptor() {
        return LLVMCountStructElementTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCountStructElementTypes(LLVMTypeRef StructTy)
     * }
     */
    public static MethodHandle LLVMCountStructElementTypes$handle() {
        return LLVMCountStructElementTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCountStructElementTypes(LLVMTypeRef StructTy)
     * }
     */
    public static MemorySegment LLVMCountStructElementTypes$address() {
        return LLVMCountStructElementTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCountStructElementTypes(LLVMTypeRef StructTy)
     * }
     */
    public static int LLVMCountStructElementTypes(MemorySegment StructTy) {
        var mh$ = LLVMCountStructElementTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCountStructElementTypes", StructTy);
            }
            return (int)mh$.invokeExact(StructTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetStructElementTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetStructElementTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetStructElementTypes(LLVMTypeRef StructTy, LLVMTypeRef *Dest)
     * }
     */
    public static FunctionDescriptor LLVMGetStructElementTypes$descriptor() {
        return LLVMGetStructElementTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetStructElementTypes(LLVMTypeRef StructTy, LLVMTypeRef *Dest)
     * }
     */
    public static MethodHandle LLVMGetStructElementTypes$handle() {
        return LLVMGetStructElementTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetStructElementTypes(LLVMTypeRef StructTy, LLVMTypeRef *Dest)
     * }
     */
    public static MemorySegment LLVMGetStructElementTypes$address() {
        return LLVMGetStructElementTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetStructElementTypes(LLVMTypeRef StructTy, LLVMTypeRef *Dest)
     * }
     */
    public static void LLVMGetStructElementTypes(MemorySegment StructTy, MemorySegment Dest) {
        var mh$ = LLVMGetStructElementTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetStructElementTypes", StructTy, Dest);
            }
            mh$.invokeExact(StructTy, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStructGetTypeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStructGetTypeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructGetTypeAtIndex(LLVMTypeRef StructTy, unsigned int i)
     * }
     */
    public static FunctionDescriptor LLVMStructGetTypeAtIndex$descriptor() {
        return LLVMStructGetTypeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructGetTypeAtIndex(LLVMTypeRef StructTy, unsigned int i)
     * }
     */
    public static MethodHandle LLVMStructGetTypeAtIndex$handle() {
        return LLVMStructGetTypeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructGetTypeAtIndex(LLVMTypeRef StructTy, unsigned int i)
     * }
     */
    public static MemorySegment LLVMStructGetTypeAtIndex$address() {
        return LLVMStructGetTypeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMStructGetTypeAtIndex(LLVMTypeRef StructTy, unsigned int i)
     * }
     */
    public static MemorySegment LLVMStructGetTypeAtIndex(MemorySegment StructTy, int i) {
        var mh$ = LLVMStructGetTypeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStructGetTypeAtIndex", StructTy, i);
            }
            return (MemorySegment)mh$.invokeExact(StructTy, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsPackedStruct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsPackedStruct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsPackedStruct(LLVMTypeRef StructTy)
     * }
     */
    public static FunctionDescriptor LLVMIsPackedStruct$descriptor() {
        return LLVMIsPackedStruct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsPackedStruct(LLVMTypeRef StructTy)
     * }
     */
    public static MethodHandle LLVMIsPackedStruct$handle() {
        return LLVMIsPackedStruct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsPackedStruct(LLVMTypeRef StructTy)
     * }
     */
    public static MemorySegment LLVMIsPackedStruct$address() {
        return LLVMIsPackedStruct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsPackedStruct(LLVMTypeRef StructTy)
     * }
     */
    public static int LLVMIsPackedStruct(MemorySegment StructTy) {
        var mh$ = LLVMIsPackedStruct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsPackedStruct", StructTy);
            }
            return (int)mh$.invokeExact(StructTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsOpaqueStruct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsOpaqueStruct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsOpaqueStruct(LLVMTypeRef StructTy)
     * }
     */
    public static FunctionDescriptor LLVMIsOpaqueStruct$descriptor() {
        return LLVMIsOpaqueStruct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsOpaqueStruct(LLVMTypeRef StructTy)
     * }
     */
    public static MethodHandle LLVMIsOpaqueStruct$handle() {
        return LLVMIsOpaqueStruct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsOpaqueStruct(LLVMTypeRef StructTy)
     * }
     */
    public static MemorySegment LLVMIsOpaqueStruct$address() {
        return LLVMIsOpaqueStruct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsOpaqueStruct(LLVMTypeRef StructTy)
     * }
     */
    public static int LLVMIsOpaqueStruct(MemorySegment StructTy) {
        var mh$ = LLVMIsOpaqueStruct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsOpaqueStruct", StructTy);
            }
            return (int)mh$.invokeExact(StructTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsLiteralStruct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsLiteralStruct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsLiteralStruct(LLVMTypeRef StructTy)
     * }
     */
    public static FunctionDescriptor LLVMIsLiteralStruct$descriptor() {
        return LLVMIsLiteralStruct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsLiteralStruct(LLVMTypeRef StructTy)
     * }
     */
    public static MethodHandle LLVMIsLiteralStruct$handle() {
        return LLVMIsLiteralStruct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsLiteralStruct(LLVMTypeRef StructTy)
     * }
     */
    public static MemorySegment LLVMIsLiteralStruct$address() {
        return LLVMIsLiteralStruct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsLiteralStruct(LLVMTypeRef StructTy)
     * }
     */
    public static int LLVMIsLiteralStruct(MemorySegment StructTy) {
        var mh$ = LLVMIsLiteralStruct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsLiteralStruct", StructTy);
            }
            return (int)mh$.invokeExact(StructTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetElementType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetElementType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetElementType(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMGetElementType$descriptor() {
        return LLVMGetElementType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetElementType(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMGetElementType$handle() {
        return LLVMGetElementType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetElementType(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetElementType$address() {
        return LLVMGetElementType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetElementType(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetElementType(MemorySegment Ty) {
        var mh$ = LLVMGetElementType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetElementType", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetSubtypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetSubtypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetSubtypes(LLVMTypeRef Tp, LLVMTypeRef *Arr)
     * }
     */
    public static FunctionDescriptor LLVMGetSubtypes$descriptor() {
        return LLVMGetSubtypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetSubtypes(LLVMTypeRef Tp, LLVMTypeRef *Arr)
     * }
     */
    public static MethodHandle LLVMGetSubtypes$handle() {
        return LLVMGetSubtypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetSubtypes(LLVMTypeRef Tp, LLVMTypeRef *Arr)
     * }
     */
    public static MemorySegment LLVMGetSubtypes$address() {
        return LLVMGetSubtypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetSubtypes(LLVMTypeRef Tp, LLVMTypeRef *Arr)
     * }
     */
    public static void LLVMGetSubtypes(MemorySegment Tp, MemorySegment Arr) {
        var mh$ = LLVMGetSubtypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetSubtypes", Tp, Arr);
            }
            mh$.invokeExact(Tp, Arr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumContainedTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumContainedTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumContainedTypes(LLVMTypeRef Tp)
     * }
     */
    public static FunctionDescriptor LLVMGetNumContainedTypes$descriptor() {
        return LLVMGetNumContainedTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumContainedTypes(LLVMTypeRef Tp)
     * }
     */
    public static MethodHandle LLVMGetNumContainedTypes$handle() {
        return LLVMGetNumContainedTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumContainedTypes(LLVMTypeRef Tp)
     * }
     */
    public static MemorySegment LLVMGetNumContainedTypes$address() {
        return LLVMGetNumContainedTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumContainedTypes(LLVMTypeRef Tp)
     * }
     */
    public static int LLVMGetNumContainedTypes(MemorySegment Tp) {
        var mh$ = LLVMGetNumContainedTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumContainedTypes", Tp);
            }
            return (int)mh$.invokeExact(Tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMArrayType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMArrayType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMArrayType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static FunctionDescriptor LLVMArrayType$descriptor() {
        return LLVMArrayType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMArrayType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MethodHandle LLVMArrayType$handle() {
        return LLVMArrayType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMArrayType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MemorySegment LLVMArrayType$address() {
        return LLVMArrayType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMArrayType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MemorySegment LLVMArrayType(MemorySegment ElementType, int ElementCount) {
        var mh$ = LLVMArrayType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMArrayType", ElementType, ElementCount);
            }
            return (MemorySegment)mh$.invokeExact(ElementType, ElementCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMArrayType2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMArrayType2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMArrayType2(LLVMTypeRef ElementType, uint64_t ElementCount)
     * }
     */
    public static FunctionDescriptor LLVMArrayType2$descriptor() {
        return LLVMArrayType2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMArrayType2(LLVMTypeRef ElementType, uint64_t ElementCount)
     * }
     */
    public static MethodHandle LLVMArrayType2$handle() {
        return LLVMArrayType2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMArrayType2(LLVMTypeRef ElementType, uint64_t ElementCount)
     * }
     */
    public static MemorySegment LLVMArrayType2$address() {
        return LLVMArrayType2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMArrayType2(LLVMTypeRef ElementType, uint64_t ElementCount)
     * }
     */
    public static MemorySegment LLVMArrayType2(MemorySegment ElementType, long ElementCount) {
        var mh$ = LLVMArrayType2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMArrayType2", ElementType, ElementCount);
            }
            return (MemorySegment)mh$.invokeExact(ElementType, ElementCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetArrayLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetArrayLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetArrayLength(LLVMTypeRef ArrayTy)
     * }
     */
    public static FunctionDescriptor LLVMGetArrayLength$descriptor() {
        return LLVMGetArrayLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetArrayLength(LLVMTypeRef ArrayTy)
     * }
     */
    public static MethodHandle LLVMGetArrayLength$handle() {
        return LLVMGetArrayLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetArrayLength(LLVMTypeRef ArrayTy)
     * }
     */
    public static MemorySegment LLVMGetArrayLength$address() {
        return LLVMGetArrayLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetArrayLength(LLVMTypeRef ArrayTy)
     * }
     */
    public static int LLVMGetArrayLength(MemorySegment ArrayTy) {
        var mh$ = LLVMGetArrayLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetArrayLength", ArrayTy);
            }
            return (int)mh$.invokeExact(ArrayTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetArrayLength2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetArrayLength2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t LLVMGetArrayLength2(LLVMTypeRef ArrayTy)
     * }
     */
    public static FunctionDescriptor LLVMGetArrayLength2$descriptor() {
        return LLVMGetArrayLength2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t LLVMGetArrayLength2(LLVMTypeRef ArrayTy)
     * }
     */
    public static MethodHandle LLVMGetArrayLength2$handle() {
        return LLVMGetArrayLength2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t LLVMGetArrayLength2(LLVMTypeRef ArrayTy)
     * }
     */
    public static MemorySegment LLVMGetArrayLength2$address() {
        return LLVMGetArrayLength2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t LLVMGetArrayLength2(LLVMTypeRef ArrayTy)
     * }
     */
    public static long LLVMGetArrayLength2(MemorySegment ArrayTy) {
        var mh$ = LLVMGetArrayLength2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetArrayLength2", ArrayTy);
            }
            return (long)mh$.invokeExact(ArrayTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPointerType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPointerType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPointerType(LLVMTypeRef ElementType, unsigned int AddressSpace)
     * }
     */
    public static FunctionDescriptor LLVMPointerType$descriptor() {
        return LLVMPointerType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPointerType(LLVMTypeRef ElementType, unsigned int AddressSpace)
     * }
     */
    public static MethodHandle LLVMPointerType$handle() {
        return LLVMPointerType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPointerType(LLVMTypeRef ElementType, unsigned int AddressSpace)
     * }
     */
    public static MemorySegment LLVMPointerType$address() {
        return LLVMPointerType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPointerType(LLVMTypeRef ElementType, unsigned int AddressSpace)
     * }
     */
    public static MemorySegment LLVMPointerType(MemorySegment ElementType, int AddressSpace) {
        var mh$ = LLVMPointerType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPointerType", ElementType, AddressSpace);
            }
            return (MemorySegment)mh$.invokeExact(ElementType, AddressSpace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPointerTypeIsOpaque {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPointerTypeIsOpaque");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMPointerTypeIsOpaque(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMPointerTypeIsOpaque$descriptor() {
        return LLVMPointerTypeIsOpaque.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMPointerTypeIsOpaque(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMPointerTypeIsOpaque$handle() {
        return LLVMPointerTypeIsOpaque.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMPointerTypeIsOpaque(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMPointerTypeIsOpaque$address() {
        return LLVMPointerTypeIsOpaque.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMPointerTypeIsOpaque(LLVMTypeRef Ty)
     * }
     */
    public static int LLVMPointerTypeIsOpaque(MemorySegment Ty) {
        var mh$ = LLVMPointerTypeIsOpaque.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPointerTypeIsOpaque", Ty);
            }
            return (int)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPointerTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPointerTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPointerTypeInContext(LLVMContextRef C, unsigned int AddressSpace)
     * }
     */
    public static FunctionDescriptor LLVMPointerTypeInContext$descriptor() {
        return LLVMPointerTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPointerTypeInContext(LLVMContextRef C, unsigned int AddressSpace)
     * }
     */
    public static MethodHandle LLVMPointerTypeInContext$handle() {
        return LLVMPointerTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPointerTypeInContext(LLVMContextRef C, unsigned int AddressSpace)
     * }
     */
    public static MemorySegment LLVMPointerTypeInContext$address() {
        return LLVMPointerTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMPointerTypeInContext(LLVMContextRef C, unsigned int AddressSpace)
     * }
     */
    public static MemorySegment LLVMPointerTypeInContext(MemorySegment C, int AddressSpace) {
        var mh$ = LLVMPointerTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPointerTypeInContext", C, AddressSpace);
            }
            return (MemorySegment)mh$.invokeExact(C, AddressSpace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPointerAddressSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPointerAddressSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetPointerAddressSpace(LLVMTypeRef PointerTy)
     * }
     */
    public static FunctionDescriptor LLVMGetPointerAddressSpace$descriptor() {
        return LLVMGetPointerAddressSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetPointerAddressSpace(LLVMTypeRef PointerTy)
     * }
     */
    public static MethodHandle LLVMGetPointerAddressSpace$handle() {
        return LLVMGetPointerAddressSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetPointerAddressSpace(LLVMTypeRef PointerTy)
     * }
     */
    public static MemorySegment LLVMGetPointerAddressSpace$address() {
        return LLVMGetPointerAddressSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetPointerAddressSpace(LLVMTypeRef PointerTy)
     * }
     */
    public static int LLVMGetPointerAddressSpace(MemorySegment PointerTy) {
        var mh$ = LLVMGetPointerAddressSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPointerAddressSpace", PointerTy);
            }
            return (int)mh$.invokeExact(PointerTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMVectorType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMVectorType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVectorType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static FunctionDescriptor LLVMVectorType$descriptor() {
        return LLVMVectorType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVectorType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MethodHandle LLVMVectorType$handle() {
        return LLVMVectorType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVectorType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MemorySegment LLVMVectorType$address() {
        return LLVMVectorType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVectorType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MemorySegment LLVMVectorType(MemorySegment ElementType, int ElementCount) {
        var mh$ = LLVMVectorType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMVectorType", ElementType, ElementCount);
            }
            return (MemorySegment)mh$.invokeExact(ElementType, ElementCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMScalableVectorType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMScalableVectorType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMScalableVectorType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static FunctionDescriptor LLVMScalableVectorType$descriptor() {
        return LLVMScalableVectorType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMScalableVectorType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MethodHandle LLVMScalableVectorType$handle() {
        return LLVMScalableVectorType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMScalableVectorType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MemorySegment LLVMScalableVectorType$address() {
        return LLVMScalableVectorType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMScalableVectorType(LLVMTypeRef ElementType, unsigned int ElementCount)
     * }
     */
    public static MemorySegment LLVMScalableVectorType(MemorySegment ElementType, int ElementCount) {
        var mh$ = LLVMScalableVectorType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMScalableVectorType", ElementType, ElementCount);
            }
            return (MemorySegment)mh$.invokeExact(ElementType, ElementCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetVectorSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetVectorSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetVectorSize(LLVMTypeRef VectorTy)
     * }
     */
    public static FunctionDescriptor LLVMGetVectorSize$descriptor() {
        return LLVMGetVectorSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetVectorSize(LLVMTypeRef VectorTy)
     * }
     */
    public static MethodHandle LLVMGetVectorSize$handle() {
        return LLVMGetVectorSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetVectorSize(LLVMTypeRef VectorTy)
     * }
     */
    public static MemorySegment LLVMGetVectorSize$address() {
        return LLVMGetVectorSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetVectorSize(LLVMTypeRef VectorTy)
     * }
     */
    public static int LLVMGetVectorSize(MemorySegment VectorTy) {
        var mh$ = LLVMGetVectorSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetVectorSize", VectorTy);
            }
            return (int)mh$.invokeExact(VectorTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetConstantPtrAuthPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetConstantPtrAuthPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthPointer(LLVMValueRef PtrAuth)
     * }
     */
    public static FunctionDescriptor LLVMGetConstantPtrAuthPointer$descriptor() {
        return LLVMGetConstantPtrAuthPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthPointer(LLVMValueRef PtrAuth)
     * }
     */
    public static MethodHandle LLVMGetConstantPtrAuthPointer$handle() {
        return LLVMGetConstantPtrAuthPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthPointer(LLVMValueRef PtrAuth)
     * }
     */
    public static MemorySegment LLVMGetConstantPtrAuthPointer$address() {
        return LLVMGetConstantPtrAuthPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthPointer(LLVMValueRef PtrAuth)
     * }
     */
    public static MemorySegment LLVMGetConstantPtrAuthPointer(MemorySegment PtrAuth) {
        var mh$ = LLVMGetConstantPtrAuthPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetConstantPtrAuthPointer", PtrAuth);
            }
            return (MemorySegment)mh$.invokeExact(PtrAuth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetConstantPtrAuthKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetConstantPtrAuthKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthKey(LLVMValueRef PtrAuth)
     * }
     */
    public static FunctionDescriptor LLVMGetConstantPtrAuthKey$descriptor() {
        return LLVMGetConstantPtrAuthKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthKey(LLVMValueRef PtrAuth)
     * }
     */
    public static MethodHandle LLVMGetConstantPtrAuthKey$handle() {
        return LLVMGetConstantPtrAuthKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthKey(LLVMValueRef PtrAuth)
     * }
     */
    public static MemorySegment LLVMGetConstantPtrAuthKey$address() {
        return LLVMGetConstantPtrAuthKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthKey(LLVMValueRef PtrAuth)
     * }
     */
    public static MemorySegment LLVMGetConstantPtrAuthKey(MemorySegment PtrAuth) {
        var mh$ = LLVMGetConstantPtrAuthKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetConstantPtrAuthKey", PtrAuth);
            }
            return (MemorySegment)mh$.invokeExact(PtrAuth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetConstantPtrAuthDiscriminator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetConstantPtrAuthDiscriminator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthDiscriminator(LLVMValueRef PtrAuth)
     * }
     */
    public static FunctionDescriptor LLVMGetConstantPtrAuthDiscriminator$descriptor() {
        return LLVMGetConstantPtrAuthDiscriminator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthDiscriminator(LLVMValueRef PtrAuth)
     * }
     */
    public static MethodHandle LLVMGetConstantPtrAuthDiscriminator$handle() {
        return LLVMGetConstantPtrAuthDiscriminator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthDiscriminator(LLVMValueRef PtrAuth)
     * }
     */
    public static MemorySegment LLVMGetConstantPtrAuthDiscriminator$address() {
        return LLVMGetConstantPtrAuthDiscriminator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthDiscriminator(LLVMValueRef PtrAuth)
     * }
     */
    public static MemorySegment LLVMGetConstantPtrAuthDiscriminator(MemorySegment PtrAuth) {
        var mh$ = LLVMGetConstantPtrAuthDiscriminator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetConstantPtrAuthDiscriminator", PtrAuth);
            }
            return (MemorySegment)mh$.invokeExact(PtrAuth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetConstantPtrAuthAddrDiscriminator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetConstantPtrAuthAddrDiscriminator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthAddrDiscriminator(LLVMValueRef PtrAuth)
     * }
     */
    public static FunctionDescriptor LLVMGetConstantPtrAuthAddrDiscriminator$descriptor() {
        return LLVMGetConstantPtrAuthAddrDiscriminator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthAddrDiscriminator(LLVMValueRef PtrAuth)
     * }
     */
    public static MethodHandle LLVMGetConstantPtrAuthAddrDiscriminator$handle() {
        return LLVMGetConstantPtrAuthAddrDiscriminator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthAddrDiscriminator(LLVMValueRef PtrAuth)
     * }
     */
    public static MemorySegment LLVMGetConstantPtrAuthAddrDiscriminator$address() {
        return LLVMGetConstantPtrAuthAddrDiscriminator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetConstantPtrAuthAddrDiscriminator(LLVMValueRef PtrAuth)
     * }
     */
    public static MemorySegment LLVMGetConstantPtrAuthAddrDiscriminator(MemorySegment PtrAuth) {
        var mh$ = LLVMGetConstantPtrAuthAddrDiscriminator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetConstantPtrAuthAddrDiscriminator", PtrAuth);
            }
            return (MemorySegment)mh$.invokeExact(PtrAuth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMVoidTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMVoidTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVoidTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMVoidTypeInContext$descriptor() {
        return LLVMVoidTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVoidTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMVoidTypeInContext$handle() {
        return LLVMVoidTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVoidTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMVoidTypeInContext$address() {
        return LLVMVoidTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVoidTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMVoidTypeInContext(MemorySegment C) {
        var mh$ = LLVMVoidTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMVoidTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMLabelTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMLabelTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMLabelTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMLabelTypeInContext$descriptor() {
        return LLVMLabelTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMLabelTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMLabelTypeInContext$handle() {
        return LLVMLabelTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMLabelTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMLabelTypeInContext$address() {
        return LLVMLabelTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMLabelTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMLabelTypeInContext(MemorySegment C) {
        var mh$ = LLVMLabelTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMLabelTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMX86AMXTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMX86AMXTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86AMXTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMX86AMXTypeInContext$descriptor() {
        return LLVMX86AMXTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86AMXTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMX86AMXTypeInContext$handle() {
        return LLVMX86AMXTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86AMXTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMX86AMXTypeInContext$address() {
        return LLVMX86AMXTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86AMXTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMX86AMXTypeInContext(MemorySegment C) {
        var mh$ = LLVMX86AMXTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMX86AMXTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTokenTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTokenTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTokenTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMTokenTypeInContext$descriptor() {
        return LLVMTokenTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTokenTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMTokenTypeInContext$handle() {
        return LLVMTokenTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTokenTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMTokenTypeInContext$address() {
        return LLVMTokenTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTokenTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMTokenTypeInContext(MemorySegment C) {
        var mh$ = LLVMTokenTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTokenTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMetadataTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMetadataTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMMetadataTypeInContext$descriptor() {
        return LLVMMetadataTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMMetadataTypeInContext$handle() {
        return LLVMMetadataTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMMetadataTypeInContext$address() {
        return LLVMMetadataTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMMetadataTypeInContext(MemorySegment C) {
        var mh$ = LLVMMetadataTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMetadataTypeInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMVoidType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMVoidType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVoidType()
     * }
     */
    public static FunctionDescriptor LLVMVoidType$descriptor() {
        return LLVMVoidType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVoidType()
     * }
     */
    public static MethodHandle LLVMVoidType$handle() {
        return LLVMVoidType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVoidType()
     * }
     */
    public static MemorySegment LLVMVoidType$address() {
        return LLVMVoidType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMVoidType()
     * }
     */
    public static MemorySegment LLVMVoidType() {
        var mh$ = LLVMVoidType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMVoidType");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMLabelType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMLabelType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMLabelType()
     * }
     */
    public static FunctionDescriptor LLVMLabelType$descriptor() {
        return LLVMLabelType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMLabelType()
     * }
     */
    public static MethodHandle LLVMLabelType$handle() {
        return LLVMLabelType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMLabelType()
     * }
     */
    public static MemorySegment LLVMLabelType$address() {
        return LLVMLabelType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMLabelType()
     * }
     */
    public static MemorySegment LLVMLabelType() {
        var mh$ = LLVMLabelType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMLabelType");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMX86AMXType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMX86AMXType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86AMXType()
     * }
     */
    public static FunctionDescriptor LLVMX86AMXType$descriptor() {
        return LLVMX86AMXType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86AMXType()
     * }
     */
    public static MethodHandle LLVMX86AMXType$handle() {
        return LLVMX86AMXType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86AMXType()
     * }
     */
    public static MemorySegment LLVMX86AMXType$address() {
        return LLVMX86AMXType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMX86AMXType()
     * }
     */
    public static MemorySegment LLVMX86AMXType() {
        var mh$ = LLVMX86AMXType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMX86AMXType");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTargetExtTypeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTargetExtTypeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTargetExtTypeInContext(LLVMContextRef C, const char *Name, LLVMTypeRef *TypeParams, unsigned int TypeParamCount, unsigned int *IntParams, unsigned int IntParamCount)
     * }
     */
    public static FunctionDescriptor LLVMTargetExtTypeInContext$descriptor() {
        return LLVMTargetExtTypeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTargetExtTypeInContext(LLVMContextRef C, const char *Name, LLVMTypeRef *TypeParams, unsigned int TypeParamCount, unsigned int *IntParams, unsigned int IntParamCount)
     * }
     */
    public static MethodHandle LLVMTargetExtTypeInContext$handle() {
        return LLVMTargetExtTypeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTargetExtTypeInContext(LLVMContextRef C, const char *Name, LLVMTypeRef *TypeParams, unsigned int TypeParamCount, unsigned int *IntParams, unsigned int IntParamCount)
     * }
     */
    public static MemorySegment LLVMTargetExtTypeInContext$address() {
        return LLVMTargetExtTypeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTargetExtTypeInContext(LLVMContextRef C, const char *Name, LLVMTypeRef *TypeParams, unsigned int TypeParamCount, unsigned int *IntParams, unsigned int IntParamCount)
     * }
     */
    public static MemorySegment LLVMTargetExtTypeInContext(MemorySegment C, MemorySegment Name, MemorySegment TypeParams, int TypeParamCount, MemorySegment IntParams, int IntParamCount) {
        var mh$ = LLVMTargetExtTypeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTargetExtTypeInContext", C, Name, TypeParams, TypeParamCount, IntParams, IntParamCount);
            }
            return (MemorySegment)mh$.invokeExact(C, Name, TypeParams, TypeParamCount, IntParams, IntParamCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetExtTypeName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetExtTypeName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetExtTypeName(LLVMTypeRef TargetExtTy)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetExtTypeName$descriptor() {
        return LLVMGetTargetExtTypeName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetExtTypeName(LLVMTypeRef TargetExtTy)
     * }
     */
    public static MethodHandle LLVMGetTargetExtTypeName$handle() {
        return LLVMGetTargetExtTypeName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetTargetExtTypeName(LLVMTypeRef TargetExtTy)
     * }
     */
    public static MemorySegment LLVMGetTargetExtTypeName$address() {
        return LLVMGetTargetExtTypeName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetTargetExtTypeName(LLVMTypeRef TargetExtTy)
     * }
     */
    public static MemorySegment LLVMGetTargetExtTypeName(MemorySegment TargetExtTy) {
        var mh$ = LLVMGetTargetExtTypeName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetExtTypeName", TargetExtTy);
            }
            return (MemorySegment)mh$.invokeExact(TargetExtTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetExtTypeNumTypeParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetExtTypeNumTypeParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeNumTypeParams(LLVMTypeRef TargetExtTy)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetExtTypeNumTypeParams$descriptor() {
        return LLVMGetTargetExtTypeNumTypeParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeNumTypeParams(LLVMTypeRef TargetExtTy)
     * }
     */
    public static MethodHandle LLVMGetTargetExtTypeNumTypeParams$handle() {
        return LLVMGetTargetExtTypeNumTypeParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeNumTypeParams(LLVMTypeRef TargetExtTy)
     * }
     */
    public static MemorySegment LLVMGetTargetExtTypeNumTypeParams$address() {
        return LLVMGetTargetExtTypeNumTypeParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeNumTypeParams(LLVMTypeRef TargetExtTy)
     * }
     */
    public static int LLVMGetTargetExtTypeNumTypeParams(MemorySegment TargetExtTy) {
        var mh$ = LLVMGetTargetExtTypeNumTypeParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetExtTypeNumTypeParams", TargetExtTy);
            }
            return (int)mh$.invokeExact(TargetExtTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetExtTypeTypeParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetExtTypeTypeParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTargetExtTypeTypeParam(LLVMTypeRef TargetExtTy, unsigned int Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetExtTypeTypeParam$descriptor() {
        return LLVMGetTargetExtTypeTypeParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTargetExtTypeTypeParam(LLVMTypeRef TargetExtTy, unsigned int Idx)
     * }
     */
    public static MethodHandle LLVMGetTargetExtTypeTypeParam$handle() {
        return LLVMGetTargetExtTypeTypeParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTargetExtTypeTypeParam(LLVMTypeRef TargetExtTy, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetTargetExtTypeTypeParam$address() {
        return LLVMGetTargetExtTypeTypeParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetTargetExtTypeTypeParam(LLVMTypeRef TargetExtTy, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetTargetExtTypeTypeParam(MemorySegment TargetExtTy, int Idx) {
        var mh$ = LLVMGetTargetExtTypeTypeParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetExtTypeTypeParam", TargetExtTy, Idx);
            }
            return (MemorySegment)mh$.invokeExact(TargetExtTy, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetExtTypeNumIntParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetExtTypeNumIntParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeNumIntParams(LLVMTypeRef TargetExtTy)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetExtTypeNumIntParams$descriptor() {
        return LLVMGetTargetExtTypeNumIntParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeNumIntParams(LLVMTypeRef TargetExtTy)
     * }
     */
    public static MethodHandle LLVMGetTargetExtTypeNumIntParams$handle() {
        return LLVMGetTargetExtTypeNumIntParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeNumIntParams(LLVMTypeRef TargetExtTy)
     * }
     */
    public static MemorySegment LLVMGetTargetExtTypeNumIntParams$address() {
        return LLVMGetTargetExtTypeNumIntParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeNumIntParams(LLVMTypeRef TargetExtTy)
     * }
     */
    public static int LLVMGetTargetExtTypeNumIntParams(MemorySegment TargetExtTy) {
        var mh$ = LLVMGetTargetExtTypeNumIntParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetExtTypeNumIntParams", TargetExtTy);
            }
            return (int)mh$.invokeExact(TargetExtTy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTargetExtTypeIntParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTargetExtTypeIntParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeIntParam(LLVMTypeRef TargetExtTy, unsigned int Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetTargetExtTypeIntParam$descriptor() {
        return LLVMGetTargetExtTypeIntParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeIntParam(LLVMTypeRef TargetExtTy, unsigned int Idx)
     * }
     */
    public static MethodHandle LLVMGetTargetExtTypeIntParam$handle() {
        return LLVMGetTargetExtTypeIntParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeIntParam(LLVMTypeRef TargetExtTy, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetTargetExtTypeIntParam$address() {
        return LLVMGetTargetExtTypeIntParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetTargetExtTypeIntParam(LLVMTypeRef TargetExtTy, unsigned int Idx)
     * }
     */
    public static int LLVMGetTargetExtTypeIntParam(MemorySegment TargetExtTy, int Idx) {
        var mh$ = LLVMGetTargetExtTypeIntParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTargetExtTypeIntParam", TargetExtTy, Idx);
            }
            return (int)mh$.invokeExact(TargetExtTy, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMTypeOf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMTypeOf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTypeOf(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMTypeOf$descriptor() {
        return LLVMTypeOf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTypeOf(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMTypeOf$handle() {
        return LLVMTypeOf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTypeOf(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMTypeOf$address() {
        return LLVMTypeOf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMTypeOf(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMTypeOf(MemorySegment Val) {
        var mh$ = LLVMTypeOf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMTypeOf", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetValueKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetValueKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueKind LLVMGetValueKind(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMGetValueKind$descriptor() {
        return LLVMGetValueKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueKind LLVMGetValueKind(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMGetValueKind$handle() {
        return LLVMGetValueKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueKind LLVMGetValueKind(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetValueKind$address() {
        return LLVMGetValueKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueKind LLVMGetValueKind(LLVMValueRef Val)
     * }
     */
    public static int LLVMGetValueKind(MemorySegment Val) {
        var mh$ = LLVMGetValueKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetValueKind", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetValueName2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetValueName2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetValueName2(LLVMValueRef Val, size_t *Length)
     * }
     */
    public static FunctionDescriptor LLVMGetValueName2$descriptor() {
        return LLVMGetValueName2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetValueName2(LLVMValueRef Val, size_t *Length)
     * }
     */
    public static MethodHandle LLVMGetValueName2$handle() {
        return LLVMGetValueName2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetValueName2(LLVMValueRef Val, size_t *Length)
     * }
     */
    public static MemorySegment LLVMGetValueName2$address() {
        return LLVMGetValueName2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetValueName2(LLVMValueRef Val, size_t *Length)
     * }
     */
    public static MemorySegment LLVMGetValueName2(MemorySegment Val, MemorySegment Length) {
        var mh$ = LLVMGetValueName2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetValueName2", Val, Length);
            }
            return (MemorySegment)mh$.invokeExact(Val, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetValueName2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetValueName2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetValueName2(LLVMValueRef Val, const char *Name, size_t NameLen)
     * }
     */
    public static FunctionDescriptor LLVMSetValueName2$descriptor() {
        return LLVMSetValueName2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetValueName2(LLVMValueRef Val, const char *Name, size_t NameLen)
     * }
     */
    public static MethodHandle LLVMSetValueName2$handle() {
        return LLVMSetValueName2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetValueName2(LLVMValueRef Val, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMSetValueName2$address() {
        return LLVMSetValueName2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetValueName2(LLVMValueRef Val, const char *Name, size_t NameLen)
     * }
     */
    public static void LLVMSetValueName2(MemorySegment Val, MemorySegment Name, long NameLen) {
        var mh$ = LLVMSetValueName2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetValueName2", Val, Name, NameLen);
            }
            mh$.invokeExact(Val, Name, NameLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDumpValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDumpValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDumpValue(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMDumpValue$descriptor() {
        return LLVMDumpValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDumpValue(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMDumpValue$handle() {
        return LLVMDumpValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDumpValue(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMDumpValue$address() {
        return LLVMDumpValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDumpValue(LLVMValueRef Val)
     * }
     */
    public static void LLVMDumpValue(MemorySegment Val) {
        var mh$ = LLVMDumpValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDumpValue", Val);
            }
            mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPrintValueToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPrintValueToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMPrintValueToString(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMPrintValueToString$descriptor() {
        return LLVMPrintValueToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMPrintValueToString(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMPrintValueToString$handle() {
        return LLVMPrintValueToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMPrintValueToString(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMPrintValueToString$address() {
        return LLVMPrintValueToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMPrintValueToString(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMPrintValueToString(MemorySegment Val) {
        var mh$ = LLVMPrintValueToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPrintValueToString", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetValueContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetValueContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetValueContext(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMGetValueContext$descriptor() {
        return LLVMGetValueContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetValueContext(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMGetValueContext$handle() {
        return LLVMGetValueContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetValueContext(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetValueContext$address() {
        return LLVMGetValueContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetValueContext(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetValueContext(MemorySegment Val) {
        var mh$ = LLVMGetValueContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetValueContext", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPrintDbgRecordToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPrintDbgRecordToString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMPrintDbgRecordToString(LLVMDbgRecordRef Record)
     * }
     */
    public static FunctionDescriptor LLVMPrintDbgRecordToString$descriptor() {
        return LLVMPrintDbgRecordToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMPrintDbgRecordToString(LLVMDbgRecordRef Record)
     * }
     */
    public static MethodHandle LLVMPrintDbgRecordToString$handle() {
        return LLVMPrintDbgRecordToString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMPrintDbgRecordToString(LLVMDbgRecordRef Record)
     * }
     */
    public static MemorySegment LLVMPrintDbgRecordToString$address() {
        return LLVMPrintDbgRecordToString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMPrintDbgRecordToString(LLVMDbgRecordRef Record)
     * }
     */
    public static MemorySegment LLVMPrintDbgRecordToString(MemorySegment Record_) {
        var mh$ = LLVMPrintDbgRecordToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPrintDbgRecordToString", Record_);
            }
            return (MemorySegment)mh$.invokeExact(Record_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMReplaceAllUsesWith {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMReplaceAllUsesWith");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMReplaceAllUsesWith(LLVMValueRef OldVal, LLVMValueRef NewVal)
     * }
     */
    public static FunctionDescriptor LLVMReplaceAllUsesWith$descriptor() {
        return LLVMReplaceAllUsesWith.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMReplaceAllUsesWith(LLVMValueRef OldVal, LLVMValueRef NewVal)
     * }
     */
    public static MethodHandle LLVMReplaceAllUsesWith$handle() {
        return LLVMReplaceAllUsesWith.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMReplaceAllUsesWith(LLVMValueRef OldVal, LLVMValueRef NewVal)
     * }
     */
    public static MemorySegment LLVMReplaceAllUsesWith$address() {
        return LLVMReplaceAllUsesWith.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMReplaceAllUsesWith(LLVMValueRef OldVal, LLVMValueRef NewVal)
     * }
     */
    public static void LLVMReplaceAllUsesWith(MemorySegment OldVal, MemorySegment NewVal) {
        var mh$ = LLVMReplaceAllUsesWith.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMReplaceAllUsesWith", OldVal, NewVal);
            }
            mh$.invokeExact(OldVal, NewVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConstant(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsConstant$descriptor() {
        return LLVMIsConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConstant(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsConstant$handle() {
        return LLVMIsConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConstant(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsConstant$address() {
        return LLVMIsConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsConstant(LLVMValueRef Val)
     * }
     */
    public static int LLVMIsConstant(MemorySegment Val) {
        var mh$ = LLVMIsConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsConstant", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsUndef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsUndef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsUndef(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsUndef$descriptor() {
        return LLVMIsUndef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsUndef(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsUndef$handle() {
        return LLVMIsUndef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsUndef(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsUndef$address() {
        return LLVMIsUndef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsUndef(LLVMValueRef Val)
     * }
     */
    public static int LLVMIsUndef(MemorySegment Val) {
        var mh$ = LLVMIsUndef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsUndef", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsPoison {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsPoison");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsPoison(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsPoison$descriptor() {
        return LLVMIsPoison.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsPoison(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsPoison$handle() {
        return LLVMIsPoison.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsPoison(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsPoison$address() {
        return LLVMIsPoison.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsPoison(LLVMValueRef Val)
     * }
     */
    public static int LLVMIsPoison(MemorySegment Val) {
        var mh$ = LLVMIsPoison.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsPoison", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAArgument {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAArgument");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAArgument(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAArgument$descriptor() {
        return LLVMIsAArgument.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAArgument(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAArgument$handle() {
        return LLVMIsAArgument.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAArgument(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAArgument$address() {
        return LLVMIsAArgument.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAArgument(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAArgument(MemorySegment Val) {
        var mh$ = LLVMIsAArgument.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAArgument", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsABasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsABasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABasicBlock(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsABasicBlock$descriptor() {
        return LLVMIsABasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABasicBlock(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsABasicBlock$handle() {
        return LLVMIsABasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABasicBlock(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABasicBlock$address() {
        return LLVMIsABasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABasicBlock(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABasicBlock(MemorySegment Val) {
        var mh$ = LLVMIsABasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsABasicBlock", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAInlineAsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAInlineAsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInlineAsm(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAInlineAsm$descriptor() {
        return LLVMIsAInlineAsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInlineAsm(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAInlineAsm$handle() {
        return LLVMIsAInlineAsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInlineAsm(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInlineAsm$address() {
        return LLVMIsAInlineAsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInlineAsm(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInlineAsm(MemorySegment Val) {
        var mh$ = LLVMIsAInlineAsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAInlineAsm", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAUser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAUser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUser(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAUser$descriptor() {
        return LLVMIsAUser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUser(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAUser$handle() {
        return LLVMIsAUser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUser(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUser$address() {
        return LLVMIsAUser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUser(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUser(MemorySegment Val) {
        var mh$ = LLVMIsAUser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAUser", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstant(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstant$descriptor() {
        return LLVMIsAConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstant(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstant$handle() {
        return LLVMIsAConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstant(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstant$address() {
        return LLVMIsAConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstant(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstant(MemorySegment Val) {
        var mh$ = LLVMIsAConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstant", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsABlockAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsABlockAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABlockAddress(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsABlockAddress$descriptor() {
        return LLVMIsABlockAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABlockAddress(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsABlockAddress$handle() {
        return LLVMIsABlockAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABlockAddress(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABlockAddress$address() {
        return LLVMIsABlockAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABlockAddress(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABlockAddress(MemorySegment Val) {
        var mh$ = LLVMIsABlockAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsABlockAddress", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantAggregateZero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantAggregateZero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantAggregateZero(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantAggregateZero$descriptor() {
        return LLVMIsAConstantAggregateZero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantAggregateZero(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantAggregateZero$handle() {
        return LLVMIsAConstantAggregateZero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantAggregateZero(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantAggregateZero$address() {
        return LLVMIsAConstantAggregateZero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantAggregateZero(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantAggregateZero(MemorySegment Val) {
        var mh$ = LLVMIsAConstantAggregateZero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantAggregateZero", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantArray(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantArray$descriptor() {
        return LLVMIsAConstantArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantArray(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantArray$handle() {
        return LLVMIsAConstantArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantArray(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantArray$address() {
        return LLVMIsAConstantArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantArray(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantArray(MemorySegment Val) {
        var mh$ = LLVMIsAConstantArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantArray", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantDataSequential {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantDataSequential");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataSequential(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantDataSequential$descriptor() {
        return LLVMIsAConstantDataSequential.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataSequential(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantDataSequential$handle() {
        return LLVMIsAConstantDataSequential.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataSequential(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantDataSequential$address() {
        return LLVMIsAConstantDataSequential.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataSequential(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantDataSequential(MemorySegment Val) {
        var mh$ = LLVMIsAConstantDataSequential.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantDataSequential", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantDataArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantDataArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataArray(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantDataArray$descriptor() {
        return LLVMIsAConstantDataArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataArray(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantDataArray$handle() {
        return LLVMIsAConstantDataArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataArray(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantDataArray$address() {
        return LLVMIsAConstantDataArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataArray(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantDataArray(MemorySegment Val) {
        var mh$ = LLVMIsAConstantDataArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantDataArray", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantDataVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantDataVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataVector(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantDataVector$descriptor() {
        return LLVMIsAConstantDataVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataVector(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantDataVector$handle() {
        return LLVMIsAConstantDataVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataVector(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantDataVector$address() {
        return LLVMIsAConstantDataVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantDataVector(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantDataVector(MemorySegment Val) {
        var mh$ = LLVMIsAConstantDataVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantDataVector", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantExpr(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantExpr$descriptor() {
        return LLVMIsAConstantExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantExpr(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantExpr$handle() {
        return LLVMIsAConstantExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantExpr(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantExpr$address() {
        return LLVMIsAConstantExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantExpr(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantExpr(MemorySegment Val) {
        var mh$ = LLVMIsAConstantExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantExpr", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantFP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantFP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantFP(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantFP$descriptor() {
        return LLVMIsAConstantFP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantFP(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantFP$handle() {
        return LLVMIsAConstantFP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantFP(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantFP$address() {
        return LLVMIsAConstantFP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantFP(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantFP(MemorySegment Val) {
        var mh$ = LLVMIsAConstantFP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantFP", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantInt(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantInt$descriptor() {
        return LLVMIsAConstantInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantInt(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantInt$handle() {
        return LLVMIsAConstantInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantInt(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantInt$address() {
        return LLVMIsAConstantInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantInt(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantInt(MemorySegment Val) {
        var mh$ = LLVMIsAConstantInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantInt", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantPointerNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantPointerNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantPointerNull(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantPointerNull$descriptor() {
        return LLVMIsAConstantPointerNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantPointerNull(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantPointerNull$handle() {
        return LLVMIsAConstantPointerNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantPointerNull(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantPointerNull$address() {
        return LLVMIsAConstantPointerNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantPointerNull(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantPointerNull(MemorySegment Val) {
        var mh$ = LLVMIsAConstantPointerNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantPointerNull", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantStruct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantStruct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantStruct(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantStruct$descriptor() {
        return LLVMIsAConstantStruct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantStruct(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantStruct$handle() {
        return LLVMIsAConstantStruct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantStruct(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantStruct$address() {
        return LLVMIsAConstantStruct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantStruct(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantStruct(MemorySegment Val) {
        var mh$ = LLVMIsAConstantStruct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantStruct", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantTokenNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantTokenNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantTokenNone(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantTokenNone$descriptor() {
        return LLVMIsAConstantTokenNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantTokenNone(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantTokenNone$handle() {
        return LLVMIsAConstantTokenNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantTokenNone(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantTokenNone$address() {
        return LLVMIsAConstantTokenNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantTokenNone(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantTokenNone(MemorySegment Val) {
        var mh$ = LLVMIsAConstantTokenNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantTokenNone", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantVector(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantVector$descriptor() {
        return LLVMIsAConstantVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantVector(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantVector$handle() {
        return LLVMIsAConstantVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantVector(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantVector$address() {
        return LLVMIsAConstantVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantVector(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantVector(MemorySegment Val) {
        var mh$ = LLVMIsAConstantVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantVector", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAConstantPtrAuth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAConstantPtrAuth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantPtrAuth(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAConstantPtrAuth$descriptor() {
        return LLVMIsAConstantPtrAuth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantPtrAuth(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAConstantPtrAuth$handle() {
        return LLVMIsAConstantPtrAuth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantPtrAuth(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantPtrAuth$address() {
        return LLVMIsAConstantPtrAuth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAConstantPtrAuth(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAConstantPtrAuth(MemorySegment Val) {
        var mh$ = LLVMIsAConstantPtrAuth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAConstantPtrAuth", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAGlobalValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAGlobalValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalValue(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAGlobalValue$descriptor() {
        return LLVMIsAGlobalValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalValue(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAGlobalValue$handle() {
        return LLVMIsAGlobalValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalValue(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalValue$address() {
        return LLVMIsAGlobalValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalValue(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalValue(MemorySegment Val) {
        var mh$ = LLVMIsAGlobalValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAGlobalValue", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAGlobalAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAGlobalAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalAlias(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAGlobalAlias$descriptor() {
        return LLVMIsAGlobalAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalAlias(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAGlobalAlias$handle() {
        return LLVMIsAGlobalAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalAlias(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalAlias$address() {
        return LLVMIsAGlobalAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalAlias(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalAlias(MemorySegment Val) {
        var mh$ = LLVMIsAGlobalAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAGlobalAlias", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAGlobalObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAGlobalObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalObject(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAGlobalObject$descriptor() {
        return LLVMIsAGlobalObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalObject(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAGlobalObject$handle() {
        return LLVMIsAGlobalObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalObject(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalObject$address() {
        return LLVMIsAGlobalObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalObject(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalObject(MemorySegment Val) {
        var mh$ = LLVMIsAGlobalObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAGlobalObject", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFunction(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFunction$descriptor() {
        return LLVMIsAFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFunction(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFunction$handle() {
        return LLVMIsAFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFunction(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFunction$address() {
        return LLVMIsAFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFunction(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFunction(MemorySegment Val) {
        var mh$ = LLVMIsAFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFunction", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAGlobalVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAGlobalVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalVariable(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAGlobalVariable$descriptor() {
        return LLVMIsAGlobalVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalVariable(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAGlobalVariable$handle() {
        return LLVMIsAGlobalVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalVariable(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalVariable$address() {
        return LLVMIsAGlobalVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalVariable(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalVariable(MemorySegment Val) {
        var mh$ = LLVMIsAGlobalVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAGlobalVariable", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalIFunc(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAGlobalIFunc$descriptor() {
        return LLVMIsAGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalIFunc(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAGlobalIFunc$handle() {
        return LLVMIsAGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalIFunc(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalIFunc$address() {
        return LLVMIsAGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGlobalIFunc(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGlobalIFunc(MemorySegment Val) {
        var mh$ = LLVMIsAGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAGlobalIFunc", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAUndefValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAUndefValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUndefValue(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAUndefValue$descriptor() {
        return LLVMIsAUndefValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUndefValue(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAUndefValue$handle() {
        return LLVMIsAUndefValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUndefValue(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUndefValue$address() {
        return LLVMIsAUndefValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUndefValue(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUndefValue(MemorySegment Val) {
        var mh$ = LLVMIsAUndefValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAUndefValue", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAPoisonValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAPoisonValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPoisonValue(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAPoisonValue$descriptor() {
        return LLVMIsAPoisonValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPoisonValue(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAPoisonValue$handle() {
        return LLVMIsAPoisonValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPoisonValue(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAPoisonValue$address() {
        return LLVMIsAPoisonValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPoisonValue(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAPoisonValue(MemorySegment Val) {
        var mh$ = LLVMIsAPoisonValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAPoisonValue", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInstruction(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAInstruction$descriptor() {
        return LLVMIsAInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInstruction(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAInstruction$handle() {
        return LLVMIsAInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInstruction(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInstruction$address() {
        return LLVMIsAInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInstruction(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInstruction(MemorySegment Val) {
        var mh$ = LLVMIsAInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAInstruction", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAUnaryOperator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAUnaryOperator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnaryOperator(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAUnaryOperator$descriptor() {
        return LLVMIsAUnaryOperator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnaryOperator(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAUnaryOperator$handle() {
        return LLVMIsAUnaryOperator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnaryOperator(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUnaryOperator$address() {
        return LLVMIsAUnaryOperator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnaryOperator(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUnaryOperator(MemorySegment Val) {
        var mh$ = LLVMIsAUnaryOperator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAUnaryOperator", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsABinaryOperator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsABinaryOperator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABinaryOperator(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsABinaryOperator$descriptor() {
        return LLVMIsABinaryOperator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABinaryOperator(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsABinaryOperator$handle() {
        return LLVMIsABinaryOperator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABinaryOperator(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABinaryOperator$address() {
        return LLVMIsABinaryOperator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABinaryOperator(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABinaryOperator(MemorySegment Val) {
        var mh$ = LLVMIsABinaryOperator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsABinaryOperator", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACallInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACallInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACallInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACallInst$descriptor() {
        return LLVMIsACallInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACallInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACallInst$handle() {
        return LLVMIsACallInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACallInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACallInst$address() {
        return LLVMIsACallInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACallInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACallInst(MemorySegment Val) {
        var mh$ = LLVMIsACallInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACallInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAIntrinsicInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAIntrinsicInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIntrinsicInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAIntrinsicInst$descriptor() {
        return LLVMIsAIntrinsicInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIntrinsicInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAIntrinsicInst$handle() {
        return LLVMIsAIntrinsicInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIntrinsicInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAIntrinsicInst$address() {
        return LLVMIsAIntrinsicInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIntrinsicInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAIntrinsicInst(MemorySegment Val) {
        var mh$ = LLVMIsAIntrinsicInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAIntrinsicInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsADbgInfoIntrinsic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsADbgInfoIntrinsic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsADbgInfoIntrinsic$descriptor() {
        return LLVMIsADbgInfoIntrinsic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsADbgInfoIntrinsic$handle() {
        return LLVMIsADbgInfoIntrinsic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsADbgInfoIntrinsic$address() {
        return LLVMIsADbgInfoIntrinsic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsADbgInfoIntrinsic(MemorySegment Val) {
        var mh$ = LLVMIsADbgInfoIntrinsic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsADbgInfoIntrinsic", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsADbgVariableIntrinsic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsADbgVariableIntrinsic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgVariableIntrinsic(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsADbgVariableIntrinsic$descriptor() {
        return LLVMIsADbgVariableIntrinsic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgVariableIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsADbgVariableIntrinsic$handle() {
        return LLVMIsADbgVariableIntrinsic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgVariableIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsADbgVariableIntrinsic$address() {
        return LLVMIsADbgVariableIntrinsic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgVariableIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsADbgVariableIntrinsic(MemorySegment Val) {
        var mh$ = LLVMIsADbgVariableIntrinsic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsADbgVariableIntrinsic", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsADbgDeclareInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsADbgDeclareInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgDeclareInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsADbgDeclareInst$descriptor() {
        return LLVMIsADbgDeclareInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgDeclareInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsADbgDeclareInst$handle() {
        return LLVMIsADbgDeclareInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgDeclareInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsADbgDeclareInst$address() {
        return LLVMIsADbgDeclareInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgDeclareInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsADbgDeclareInst(MemorySegment Val) {
        var mh$ = LLVMIsADbgDeclareInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsADbgDeclareInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsADbgLabelInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsADbgLabelInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgLabelInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsADbgLabelInst$descriptor() {
        return LLVMIsADbgLabelInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgLabelInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsADbgLabelInst$handle() {
        return LLVMIsADbgLabelInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgLabelInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsADbgLabelInst$address() {
        return LLVMIsADbgLabelInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsADbgLabelInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsADbgLabelInst(MemorySegment Val) {
        var mh$ = LLVMIsADbgLabelInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsADbgLabelInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAMemIntrinsic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAMemIntrinsic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemIntrinsic(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAMemIntrinsic$descriptor() {
        return LLVMIsAMemIntrinsic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAMemIntrinsic$handle() {
        return LLVMIsAMemIntrinsic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMemIntrinsic$address() {
        return LLVMIsAMemIntrinsic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemIntrinsic(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMemIntrinsic(MemorySegment Val) {
        var mh$ = LLVMIsAMemIntrinsic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAMemIntrinsic", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAMemCpyInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAMemCpyInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemCpyInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAMemCpyInst$descriptor() {
        return LLVMIsAMemCpyInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemCpyInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAMemCpyInst$handle() {
        return LLVMIsAMemCpyInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemCpyInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMemCpyInst$address() {
        return LLVMIsAMemCpyInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemCpyInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMemCpyInst(MemorySegment Val) {
        var mh$ = LLVMIsAMemCpyInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAMemCpyInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAMemMoveInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAMemMoveInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemMoveInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAMemMoveInst$descriptor() {
        return LLVMIsAMemMoveInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemMoveInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAMemMoveInst$handle() {
        return LLVMIsAMemMoveInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemMoveInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMemMoveInst$address() {
        return LLVMIsAMemMoveInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemMoveInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMemMoveInst(MemorySegment Val) {
        var mh$ = LLVMIsAMemMoveInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAMemMoveInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAMemSetInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAMemSetInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemSetInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAMemSetInst$descriptor() {
        return LLVMIsAMemSetInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemSetInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAMemSetInst$handle() {
        return LLVMIsAMemSetInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemSetInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMemSetInst$address() {
        return LLVMIsAMemSetInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMemSetInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMemSetInst(MemorySegment Val) {
        var mh$ = LLVMIsAMemSetInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAMemSetInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACmpInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACmpInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACmpInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACmpInst$descriptor() {
        return LLVMIsACmpInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACmpInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACmpInst$handle() {
        return LLVMIsACmpInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACmpInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACmpInst$address() {
        return LLVMIsACmpInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACmpInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACmpInst(MemorySegment Val) {
        var mh$ = LLVMIsACmpInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACmpInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFCmpInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFCmpInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFCmpInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFCmpInst$descriptor() {
        return LLVMIsAFCmpInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFCmpInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFCmpInst$handle() {
        return LLVMIsAFCmpInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFCmpInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFCmpInst$address() {
        return LLVMIsAFCmpInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFCmpInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFCmpInst(MemorySegment Val) {
        var mh$ = LLVMIsAFCmpInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFCmpInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAICmpInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAICmpInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAICmpInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAICmpInst$descriptor() {
        return LLVMIsAICmpInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAICmpInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAICmpInst$handle() {
        return LLVMIsAICmpInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAICmpInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAICmpInst$address() {
        return LLVMIsAICmpInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAICmpInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAICmpInst(MemorySegment Val) {
        var mh$ = LLVMIsAICmpInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAICmpInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAExtractElementInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAExtractElementInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAExtractElementInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAExtractElementInst$descriptor() {
        return LLVMIsAExtractElementInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAExtractElementInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAExtractElementInst$handle() {
        return LLVMIsAExtractElementInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAExtractElementInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAExtractElementInst$address() {
        return LLVMIsAExtractElementInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAExtractElementInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAExtractElementInst(MemorySegment Val) {
        var mh$ = LLVMIsAExtractElementInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAExtractElementInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAGetElementPtrInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAGetElementPtrInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGetElementPtrInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAGetElementPtrInst$descriptor() {
        return LLVMIsAGetElementPtrInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGetElementPtrInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAGetElementPtrInst$handle() {
        return LLVMIsAGetElementPtrInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGetElementPtrInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGetElementPtrInst$address() {
        return LLVMIsAGetElementPtrInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAGetElementPtrInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAGetElementPtrInst(MemorySegment Val) {
        var mh$ = LLVMIsAGetElementPtrInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAGetElementPtrInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAInsertElementInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAInsertElementInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInsertElementInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAInsertElementInst$descriptor() {
        return LLVMIsAInsertElementInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInsertElementInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAInsertElementInst$handle() {
        return LLVMIsAInsertElementInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInsertElementInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInsertElementInst$address() {
        return LLVMIsAInsertElementInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInsertElementInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInsertElementInst(MemorySegment Val) {
        var mh$ = LLVMIsAInsertElementInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAInsertElementInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAInsertValueInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAInsertValueInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInsertValueInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAInsertValueInst$descriptor() {
        return LLVMIsAInsertValueInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInsertValueInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAInsertValueInst$handle() {
        return LLVMIsAInsertValueInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInsertValueInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInsertValueInst$address() {
        return LLVMIsAInsertValueInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInsertValueInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInsertValueInst(MemorySegment Val) {
        var mh$ = LLVMIsAInsertValueInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAInsertValueInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsALandingPadInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsALandingPadInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsALandingPadInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsALandingPadInst$descriptor() {
        return LLVMIsALandingPadInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsALandingPadInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsALandingPadInst$handle() {
        return LLVMIsALandingPadInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsALandingPadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsALandingPadInst$address() {
        return LLVMIsALandingPadInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsALandingPadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsALandingPadInst(MemorySegment Val) {
        var mh$ = LLVMIsALandingPadInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsALandingPadInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAPHINode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAPHINode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPHINode(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAPHINode$descriptor() {
        return LLVMIsAPHINode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPHINode(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAPHINode$handle() {
        return LLVMIsAPHINode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPHINode(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAPHINode$address() {
        return LLVMIsAPHINode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPHINode(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAPHINode(MemorySegment Val) {
        var mh$ = LLVMIsAPHINode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAPHINode", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsASelectInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsASelectInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASelectInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsASelectInst$descriptor() {
        return LLVMIsASelectInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASelectInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsASelectInst$handle() {
        return LLVMIsASelectInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASelectInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsASelectInst$address() {
        return LLVMIsASelectInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASelectInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsASelectInst(MemorySegment Val) {
        var mh$ = LLVMIsASelectInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsASelectInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAShuffleVectorInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAShuffleVectorInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAShuffleVectorInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAShuffleVectorInst$descriptor() {
        return LLVMIsAShuffleVectorInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAShuffleVectorInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAShuffleVectorInst$handle() {
        return LLVMIsAShuffleVectorInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAShuffleVectorInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAShuffleVectorInst$address() {
        return LLVMIsAShuffleVectorInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAShuffleVectorInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAShuffleVectorInst(MemorySegment Val) {
        var mh$ = LLVMIsAShuffleVectorInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAShuffleVectorInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAStoreInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAStoreInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAStoreInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAStoreInst$descriptor() {
        return LLVMIsAStoreInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAStoreInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAStoreInst$handle() {
        return LLVMIsAStoreInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAStoreInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAStoreInst$address() {
        return LLVMIsAStoreInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAStoreInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAStoreInst(MemorySegment Val) {
        var mh$ = LLVMIsAStoreInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAStoreInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsABranchInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsABranchInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABranchInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsABranchInst$descriptor() {
        return LLVMIsABranchInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABranchInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsABranchInst$handle() {
        return LLVMIsABranchInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABranchInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABranchInst$address() {
        return LLVMIsABranchInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABranchInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABranchInst(MemorySegment Val) {
        var mh$ = LLVMIsABranchInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsABranchInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAIndirectBrInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAIndirectBrInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIndirectBrInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAIndirectBrInst$descriptor() {
        return LLVMIsAIndirectBrInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIndirectBrInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAIndirectBrInst$handle() {
        return LLVMIsAIndirectBrInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIndirectBrInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAIndirectBrInst$address() {
        return LLVMIsAIndirectBrInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIndirectBrInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAIndirectBrInst(MemorySegment Val) {
        var mh$ = LLVMIsAIndirectBrInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAIndirectBrInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAInvokeInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAInvokeInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInvokeInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAInvokeInst$descriptor() {
        return LLVMIsAInvokeInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInvokeInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAInvokeInst$handle() {
        return LLVMIsAInvokeInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInvokeInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInvokeInst$address() {
        return LLVMIsAInvokeInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAInvokeInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAInvokeInst(MemorySegment Val) {
        var mh$ = LLVMIsAInvokeInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAInvokeInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAReturnInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAReturnInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAReturnInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAReturnInst$descriptor() {
        return LLVMIsAReturnInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAReturnInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAReturnInst$handle() {
        return LLVMIsAReturnInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAReturnInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAReturnInst$address() {
        return LLVMIsAReturnInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAReturnInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAReturnInst(MemorySegment Val) {
        var mh$ = LLVMIsAReturnInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAReturnInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsASwitchInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsASwitchInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASwitchInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsASwitchInst$descriptor() {
        return LLVMIsASwitchInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASwitchInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsASwitchInst$handle() {
        return LLVMIsASwitchInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASwitchInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsASwitchInst$address() {
        return LLVMIsASwitchInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASwitchInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsASwitchInst(MemorySegment Val) {
        var mh$ = LLVMIsASwitchInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsASwitchInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAUnreachableInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAUnreachableInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnreachableInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAUnreachableInst$descriptor() {
        return LLVMIsAUnreachableInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnreachableInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAUnreachableInst$handle() {
        return LLVMIsAUnreachableInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnreachableInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUnreachableInst$address() {
        return LLVMIsAUnreachableInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnreachableInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUnreachableInst(MemorySegment Val) {
        var mh$ = LLVMIsAUnreachableInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAUnreachableInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAResumeInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAResumeInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAResumeInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAResumeInst$descriptor() {
        return LLVMIsAResumeInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAResumeInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAResumeInst$handle() {
        return LLVMIsAResumeInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAResumeInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAResumeInst$address() {
        return LLVMIsAResumeInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAResumeInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAResumeInst(MemorySegment Val) {
        var mh$ = LLVMIsAResumeInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAResumeInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACleanupReturnInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACleanupReturnInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACleanupReturnInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACleanupReturnInst$descriptor() {
        return LLVMIsACleanupReturnInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACleanupReturnInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACleanupReturnInst$handle() {
        return LLVMIsACleanupReturnInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACleanupReturnInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACleanupReturnInst$address() {
        return LLVMIsACleanupReturnInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACleanupReturnInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACleanupReturnInst(MemorySegment Val) {
        var mh$ = LLVMIsACleanupReturnInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACleanupReturnInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACatchReturnInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACatchReturnInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchReturnInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACatchReturnInst$descriptor() {
        return LLVMIsACatchReturnInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchReturnInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACatchReturnInst$handle() {
        return LLVMIsACatchReturnInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchReturnInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACatchReturnInst$address() {
        return LLVMIsACatchReturnInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchReturnInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACatchReturnInst(MemorySegment Val) {
        var mh$ = LLVMIsACatchReturnInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACatchReturnInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACatchSwitchInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACatchSwitchInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchSwitchInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACatchSwitchInst$descriptor() {
        return LLVMIsACatchSwitchInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchSwitchInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACatchSwitchInst$handle() {
        return LLVMIsACatchSwitchInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchSwitchInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACatchSwitchInst$address() {
        return LLVMIsACatchSwitchInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchSwitchInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACatchSwitchInst(MemorySegment Val) {
        var mh$ = LLVMIsACatchSwitchInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACatchSwitchInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACallBrInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACallBrInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACallBrInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACallBrInst$descriptor() {
        return LLVMIsACallBrInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACallBrInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACallBrInst$handle() {
        return LLVMIsACallBrInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACallBrInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACallBrInst$address() {
        return LLVMIsACallBrInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACallBrInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACallBrInst(MemorySegment Val) {
        var mh$ = LLVMIsACallBrInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACallBrInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFuncletPadInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFuncletPadInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFuncletPadInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFuncletPadInst$descriptor() {
        return LLVMIsAFuncletPadInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFuncletPadInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFuncletPadInst$handle() {
        return LLVMIsAFuncletPadInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFuncletPadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFuncletPadInst$address() {
        return LLVMIsAFuncletPadInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFuncletPadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFuncletPadInst(MemorySegment Val) {
        var mh$ = LLVMIsAFuncletPadInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFuncletPadInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACatchPadInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACatchPadInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchPadInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACatchPadInst$descriptor() {
        return LLVMIsACatchPadInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchPadInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACatchPadInst$handle() {
        return LLVMIsACatchPadInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchPadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACatchPadInst$address() {
        return LLVMIsACatchPadInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACatchPadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACatchPadInst(MemorySegment Val) {
        var mh$ = LLVMIsACatchPadInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACatchPadInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACleanupPadInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACleanupPadInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACleanupPadInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACleanupPadInst$descriptor() {
        return LLVMIsACleanupPadInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACleanupPadInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACleanupPadInst$handle() {
        return LLVMIsACleanupPadInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACleanupPadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACleanupPadInst$address() {
        return LLVMIsACleanupPadInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACleanupPadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACleanupPadInst(MemorySegment Val) {
        var mh$ = LLVMIsACleanupPadInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACleanupPadInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAUnaryInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAUnaryInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnaryInstruction(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAUnaryInstruction$descriptor() {
        return LLVMIsAUnaryInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnaryInstruction(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAUnaryInstruction$handle() {
        return LLVMIsAUnaryInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnaryInstruction(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUnaryInstruction$address() {
        return LLVMIsAUnaryInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUnaryInstruction(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUnaryInstruction(MemorySegment Val) {
        var mh$ = LLVMIsAUnaryInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAUnaryInstruction", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAAllocaInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAAllocaInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAllocaInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAAllocaInst$descriptor() {
        return LLVMIsAAllocaInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAllocaInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAAllocaInst$handle() {
        return LLVMIsAAllocaInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAllocaInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAAllocaInst$address() {
        return LLVMIsAAllocaInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAllocaInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAAllocaInst(MemorySegment Val) {
        var mh$ = LLVMIsAAllocaInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAAllocaInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsACastInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsACastInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACastInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsACastInst$descriptor() {
        return LLVMIsACastInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACastInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsACastInst$handle() {
        return LLVMIsACastInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACastInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACastInst$address() {
        return LLVMIsACastInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsACastInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsACastInst(MemorySegment Val) {
        var mh$ = LLVMIsACastInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsACastInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAAddrSpaceCastInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAAddrSpaceCastInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAddrSpaceCastInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAAddrSpaceCastInst$descriptor() {
        return LLVMIsAAddrSpaceCastInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAddrSpaceCastInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAAddrSpaceCastInst$handle() {
        return LLVMIsAAddrSpaceCastInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAddrSpaceCastInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAAddrSpaceCastInst$address() {
        return LLVMIsAAddrSpaceCastInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAddrSpaceCastInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAAddrSpaceCastInst(MemorySegment Val) {
        var mh$ = LLVMIsAAddrSpaceCastInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAAddrSpaceCastInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsABitCastInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsABitCastInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABitCastInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsABitCastInst$descriptor() {
        return LLVMIsABitCastInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABitCastInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsABitCastInst$handle() {
        return LLVMIsABitCastInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABitCastInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABitCastInst$address() {
        return LLVMIsABitCastInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsABitCastInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsABitCastInst(MemorySegment Val) {
        var mh$ = LLVMIsABitCastInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsABitCastInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFPExtInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFPExtInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPExtInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFPExtInst$descriptor() {
        return LLVMIsAFPExtInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPExtInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFPExtInst$handle() {
        return LLVMIsAFPExtInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPExtInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFPExtInst$address() {
        return LLVMIsAFPExtInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPExtInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFPExtInst(MemorySegment Val) {
        var mh$ = LLVMIsAFPExtInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFPExtInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFPToSIInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFPToSIInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPToSIInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFPToSIInst$descriptor() {
        return LLVMIsAFPToSIInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPToSIInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFPToSIInst$handle() {
        return LLVMIsAFPToSIInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPToSIInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFPToSIInst$address() {
        return LLVMIsAFPToSIInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPToSIInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFPToSIInst(MemorySegment Val) {
        var mh$ = LLVMIsAFPToSIInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFPToSIInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFPToUIInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFPToUIInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPToUIInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFPToUIInst$descriptor() {
        return LLVMIsAFPToUIInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPToUIInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFPToUIInst$handle() {
        return LLVMIsAFPToUIInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPToUIInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFPToUIInst$address() {
        return LLVMIsAFPToUIInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPToUIInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFPToUIInst(MemorySegment Val) {
        var mh$ = LLVMIsAFPToUIInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFPToUIInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFPTruncInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFPTruncInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPTruncInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFPTruncInst$descriptor() {
        return LLVMIsAFPTruncInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPTruncInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFPTruncInst$handle() {
        return LLVMIsAFPTruncInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPTruncInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFPTruncInst$address() {
        return LLVMIsAFPTruncInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFPTruncInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFPTruncInst(MemorySegment Val) {
        var mh$ = LLVMIsAFPTruncInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFPTruncInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAIntToPtrInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAIntToPtrInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIntToPtrInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAIntToPtrInst$descriptor() {
        return LLVMIsAIntToPtrInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIntToPtrInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAIntToPtrInst$handle() {
        return LLVMIsAIntToPtrInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIntToPtrInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAIntToPtrInst$address() {
        return LLVMIsAIntToPtrInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAIntToPtrInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAIntToPtrInst(MemorySegment Val) {
        var mh$ = LLVMIsAIntToPtrInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAIntToPtrInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAPtrToIntInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAPtrToIntInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPtrToIntInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAPtrToIntInst$descriptor() {
        return LLVMIsAPtrToIntInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPtrToIntInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAPtrToIntInst$handle() {
        return LLVMIsAPtrToIntInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPtrToIntInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAPtrToIntInst$address() {
        return LLVMIsAPtrToIntInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAPtrToIntInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAPtrToIntInst(MemorySegment Val) {
        var mh$ = LLVMIsAPtrToIntInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAPtrToIntInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsASExtInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsASExtInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASExtInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsASExtInst$descriptor() {
        return LLVMIsASExtInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASExtInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsASExtInst$handle() {
        return LLVMIsASExtInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASExtInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsASExtInst$address() {
        return LLVMIsASExtInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASExtInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsASExtInst(MemorySegment Val) {
        var mh$ = LLVMIsASExtInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsASExtInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsASIToFPInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsASIToFPInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASIToFPInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsASIToFPInst$descriptor() {
        return LLVMIsASIToFPInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASIToFPInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsASIToFPInst$handle() {
        return LLVMIsASIToFPInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASIToFPInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsASIToFPInst$address() {
        return LLVMIsASIToFPInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsASIToFPInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsASIToFPInst(MemorySegment Val) {
        var mh$ = LLVMIsASIToFPInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsASIToFPInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsATruncInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsATruncInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATruncInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsATruncInst$descriptor() {
        return LLVMIsATruncInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATruncInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsATruncInst$handle() {
        return LLVMIsATruncInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATruncInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsATruncInst$address() {
        return LLVMIsATruncInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATruncInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsATruncInst(MemorySegment Val) {
        var mh$ = LLVMIsATruncInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsATruncInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAUIToFPInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAUIToFPInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUIToFPInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAUIToFPInst$descriptor() {
        return LLVMIsAUIToFPInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUIToFPInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAUIToFPInst$handle() {
        return LLVMIsAUIToFPInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUIToFPInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUIToFPInst$address() {
        return LLVMIsAUIToFPInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAUIToFPInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAUIToFPInst(MemorySegment Val) {
        var mh$ = LLVMIsAUIToFPInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAUIToFPInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAZExtInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAZExtInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAZExtInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAZExtInst$descriptor() {
        return LLVMIsAZExtInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAZExtInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAZExtInst$handle() {
        return LLVMIsAZExtInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAZExtInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAZExtInst$address() {
        return LLVMIsAZExtInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAZExtInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAZExtInst(MemorySegment Val) {
        var mh$ = LLVMIsAZExtInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAZExtInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAExtractValueInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAExtractValueInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAExtractValueInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAExtractValueInst$descriptor() {
        return LLVMIsAExtractValueInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAExtractValueInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAExtractValueInst$handle() {
        return LLVMIsAExtractValueInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAExtractValueInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAExtractValueInst$address() {
        return LLVMIsAExtractValueInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAExtractValueInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAExtractValueInst(MemorySegment Val) {
        var mh$ = LLVMIsAExtractValueInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAExtractValueInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsALoadInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsALoadInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsALoadInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsALoadInst$descriptor() {
        return LLVMIsALoadInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsALoadInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsALoadInst$handle() {
        return LLVMIsALoadInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsALoadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsALoadInst$address() {
        return LLVMIsALoadInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsALoadInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsALoadInst(MemorySegment Val) {
        var mh$ = LLVMIsALoadInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsALoadInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAVAArgInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAVAArgInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAVAArgInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAVAArgInst$descriptor() {
        return LLVMIsAVAArgInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAVAArgInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAVAArgInst$handle() {
        return LLVMIsAVAArgInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAVAArgInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAVAArgInst$address() {
        return LLVMIsAVAArgInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAVAArgInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAVAArgInst(MemorySegment Val) {
        var mh$ = LLVMIsAVAArgInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAVAArgInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFreezeInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFreezeInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFreezeInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFreezeInst$descriptor() {
        return LLVMIsAFreezeInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFreezeInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFreezeInst$handle() {
        return LLVMIsAFreezeInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFreezeInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFreezeInst$address() {
        return LLVMIsAFreezeInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFreezeInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFreezeInst(MemorySegment Val) {
        var mh$ = LLVMIsAFreezeInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFreezeInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAAtomicCmpXchgInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAAtomicCmpXchgInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAtomicCmpXchgInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAAtomicCmpXchgInst$descriptor() {
        return LLVMIsAAtomicCmpXchgInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAtomicCmpXchgInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAAtomicCmpXchgInst$handle() {
        return LLVMIsAAtomicCmpXchgInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAtomicCmpXchgInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAAtomicCmpXchgInst$address() {
        return LLVMIsAAtomicCmpXchgInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAtomicCmpXchgInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAAtomicCmpXchgInst(MemorySegment Val) {
        var mh$ = LLVMIsAAtomicCmpXchgInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAAtomicCmpXchgInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAAtomicRMWInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAAtomicRMWInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAtomicRMWInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAAtomicRMWInst$descriptor() {
        return LLVMIsAAtomicRMWInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAtomicRMWInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAAtomicRMWInst$handle() {
        return LLVMIsAAtomicRMWInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAtomicRMWInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAAtomicRMWInst$address() {
        return LLVMIsAAtomicRMWInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAAtomicRMWInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAAtomicRMWInst(MemorySegment Val) {
        var mh$ = LLVMIsAAtomicRMWInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAAtomicRMWInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAFenceInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAFenceInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFenceInst(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAFenceInst$descriptor() {
        return LLVMIsAFenceInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFenceInst(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAFenceInst$handle() {
        return LLVMIsAFenceInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFenceInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFenceInst$address() {
        return LLVMIsAFenceInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAFenceInst(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAFenceInst(MemorySegment Val) {
        var mh$ = LLVMIsAFenceInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAFenceInst", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAMDNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAMDNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMDNode(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAMDNode$descriptor() {
        return LLVMIsAMDNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMDNode(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAMDNode$handle() {
        return LLVMIsAMDNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMDNode(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMDNode$address() {
        return LLVMIsAMDNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMDNode(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMDNode(MemorySegment Val) {
        var mh$ = LLVMIsAMDNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAMDNode", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAValueAsMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAValueAsMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAValueAsMetadata$descriptor() {
        return LLVMIsAValueAsMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAValueAsMetadata$handle() {
        return LLVMIsAValueAsMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAValueAsMetadata$address() {
        return LLVMIsAValueAsMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAValueAsMetadata(MemorySegment Val) {
        var mh$ = LLVMIsAValueAsMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAValueAsMetadata", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAMDString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAMDString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMDString(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsAMDString$descriptor() {
        return LLVMIsAMDString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMDString(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsAMDString$handle() {
        return LLVMIsAMDString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMDString(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMDString$address() {
        return LLVMIsAMDString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsAMDString(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsAMDString(MemorySegment Val) {
        var mh$ = LLVMIsAMDString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAMDString", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetValueName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetValueName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetValueName(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMGetValueName$descriptor() {
        return LLVMGetValueName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetValueName(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMGetValueName$handle() {
        return LLVMGetValueName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetValueName(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetValueName$address() {
        return LLVMGetValueName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetValueName(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetValueName(MemorySegment Val) {
        var mh$ = LLVMGetValueName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetValueName", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetValueName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetValueName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetValueName(LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMSetValueName$descriptor() {
        return LLVMSetValueName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetValueName(LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMSetValueName$handle() {
        return LLVMSetValueName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetValueName(LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMSetValueName$address() {
        return LLVMSetValueName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetValueName(LLVMValueRef Val, const char *Name)
     * }
     */
    public static void LLVMSetValueName(MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMSetValueName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetValueName", Val, Name);
            }
            mh$.invokeExact(Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetFirstUse(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstUse$descriptor() {
        return LLVMGetFirstUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetFirstUse(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMGetFirstUse$handle() {
        return LLVMGetFirstUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetFirstUse(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetFirstUse$address() {
        return LLVMGetFirstUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetFirstUse(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetFirstUse(MemorySegment Val) {
        var mh$ = LLVMGetFirstUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstUse", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetNextUse(LLVMUseRef U)
     * }
     */
    public static FunctionDescriptor LLVMGetNextUse$descriptor() {
        return LLVMGetNextUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetNextUse(LLVMUseRef U)
     * }
     */
    public static MethodHandle LLVMGetNextUse$handle() {
        return LLVMGetNextUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetNextUse(LLVMUseRef U)
     * }
     */
    public static MemorySegment LLVMGetNextUse$address() {
        return LLVMGetNextUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetNextUse(LLVMUseRef U)
     * }
     */
    public static MemorySegment LLVMGetNextUse(MemorySegment U) {
        var mh$ = LLVMGetNextUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextUse", U);
            }
            return (MemorySegment)mh$.invokeExact(U);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetUser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetUser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUser(LLVMUseRef U)
     * }
     */
    public static FunctionDescriptor LLVMGetUser$descriptor() {
        return LLVMGetUser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUser(LLVMUseRef U)
     * }
     */
    public static MethodHandle LLVMGetUser$handle() {
        return LLVMGetUser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUser(LLVMUseRef U)
     * }
     */
    public static MemorySegment LLVMGetUser$address() {
        return LLVMGetUser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUser(LLVMUseRef U)
     * }
     */
    public static MemorySegment LLVMGetUser(MemorySegment U) {
        var mh$ = LLVMGetUser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetUser", U);
            }
            return (MemorySegment)mh$.invokeExact(U);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetUsedValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetUsedValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUsedValue(LLVMUseRef U)
     * }
     */
    public static FunctionDescriptor LLVMGetUsedValue$descriptor() {
        return LLVMGetUsedValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUsedValue(LLVMUseRef U)
     * }
     */
    public static MethodHandle LLVMGetUsedValue$handle() {
        return LLVMGetUsedValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUsedValue(LLVMUseRef U)
     * }
     */
    public static MemorySegment LLVMGetUsedValue$address() {
        return LLVMGetUsedValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUsedValue(LLVMUseRef U)
     * }
     */
    public static MemorySegment LLVMGetUsedValue(MemorySegment U) {
        var mh$ = LLVMGetUsedValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetUsedValue", U);
            }
            return (MemorySegment)mh$.invokeExact(U);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOperand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOperand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperand(LLVMValueRef Val, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetOperand$descriptor() {
        return LLVMGetOperand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperand(LLVMValueRef Val, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetOperand$handle() {
        return LLVMGetOperand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperand(LLVMValueRef Val, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperand$address() {
        return LLVMGetOperand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperand(LLVMValueRef Val, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperand(MemorySegment Val, int Index) {
        var mh$ = LLVMGetOperand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOperand", Val, Index);
            }
            return (MemorySegment)mh$.invokeExact(Val, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOperandUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOperandUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetOperandUse(LLVMValueRef Val, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetOperandUse$descriptor() {
        return LLVMGetOperandUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetOperandUse(LLVMValueRef Val, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetOperandUse$handle() {
        return LLVMGetOperandUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetOperandUse(LLVMValueRef Val, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandUse$address() {
        return LLVMGetOperandUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMUseRef LLVMGetOperandUse(LLVMValueRef Val, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandUse(MemorySegment Val, int Index) {
        var mh$ = LLVMGetOperandUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOperandUse", Val, Index);
            }
            return (MemorySegment)mh$.invokeExact(Val, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetOperand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetOperand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetOperand(LLVMValueRef User, unsigned int Index, LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMSetOperand$descriptor() {
        return LLVMSetOperand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetOperand(LLVMValueRef User, unsigned int Index, LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMSetOperand$handle() {
        return LLVMSetOperand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetOperand(LLVMValueRef User, unsigned int Index, LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMSetOperand$address() {
        return LLVMSetOperand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetOperand(LLVMValueRef User, unsigned int Index, LLVMValueRef Val)
     * }
     */
    public static void LLVMSetOperand(MemorySegment User, int Index, MemorySegment Val) {
        var mh$ = LLVMSetOperand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetOperand", User, Index, Val);
            }
            mh$.invokeExact(User, Index, Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LLVMGetNumOperands(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMGetNumOperands$descriptor() {
        return LLVMGetNumOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LLVMGetNumOperands(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMGetNumOperands$handle() {
        return LLVMGetNumOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LLVMGetNumOperands(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMGetNumOperands$address() {
        return LLVMGetNumOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LLVMGetNumOperands(LLVMValueRef Val)
     * }
     */
    public static int LLVMGetNumOperands(MemorySegment Val) {
        var mh$ = LLVMGetNumOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumOperands", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNull(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMConstNull$descriptor() {
        return LLVMConstNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNull(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMConstNull$handle() {
        return LLVMConstNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNull(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMConstNull$address() {
        return LLVMConstNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNull(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMConstNull(MemorySegment Ty) {
        var mh$ = LLVMConstNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNull", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstAllOnes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstAllOnes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAllOnes(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMConstAllOnes$descriptor() {
        return LLVMConstAllOnes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAllOnes(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMConstAllOnes$handle() {
        return LLVMConstAllOnes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAllOnes(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMConstAllOnes$address() {
        return LLVMConstAllOnes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAllOnes(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMConstAllOnes(MemorySegment Ty) {
        var mh$ = LLVMConstAllOnes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstAllOnes", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetUndef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetUndef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUndef(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMGetUndef$descriptor() {
        return LLVMGetUndef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUndef(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMGetUndef$handle() {
        return LLVMGetUndef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUndef(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetUndef$address() {
        return LLVMGetUndef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetUndef(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetUndef(MemorySegment Ty) {
        var mh$ = LLVMGetUndef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetUndef", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPoison {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPoison");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPoison(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMGetPoison$descriptor() {
        return LLVMGetPoison.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPoison(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMGetPoison$handle() {
        return LLVMGetPoison.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPoison(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetPoison$address() {
        return LLVMGetPoison.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPoison(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMGetPoison(MemorySegment Ty) {
        var mh$ = LLVMGetPoison.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPoison", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsNull(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMIsNull$descriptor() {
        return LLVMIsNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsNull(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMIsNull$handle() {
        return LLVMIsNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsNull(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMIsNull$address() {
        return LLVMIsNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsNull(LLVMValueRef Val)
     * }
     */
    public static int LLVMIsNull(MemorySegment Val) {
        var mh$ = LLVMIsNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsNull", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstPointerNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstPointerNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPointerNull(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMConstPointerNull$descriptor() {
        return LLVMConstPointerNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPointerNull(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMConstPointerNull$handle() {
        return LLVMConstPointerNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPointerNull(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMConstPointerNull$address() {
        return LLVMConstPointerNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPointerNull(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMConstPointerNull(MemorySegment Ty) {
        var mh$ = LLVMConstPointerNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstPointerNull", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG_LONG,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInt(LLVMTypeRef IntTy, unsigned long long N, LLVMBool SignExtend)
     * }
     */
    public static FunctionDescriptor LLVMConstInt$descriptor() {
        return LLVMConstInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInt(LLVMTypeRef IntTy, unsigned long long N, LLVMBool SignExtend)
     * }
     */
    public static MethodHandle LLVMConstInt$handle() {
        return LLVMConstInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInt(LLVMTypeRef IntTy, unsigned long long N, LLVMBool SignExtend)
     * }
     */
    public static MemorySegment LLVMConstInt$address() {
        return LLVMConstInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInt(LLVMTypeRef IntTy, unsigned long long N, LLVMBool SignExtend)
     * }
     */
    public static MemorySegment LLVMConstInt(MemorySegment IntTy, long N, int SignExtend) {
        var mh$ = LLVMConstInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstInt", IntTy, N, SignExtend);
            }
            return (MemorySegment)mh$.invokeExact(IntTy, N, SignExtend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstIntOfArbitraryPrecision {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstIntOfArbitraryPrecision");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMTypeRef IntTy, unsigned int NumWords, const uint64_t Words[])
     * }
     */
    public static FunctionDescriptor LLVMConstIntOfArbitraryPrecision$descriptor() {
        return LLVMConstIntOfArbitraryPrecision.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMTypeRef IntTy, unsigned int NumWords, const uint64_t Words[])
     * }
     */
    public static MethodHandle LLVMConstIntOfArbitraryPrecision$handle() {
        return LLVMConstIntOfArbitraryPrecision.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMTypeRef IntTy, unsigned int NumWords, const uint64_t Words[])
     * }
     */
    public static MemorySegment LLVMConstIntOfArbitraryPrecision$address() {
        return LLVMConstIntOfArbitraryPrecision.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMTypeRef IntTy, unsigned int NumWords, const uint64_t Words[])
     * }
     */
    public static MemorySegment LLVMConstIntOfArbitraryPrecision(MemorySegment IntTy, int NumWords, MemorySegment Words) {
        var mh$ = LLVMConstIntOfArbitraryPrecision.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstIntOfArbitraryPrecision", IntTy, NumWords, Words);
            }
            return (MemorySegment)mh$.invokeExact(IntTy, NumWords, Words);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstIntOfString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_CHAR
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstIntOfString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfString(LLVMTypeRef IntTy, const char *Text, uint8_t Radix)
     * }
     */
    public static FunctionDescriptor LLVMConstIntOfString$descriptor() {
        return LLVMConstIntOfString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfString(LLVMTypeRef IntTy, const char *Text, uint8_t Radix)
     * }
     */
    public static MethodHandle LLVMConstIntOfString$handle() {
        return LLVMConstIntOfString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfString(LLVMTypeRef IntTy, const char *Text, uint8_t Radix)
     * }
     */
    public static MemorySegment LLVMConstIntOfString$address() {
        return LLVMConstIntOfString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfString(LLVMTypeRef IntTy, const char *Text, uint8_t Radix)
     * }
     */
    public static MemorySegment LLVMConstIntOfString(MemorySegment IntTy, MemorySegment Text, byte Radix) {
        var mh$ = LLVMConstIntOfString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstIntOfString", IntTy, Text, Radix);
            }
            return (MemorySegment)mh$.invokeExact(IntTy, Text, Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstIntOfStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_CHAR
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstIntOfStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfStringAndSize(LLVMTypeRef IntTy, const char *Text, unsigned int SLen, uint8_t Radix)
     * }
     */
    public static FunctionDescriptor LLVMConstIntOfStringAndSize$descriptor() {
        return LLVMConstIntOfStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfStringAndSize(LLVMTypeRef IntTy, const char *Text, unsigned int SLen, uint8_t Radix)
     * }
     */
    public static MethodHandle LLVMConstIntOfStringAndSize$handle() {
        return LLVMConstIntOfStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfStringAndSize(LLVMTypeRef IntTy, const char *Text, unsigned int SLen, uint8_t Radix)
     * }
     */
    public static MemorySegment LLVMConstIntOfStringAndSize$address() {
        return LLVMConstIntOfStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntOfStringAndSize(LLVMTypeRef IntTy, const char *Text, unsigned int SLen, uint8_t Radix)
     * }
     */
    public static MemorySegment LLVMConstIntOfStringAndSize(MemorySegment IntTy, MemorySegment Text, int SLen, byte Radix) {
        var mh$ = LLVMConstIntOfStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstIntOfStringAndSize", IntTy, Text, SLen, Radix);
            }
            return (MemorySegment)mh$.invokeExact(IntTy, Text, SLen, Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstReal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_DOUBLE
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstReal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstReal(LLVMTypeRef RealTy, double N)
     * }
     */
    public static FunctionDescriptor LLVMConstReal$descriptor() {
        return LLVMConstReal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstReal(LLVMTypeRef RealTy, double N)
     * }
     */
    public static MethodHandle LLVMConstReal$handle() {
        return LLVMConstReal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstReal(LLVMTypeRef RealTy, double N)
     * }
     */
    public static MemorySegment LLVMConstReal$address() {
        return LLVMConstReal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstReal(LLVMTypeRef RealTy, double N)
     * }
     */
    public static MemorySegment LLVMConstReal(MemorySegment RealTy, double N) {
        var mh$ = LLVMConstReal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstReal", RealTy, N);
            }
            return (MemorySegment)mh$.invokeExact(RealTy, N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstRealOfString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstRealOfString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstRealOfString(LLVMTypeRef RealTy, const char *Text)
     * }
     */
    public static FunctionDescriptor LLVMConstRealOfString$descriptor() {
        return LLVMConstRealOfString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstRealOfString(LLVMTypeRef RealTy, const char *Text)
     * }
     */
    public static MethodHandle LLVMConstRealOfString$handle() {
        return LLVMConstRealOfString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstRealOfString(LLVMTypeRef RealTy, const char *Text)
     * }
     */
    public static MemorySegment LLVMConstRealOfString$address() {
        return LLVMConstRealOfString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstRealOfString(LLVMTypeRef RealTy, const char *Text)
     * }
     */
    public static MemorySegment LLVMConstRealOfString(MemorySegment RealTy, MemorySegment Text) {
        var mh$ = LLVMConstRealOfString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstRealOfString", RealTy, Text);
            }
            return (MemorySegment)mh$.invokeExact(RealTy, Text);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstRealOfStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstRealOfStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstRealOfStringAndSize(LLVMTypeRef RealTy, const char *Text, unsigned int SLen)
     * }
     */
    public static FunctionDescriptor LLVMConstRealOfStringAndSize$descriptor() {
        return LLVMConstRealOfStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstRealOfStringAndSize(LLVMTypeRef RealTy, const char *Text, unsigned int SLen)
     * }
     */
    public static MethodHandle LLVMConstRealOfStringAndSize$handle() {
        return LLVMConstRealOfStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstRealOfStringAndSize(LLVMTypeRef RealTy, const char *Text, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMConstRealOfStringAndSize$address() {
        return LLVMConstRealOfStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstRealOfStringAndSize(LLVMTypeRef RealTy, const char *Text, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMConstRealOfStringAndSize(MemorySegment RealTy, MemorySegment Text, int SLen) {
        var mh$ = LLVMConstRealOfStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstRealOfStringAndSize", RealTy, Text, SLen);
            }
            return (MemorySegment)mh$.invokeExact(RealTy, Text, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstIntGetZExtValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstIntGetZExtValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long LLVMConstIntGetZExtValue(LLVMValueRef ConstantVal)
     * }
     */
    public static FunctionDescriptor LLVMConstIntGetZExtValue$descriptor() {
        return LLVMConstIntGetZExtValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long LLVMConstIntGetZExtValue(LLVMValueRef ConstantVal)
     * }
     */
    public static MethodHandle LLVMConstIntGetZExtValue$handle() {
        return LLVMConstIntGetZExtValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long LLVMConstIntGetZExtValue(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstIntGetZExtValue$address() {
        return LLVMConstIntGetZExtValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long LLVMConstIntGetZExtValue(LLVMValueRef ConstantVal)
     * }
     */
    public static long LLVMConstIntGetZExtValue(MemorySegment ConstantVal) {
        var mh$ = LLVMConstIntGetZExtValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstIntGetZExtValue", ConstantVal);
            }
            return (long)mh$.invokeExact(ConstantVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstIntGetSExtValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstIntGetSExtValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long LLVMConstIntGetSExtValue(LLVMValueRef ConstantVal)
     * }
     */
    public static FunctionDescriptor LLVMConstIntGetSExtValue$descriptor() {
        return LLVMConstIntGetSExtValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long LLVMConstIntGetSExtValue(LLVMValueRef ConstantVal)
     * }
     */
    public static MethodHandle LLVMConstIntGetSExtValue$handle() {
        return LLVMConstIntGetSExtValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long LLVMConstIntGetSExtValue(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstIntGetSExtValue$address() {
        return LLVMConstIntGetSExtValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long LLVMConstIntGetSExtValue(LLVMValueRef ConstantVal)
     * }
     */
    public static long LLVMConstIntGetSExtValue(MemorySegment ConstantVal) {
        var mh$ = LLVMConstIntGetSExtValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstIntGetSExtValue", ConstantVal);
            }
            return (long)mh$.invokeExact(ConstantVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstRealGetDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_DOUBLE,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstRealGetDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LLVMConstRealGetDouble(LLVMValueRef ConstantVal, LLVMBool *losesInfo)
     * }
     */
    public static FunctionDescriptor LLVMConstRealGetDouble$descriptor() {
        return LLVMConstRealGetDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LLVMConstRealGetDouble(LLVMValueRef ConstantVal, LLVMBool *losesInfo)
     * }
     */
    public static MethodHandle LLVMConstRealGetDouble$handle() {
        return LLVMConstRealGetDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LLVMConstRealGetDouble(LLVMValueRef ConstantVal, LLVMBool *losesInfo)
     * }
     */
    public static MemorySegment LLVMConstRealGetDouble$address() {
        return LLVMConstRealGetDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LLVMConstRealGetDouble(LLVMValueRef ConstantVal, LLVMBool *losesInfo)
     * }
     */
    public static double LLVMConstRealGetDouble(MemorySegment ConstantVal, MemorySegment losesInfo) {
        var mh$ = LLVMConstRealGetDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstRealGetDouble", ConstantVal, losesInfo);
            }
            return (double)mh$.invokeExact(ConstantVal, losesInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstStringInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstStringInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStringInContext(LLVMContextRef C, const char *Str, unsigned int Length, LLVMBool DontNullTerminate)
     * }
     */
    public static FunctionDescriptor LLVMConstStringInContext$descriptor() {
        return LLVMConstStringInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStringInContext(LLVMContextRef C, const char *Str, unsigned int Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MethodHandle LLVMConstStringInContext$handle() {
        return LLVMConstStringInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStringInContext(LLVMContextRef C, const char *Str, unsigned int Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MemorySegment LLVMConstStringInContext$address() {
        return LLVMConstStringInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStringInContext(LLVMContextRef C, const char *Str, unsigned int Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MemorySegment LLVMConstStringInContext(MemorySegment C, MemorySegment Str, int Length, int DontNullTerminate) {
        var mh$ = LLVMConstStringInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstStringInContext", C, Str, Length, DontNullTerminate);
            }
            return (MemorySegment)mh$.invokeExact(C, Str, Length, DontNullTerminate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstStringInContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstStringInContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStringInContext2(LLVMContextRef C, const char *Str, size_t Length, LLVMBool DontNullTerminate)
     * }
     */
    public static FunctionDescriptor LLVMConstStringInContext2$descriptor() {
        return LLVMConstStringInContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStringInContext2(LLVMContextRef C, const char *Str, size_t Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MethodHandle LLVMConstStringInContext2$handle() {
        return LLVMConstStringInContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStringInContext2(LLVMContextRef C, const char *Str, size_t Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MemorySegment LLVMConstStringInContext2$address() {
        return LLVMConstStringInContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStringInContext2(LLVMContextRef C, const char *Str, size_t Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MemorySegment LLVMConstStringInContext2(MemorySegment C, MemorySegment Str, long Length, int DontNullTerminate) {
        var mh$ = LLVMConstStringInContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstStringInContext2", C, Str, Length, DontNullTerminate);
            }
            return (MemorySegment)mh$.invokeExact(C, Str, Length, DontNullTerminate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstString(const char *Str, unsigned int Length, LLVMBool DontNullTerminate)
     * }
     */
    public static FunctionDescriptor LLVMConstString$descriptor() {
        return LLVMConstString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstString(const char *Str, unsigned int Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MethodHandle LLVMConstString$handle() {
        return LLVMConstString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstString(const char *Str, unsigned int Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MemorySegment LLVMConstString$address() {
        return LLVMConstString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstString(const char *Str, unsigned int Length, LLVMBool DontNullTerminate)
     * }
     */
    public static MemorySegment LLVMConstString(MemorySegment Str, int Length, int DontNullTerminate) {
        var mh$ = LLVMConstString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstString", Str, Length, DontNullTerminate);
            }
            return (MemorySegment)mh$.invokeExact(Str, Length, DontNullTerminate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsConstantString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsConstantString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConstantString(LLVMValueRef c)
     * }
     */
    public static FunctionDescriptor LLVMIsConstantString$descriptor() {
        return LLVMIsConstantString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConstantString(LLVMValueRef c)
     * }
     */
    public static MethodHandle LLVMIsConstantString$handle() {
        return LLVMIsConstantString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConstantString(LLVMValueRef c)
     * }
     */
    public static MemorySegment LLVMIsConstantString$address() {
        return LLVMIsConstantString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsConstantString(LLVMValueRef c)
     * }
     */
    public static int LLVMIsConstantString(MemorySegment c) {
        var mh$ = LLVMIsConstantString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsConstantString", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetAsString(LLVMValueRef c, size_t *Length)
     * }
     */
    public static FunctionDescriptor LLVMGetAsString$descriptor() {
        return LLVMGetAsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetAsString(LLVMValueRef c, size_t *Length)
     * }
     */
    public static MethodHandle LLVMGetAsString$handle() {
        return LLVMGetAsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetAsString(LLVMValueRef c, size_t *Length)
     * }
     */
    public static MemorySegment LLVMGetAsString$address() {
        return LLVMGetAsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetAsString(LLVMValueRef c, size_t *Length)
     * }
     */
    public static MemorySegment LLVMGetAsString(MemorySegment c, MemorySegment Length) {
        var mh$ = LLVMGetAsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAsString", c, Length);
            }
            return (MemorySegment)mh$.invokeExact(c, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstStructInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstStructInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStructInContext(LLVMContextRef C, LLVMValueRef *ConstantVals, unsigned int Count, LLVMBool Packed)
     * }
     */
    public static FunctionDescriptor LLVMConstStructInContext$descriptor() {
        return LLVMConstStructInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStructInContext(LLVMContextRef C, LLVMValueRef *ConstantVals, unsigned int Count, LLVMBool Packed)
     * }
     */
    public static MethodHandle LLVMConstStructInContext$handle() {
        return LLVMConstStructInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStructInContext(LLVMContextRef C, LLVMValueRef *ConstantVals, unsigned int Count, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMConstStructInContext$address() {
        return LLVMConstStructInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStructInContext(LLVMContextRef C, LLVMValueRef *ConstantVals, unsigned int Count, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMConstStructInContext(MemorySegment C, MemorySegment ConstantVals, int Count, int Packed) {
        var mh$ = LLVMConstStructInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstStructInContext", C, ConstantVals, Count, Packed);
            }
            return (MemorySegment)mh$.invokeExact(C, ConstantVals, Count, Packed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstStruct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstStruct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStruct(LLVMValueRef *ConstantVals, unsigned int Count, LLVMBool Packed)
     * }
     */
    public static FunctionDescriptor LLVMConstStruct$descriptor() {
        return LLVMConstStruct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStruct(LLVMValueRef *ConstantVals, unsigned int Count, LLVMBool Packed)
     * }
     */
    public static MethodHandle LLVMConstStruct$handle() {
        return LLVMConstStruct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStruct(LLVMValueRef *ConstantVals, unsigned int Count, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMConstStruct$address() {
        return LLVMConstStruct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstStruct(LLVMValueRef *ConstantVals, unsigned int Count, LLVMBool Packed)
     * }
     */
    public static MemorySegment LLVMConstStruct(MemorySegment ConstantVals, int Count, int Packed) {
        var mh$ = LLVMConstStruct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstStruct", ConstantVals, Count, Packed);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVals, Count, Packed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstArray(LLVMTypeRef ElementTy, LLVMValueRef *ConstantVals, unsigned int Length)
     * }
     */
    public static FunctionDescriptor LLVMConstArray$descriptor() {
        return LLVMConstArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstArray(LLVMTypeRef ElementTy, LLVMValueRef *ConstantVals, unsigned int Length)
     * }
     */
    public static MethodHandle LLVMConstArray$handle() {
        return LLVMConstArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstArray(LLVMTypeRef ElementTy, LLVMValueRef *ConstantVals, unsigned int Length)
     * }
     */
    public static MemorySegment LLVMConstArray$address() {
        return LLVMConstArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstArray(LLVMTypeRef ElementTy, LLVMValueRef *ConstantVals, unsigned int Length)
     * }
     */
    public static MemorySegment LLVMConstArray(MemorySegment ElementTy, MemorySegment ConstantVals, int Length) {
        var mh$ = LLVMConstArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstArray", ElementTy, ConstantVals, Length);
            }
            return (MemorySegment)mh$.invokeExact(ElementTy, ConstantVals, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstArray2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstArray2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstArray2(LLVMTypeRef ElementTy, LLVMValueRef *ConstantVals, uint64_t Length)
     * }
     */
    public static FunctionDescriptor LLVMConstArray2$descriptor() {
        return LLVMConstArray2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstArray2(LLVMTypeRef ElementTy, LLVMValueRef *ConstantVals, uint64_t Length)
     * }
     */
    public static MethodHandle LLVMConstArray2$handle() {
        return LLVMConstArray2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstArray2(LLVMTypeRef ElementTy, LLVMValueRef *ConstantVals, uint64_t Length)
     * }
     */
    public static MemorySegment LLVMConstArray2$address() {
        return LLVMConstArray2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstArray2(LLVMTypeRef ElementTy, LLVMValueRef *ConstantVals, uint64_t Length)
     * }
     */
    public static MemorySegment LLVMConstArray2(MemorySegment ElementTy, MemorySegment ConstantVals, long Length) {
        var mh$ = LLVMConstArray2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstArray2", ElementTy, ConstantVals, Length);
            }
            return (MemorySegment)mh$.invokeExact(ElementTy, ConstantVals, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNamedStruct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNamedStruct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNamedStruct(LLVMTypeRef StructTy, LLVMValueRef *ConstantVals, unsigned int Count)
     * }
     */
    public static FunctionDescriptor LLVMConstNamedStruct$descriptor() {
        return LLVMConstNamedStruct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNamedStruct(LLVMTypeRef StructTy, LLVMValueRef *ConstantVals, unsigned int Count)
     * }
     */
    public static MethodHandle LLVMConstNamedStruct$handle() {
        return LLVMConstNamedStruct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNamedStruct(LLVMTypeRef StructTy, LLVMValueRef *ConstantVals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMConstNamedStruct$address() {
        return LLVMConstNamedStruct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNamedStruct(LLVMTypeRef StructTy, LLVMValueRef *ConstantVals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMConstNamedStruct(MemorySegment StructTy, MemorySegment ConstantVals, int Count) {
        var mh$ = LLVMConstNamedStruct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNamedStruct", StructTy, ConstantVals, Count);
            }
            return (MemorySegment)mh$.invokeExact(StructTy, ConstantVals, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAggregateElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAggregateElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetAggregateElement(LLVMValueRef C, unsigned int Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetAggregateElement$descriptor() {
        return LLVMGetAggregateElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetAggregateElement(LLVMValueRef C, unsigned int Idx)
     * }
     */
    public static MethodHandle LLVMGetAggregateElement$handle() {
        return LLVMGetAggregateElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetAggregateElement(LLVMValueRef C, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetAggregateElement$address() {
        return LLVMGetAggregateElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetAggregateElement(LLVMValueRef C, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetAggregateElement(MemorySegment C, int Idx) {
        var mh$ = LLVMGetAggregateElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAggregateElement", C, Idx);
            }
            return (MemorySegment)mh$.invokeExact(C, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetElementAsConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetElementAsConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetElementAsConstant(LLVMValueRef C, unsigned int idx)
     * }
     */
    public static FunctionDescriptor LLVMGetElementAsConstant$descriptor() {
        return LLVMGetElementAsConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetElementAsConstant(LLVMValueRef C, unsigned int idx)
     * }
     */
    public static MethodHandle LLVMGetElementAsConstant$handle() {
        return LLVMGetElementAsConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetElementAsConstant(LLVMValueRef C, unsigned int idx)
     * }
     */
    public static MemorySegment LLVMGetElementAsConstant$address() {
        return LLVMGetElementAsConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetElementAsConstant(LLVMValueRef C, unsigned int idx)
     * }
     */
    public static MemorySegment LLVMGetElementAsConstant(MemorySegment C, int idx) {
        var mh$ = LLVMGetElementAsConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetElementAsConstant", C, idx);
            }
            return (MemorySegment)mh$.invokeExact(C, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstVector(LLVMValueRef *ScalarConstantVals, unsigned int Size)
     * }
     */
    public static FunctionDescriptor LLVMConstVector$descriptor() {
        return LLVMConstVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstVector(LLVMValueRef *ScalarConstantVals, unsigned int Size)
     * }
     */
    public static MethodHandle LLVMConstVector$handle() {
        return LLVMConstVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstVector(LLVMValueRef *ScalarConstantVals, unsigned int Size)
     * }
     */
    public static MemorySegment LLVMConstVector$address() {
        return LLVMConstVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstVector(LLVMValueRef *ScalarConstantVals, unsigned int Size)
     * }
     */
    public static MemorySegment LLVMConstVector(MemorySegment ScalarConstantVals, int Size) {
        var mh$ = LLVMConstVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstVector", ScalarConstantVals, Size);
            }
            return (MemorySegment)mh$.invokeExact(ScalarConstantVals, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstantPtrAuth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstantPtrAuth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstantPtrAuth(LLVMValueRef Ptr, LLVMValueRef Key, LLVMValueRef Disc, LLVMValueRef AddrDisc)
     * }
     */
    public static FunctionDescriptor LLVMConstantPtrAuth$descriptor() {
        return LLVMConstantPtrAuth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstantPtrAuth(LLVMValueRef Ptr, LLVMValueRef Key, LLVMValueRef Disc, LLVMValueRef AddrDisc)
     * }
     */
    public static MethodHandle LLVMConstantPtrAuth$handle() {
        return LLVMConstantPtrAuth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstantPtrAuth(LLVMValueRef Ptr, LLVMValueRef Key, LLVMValueRef Disc, LLVMValueRef AddrDisc)
     * }
     */
    public static MemorySegment LLVMConstantPtrAuth$address() {
        return LLVMConstantPtrAuth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstantPtrAuth(LLVMValueRef Ptr, LLVMValueRef Key, LLVMValueRef Disc, LLVMValueRef AddrDisc)
     * }
     */
    public static MemorySegment LLVMConstantPtrAuth(MemorySegment Ptr, MemorySegment Key, MemorySegment Disc, MemorySegment AddrDisc) {
        var mh$ = LLVMConstantPtrAuth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstantPtrAuth", Ptr, Key, Disc, AddrDisc);
            }
            return (MemorySegment)mh$.invokeExact(Ptr, Key, Disc, AddrDisc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetConstOpcode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetConstOpcode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetConstOpcode(LLVMValueRef ConstantVal)
     * }
     */
    public static FunctionDescriptor LLVMGetConstOpcode$descriptor() {
        return LLVMGetConstOpcode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetConstOpcode(LLVMValueRef ConstantVal)
     * }
     */
    public static MethodHandle LLVMGetConstOpcode$handle() {
        return LLVMGetConstOpcode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetConstOpcode(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMGetConstOpcode$address() {
        return LLVMGetConstOpcode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetConstOpcode(LLVMValueRef ConstantVal)
     * }
     */
    public static int LLVMGetConstOpcode(MemorySegment ConstantVal) {
        var mh$ = LLVMGetConstOpcode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetConstOpcode", ConstantVal);
            }
            return (int)mh$.invokeExact(ConstantVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAlignOf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAlignOf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAlignOf(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMAlignOf$descriptor() {
        return LLVMAlignOf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAlignOf(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMAlignOf$handle() {
        return LLVMAlignOf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAlignOf(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMAlignOf$address() {
        return LLVMAlignOf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMAlignOf(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMAlignOf(MemorySegment Ty) {
        var mh$ = LLVMAlignOf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAlignOf", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSizeOf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSizeOf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMSizeOf(LLVMTypeRef Ty)
     * }
     */
    public static FunctionDescriptor LLVMSizeOf$descriptor() {
        return LLVMSizeOf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMSizeOf(LLVMTypeRef Ty)
     * }
     */
    public static MethodHandle LLVMSizeOf$handle() {
        return LLVMSizeOf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMSizeOf(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMSizeOf$address() {
        return LLVMSizeOf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMSizeOf(LLVMTypeRef Ty)
     * }
     */
    public static MemorySegment LLVMSizeOf(MemorySegment Ty) {
        var mh$ = LLVMSizeOf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSizeOf", Ty);
            }
            return (MemorySegment)mh$.invokeExact(Ty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static FunctionDescriptor LLVMConstNeg$descriptor() {
        return LLVMConstNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MethodHandle LLVMConstNeg$handle() {
        return LLVMConstNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstNeg$address() {
        return LLVMConstNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstNeg(MemorySegment ConstantVal) {
        var mh$ = LLVMConstNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNeg", ConstantVal);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNSWNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNSWNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static FunctionDescriptor LLVMConstNSWNeg$descriptor() {
        return LLVMConstNSWNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MethodHandle LLVMConstNSWNeg$handle() {
        return LLVMConstNSWNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstNSWNeg$address() {
        return LLVMConstNSWNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstNSWNeg(MemorySegment ConstantVal) {
        var mh$ = LLVMConstNSWNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNSWNeg", ConstantVal);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNUWNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNUWNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static FunctionDescriptor LLVMConstNUWNeg$descriptor() {
        return LLVMConstNUWNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MethodHandle LLVMConstNUWNeg$handle() {
        return LLVMConstNUWNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstNUWNeg$address() {
        return LLVMConstNUWNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWNeg(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstNUWNeg(MemorySegment ConstantVal) {
        var mh$ = LLVMConstNUWNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNUWNeg", ConstantVal);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNot(LLVMValueRef ConstantVal)
     * }
     */
    public static FunctionDescriptor LLVMConstNot$descriptor() {
        return LLVMConstNot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNot(LLVMValueRef ConstantVal)
     * }
     */
    public static MethodHandle LLVMConstNot$handle() {
        return LLVMConstNot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNot(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstNot$address() {
        return LLVMConstNot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNot(LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMConstNot(MemorySegment ConstantVal) {
        var mh$ = LLVMConstNot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNot", ConstantVal);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstAdd$descriptor() {
        return LLVMConstAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstAdd$handle() {
        return LLVMConstAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstAdd$address() {
        return LLVMConstAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstAdd(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstAdd", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNSWAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNSWAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstNSWAdd$descriptor() {
        return LLVMConstNSWAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstNSWAdd$handle() {
        return LLVMConstNSWAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNSWAdd$address() {
        return LLVMConstNSWAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNSWAdd(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstNSWAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNSWAdd", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNUWAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNUWAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstNUWAdd$descriptor() {
        return LLVMConstNUWAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstNUWAdd$handle() {
        return LLVMConstNUWAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNUWAdd$address() {
        return LLVMConstNUWAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWAdd(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNUWAdd(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstNUWAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNUWAdd", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstSub$descriptor() {
        return LLVMConstSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstSub$handle() {
        return LLVMConstSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstSub$address() {
        return LLVMConstSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstSub(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstSub", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNSWSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNSWSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstNSWSub$descriptor() {
        return LLVMConstNSWSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstNSWSub$handle() {
        return LLVMConstNSWSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNSWSub$address() {
        return LLVMConstNSWSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNSWSub(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstNSWSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNSWSub", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNUWSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNUWSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstNUWSub$descriptor() {
        return LLVMConstNUWSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstNUWSub$handle() {
        return LLVMConstNUWSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNUWSub$address() {
        return LLVMConstNUWSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWSub(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNUWSub(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstNUWSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNUWSub", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstMul$descriptor() {
        return LLVMConstMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstMul$handle() {
        return LLVMConstMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstMul$address() {
        return LLVMConstMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstMul(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstMul", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNSWMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNSWMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstNSWMul$descriptor() {
        return LLVMConstNSWMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstNSWMul$handle() {
        return LLVMConstNSWMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNSWMul$address() {
        return LLVMConstNSWMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNSWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNSWMul(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstNSWMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNSWMul", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstNUWMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstNUWMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstNUWMul$descriptor() {
        return LLVMConstNUWMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstNUWMul$handle() {
        return LLVMConstNUWMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNUWMul$address() {
        return LLVMConstNUWMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstNUWMul(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstNUWMul(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstNUWMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstNUWMul", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstXor(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstXor$descriptor() {
        return LLVMConstXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstXor(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MethodHandle LLVMConstXor$handle() {
        return LLVMConstXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstXor(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstXor$address() {
        return LLVMConstXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstXor(LLVMValueRef LHSConstant, LLVMValueRef RHSConstant)
     * }
     */
    public static MemorySegment LLVMConstXor(MemorySegment LHSConstant, MemorySegment RHSConstant) {
        var mh$ = LLVMConstXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstXor", LHSConstant, RHSConstant);
            }
            return (MemorySegment)mh$.invokeExact(LHSConstant, RHSConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstGEP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstGEP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstGEP2(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices)
     * }
     */
    public static FunctionDescriptor LLVMConstGEP2$descriptor() {
        return LLVMConstGEP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstGEP2(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices)
     * }
     */
    public static MethodHandle LLVMConstGEP2$handle() {
        return LLVMConstGEP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstGEP2(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices)
     * }
     */
    public static MemorySegment LLVMConstGEP2$address() {
        return LLVMConstGEP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstGEP2(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices)
     * }
     */
    public static MemorySegment LLVMConstGEP2(MemorySegment Ty, MemorySegment ConstantVal, MemorySegment ConstantIndices, int NumIndices) {
        var mh$ = LLVMConstGEP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstGEP2", Ty, ConstantVal, ConstantIndices, NumIndices);
            }
            return (MemorySegment)mh$.invokeExact(Ty, ConstantVal, ConstantIndices, NumIndices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstInBoundsGEP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstInBoundsGEP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInBoundsGEP2(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices)
     * }
     */
    public static FunctionDescriptor LLVMConstInBoundsGEP2$descriptor() {
        return LLVMConstInBoundsGEP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInBoundsGEP2(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices)
     * }
     */
    public static MethodHandle LLVMConstInBoundsGEP2$handle() {
        return LLVMConstInBoundsGEP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInBoundsGEP2(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices)
     * }
     */
    public static MemorySegment LLVMConstInBoundsGEP2$address() {
        return LLVMConstInBoundsGEP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInBoundsGEP2(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices)
     * }
     */
    public static MemorySegment LLVMConstInBoundsGEP2(MemorySegment Ty, MemorySegment ConstantVal, MemorySegment ConstantIndices, int NumIndices) {
        var mh$ = LLVMConstInBoundsGEP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstInBoundsGEP2", Ty, ConstantVal, ConstantIndices, NumIndices);
            }
            return (MemorySegment)mh$.invokeExact(Ty, ConstantVal, ConstantIndices, NumIndices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstGEPWithNoWrapFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstGEPWithNoWrapFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstGEPWithNoWrapFlags(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static FunctionDescriptor LLVMConstGEPWithNoWrapFlags$descriptor() {
        return LLVMConstGEPWithNoWrapFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstGEPWithNoWrapFlags(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MethodHandle LLVMConstGEPWithNoWrapFlags$handle() {
        return LLVMConstGEPWithNoWrapFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstGEPWithNoWrapFlags(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MemorySegment LLVMConstGEPWithNoWrapFlags$address() {
        return LLVMConstGEPWithNoWrapFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstGEPWithNoWrapFlags(LLVMTypeRef Ty, LLVMValueRef ConstantVal, LLVMValueRef *ConstantIndices, unsigned int NumIndices, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MemorySegment LLVMConstGEPWithNoWrapFlags(MemorySegment Ty, MemorySegment ConstantVal, MemorySegment ConstantIndices, int NumIndices, int NoWrapFlags) {
        var mh$ = LLVMConstGEPWithNoWrapFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstGEPWithNoWrapFlags", Ty, ConstantVal, ConstantIndices, NumIndices, NoWrapFlags);
            }
            return (MemorySegment)mh$.invokeExact(Ty, ConstantVal, ConstantIndices, NumIndices, NoWrapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstTrunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstTrunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstTrunc(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static FunctionDescriptor LLVMConstTrunc$descriptor() {
        return LLVMConstTrunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstTrunc(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MethodHandle LLVMConstTrunc$handle() {
        return LLVMConstTrunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstTrunc(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstTrunc$address() {
        return LLVMConstTrunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstTrunc(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstTrunc(MemorySegment ConstantVal, MemorySegment ToType) {
        var mh$ = LLVMConstTrunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstTrunc", ConstantVal, ToType);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal, ToType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstPtrToInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstPtrToInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPtrToInt(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static FunctionDescriptor LLVMConstPtrToInt$descriptor() {
        return LLVMConstPtrToInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPtrToInt(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MethodHandle LLVMConstPtrToInt$handle() {
        return LLVMConstPtrToInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPtrToInt(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstPtrToInt$address() {
        return LLVMConstPtrToInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPtrToInt(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstPtrToInt(MemorySegment ConstantVal, MemorySegment ToType) {
        var mh$ = LLVMConstPtrToInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstPtrToInt", ConstantVal, ToType);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal, ToType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstIntToPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstIntToPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntToPtr(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static FunctionDescriptor LLVMConstIntToPtr$descriptor() {
        return LLVMConstIntToPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntToPtr(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MethodHandle LLVMConstIntToPtr$handle() {
        return LLVMConstIntToPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntToPtr(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstIntToPtr$address() {
        return LLVMConstIntToPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstIntToPtr(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstIntToPtr(MemorySegment ConstantVal, MemorySegment ToType) {
        var mh$ = LLVMConstIntToPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstIntToPtr", ConstantVal, ToType);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal, ToType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static FunctionDescriptor LLVMConstBitCast$descriptor() {
        return LLVMConstBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MethodHandle LLVMConstBitCast$handle() {
        return LLVMConstBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstBitCast$address() {
        return LLVMConstBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstBitCast(MemorySegment ConstantVal, MemorySegment ToType) {
        var mh$ = LLVMConstBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstBitCast", ConstantVal, ToType);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal, ToType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstAddrSpaceCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstAddrSpaceCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAddrSpaceCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static FunctionDescriptor LLVMConstAddrSpaceCast$descriptor() {
        return LLVMConstAddrSpaceCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAddrSpaceCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MethodHandle LLVMConstAddrSpaceCast$handle() {
        return LLVMConstAddrSpaceCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAddrSpaceCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstAddrSpaceCast$address() {
        return LLVMConstAddrSpaceCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstAddrSpaceCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstAddrSpaceCast(MemorySegment ConstantVal, MemorySegment ToType) {
        var mh$ = LLVMConstAddrSpaceCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstAddrSpaceCast", ConstantVal, ToType);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal, ToType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstTruncOrBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstTruncOrBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstTruncOrBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static FunctionDescriptor LLVMConstTruncOrBitCast$descriptor() {
        return LLVMConstTruncOrBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstTruncOrBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MethodHandle LLVMConstTruncOrBitCast$handle() {
        return LLVMConstTruncOrBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstTruncOrBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstTruncOrBitCast$address() {
        return LLVMConstTruncOrBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstTruncOrBitCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstTruncOrBitCast(MemorySegment ConstantVal, MemorySegment ToType) {
        var mh$ = LLVMConstTruncOrBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstTruncOrBitCast", ConstantVal, ToType);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal, ToType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstPointerCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstPointerCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPointerCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static FunctionDescriptor LLVMConstPointerCast$descriptor() {
        return LLVMConstPointerCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPointerCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MethodHandle LLVMConstPointerCast$handle() {
        return LLVMConstPointerCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPointerCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstPointerCast$address() {
        return LLVMConstPointerCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstPointerCast(LLVMValueRef ConstantVal, LLVMTypeRef ToType)
     * }
     */
    public static MemorySegment LLVMConstPointerCast(MemorySegment ConstantVal, MemorySegment ToType) {
        var mh$ = LLVMConstPointerCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstPointerCast", ConstantVal, ToType);
            }
            return (MemorySegment)mh$.invokeExact(ConstantVal, ToType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstExtractElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstExtractElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstExtractElement(LLVMValueRef VectorConstant, LLVMValueRef IndexConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstExtractElement$descriptor() {
        return LLVMConstExtractElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstExtractElement(LLVMValueRef VectorConstant, LLVMValueRef IndexConstant)
     * }
     */
    public static MethodHandle LLVMConstExtractElement$handle() {
        return LLVMConstExtractElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstExtractElement(LLVMValueRef VectorConstant, LLVMValueRef IndexConstant)
     * }
     */
    public static MemorySegment LLVMConstExtractElement$address() {
        return LLVMConstExtractElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstExtractElement(LLVMValueRef VectorConstant, LLVMValueRef IndexConstant)
     * }
     */
    public static MemorySegment LLVMConstExtractElement(MemorySegment VectorConstant, MemorySegment IndexConstant) {
        var mh$ = LLVMConstExtractElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstExtractElement", VectorConstant, IndexConstant);
            }
            return (MemorySegment)mh$.invokeExact(VectorConstant, IndexConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstInsertElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstInsertElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInsertElement(LLVMValueRef VectorConstant, LLVMValueRef ElementValueConstant, LLVMValueRef IndexConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstInsertElement$descriptor() {
        return LLVMConstInsertElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInsertElement(LLVMValueRef VectorConstant, LLVMValueRef ElementValueConstant, LLVMValueRef IndexConstant)
     * }
     */
    public static MethodHandle LLVMConstInsertElement$handle() {
        return LLVMConstInsertElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInsertElement(LLVMValueRef VectorConstant, LLVMValueRef ElementValueConstant, LLVMValueRef IndexConstant)
     * }
     */
    public static MemorySegment LLVMConstInsertElement$address() {
        return LLVMConstInsertElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInsertElement(LLVMValueRef VectorConstant, LLVMValueRef ElementValueConstant, LLVMValueRef IndexConstant)
     * }
     */
    public static MemorySegment LLVMConstInsertElement(MemorySegment VectorConstant, MemorySegment ElementValueConstant, MemorySegment IndexConstant) {
        var mh$ = LLVMConstInsertElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstInsertElement", VectorConstant, ElementValueConstant, IndexConstant);
            }
            return (MemorySegment)mh$.invokeExact(VectorConstant, ElementValueConstant, IndexConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstShuffleVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstShuffleVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstShuffleVector(LLVMValueRef VectorAConstant, LLVMValueRef VectorBConstant, LLVMValueRef MaskConstant)
     * }
     */
    public static FunctionDescriptor LLVMConstShuffleVector$descriptor() {
        return LLVMConstShuffleVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstShuffleVector(LLVMValueRef VectorAConstant, LLVMValueRef VectorBConstant, LLVMValueRef MaskConstant)
     * }
     */
    public static MethodHandle LLVMConstShuffleVector$handle() {
        return LLVMConstShuffleVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstShuffleVector(LLVMValueRef VectorAConstant, LLVMValueRef VectorBConstant, LLVMValueRef MaskConstant)
     * }
     */
    public static MemorySegment LLVMConstShuffleVector$address() {
        return LLVMConstShuffleVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstShuffleVector(LLVMValueRef VectorAConstant, LLVMValueRef VectorBConstant, LLVMValueRef MaskConstant)
     * }
     */
    public static MemorySegment LLVMConstShuffleVector(MemorySegment VectorAConstant, MemorySegment VectorBConstant, MemorySegment MaskConstant) {
        var mh$ = LLVMConstShuffleVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstShuffleVector", VectorAConstant, VectorBConstant, MaskConstant);
            }
            return (MemorySegment)mh$.invokeExact(VectorAConstant, VectorBConstant, MaskConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBlockAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBlockAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBlockAddress(LLVMValueRef F, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMBlockAddress$descriptor() {
        return LLVMBlockAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBlockAddress(LLVMValueRef F, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMBlockAddress$handle() {
        return LLVMBlockAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBlockAddress(LLVMValueRef F, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBlockAddress$address() {
        return LLVMBlockAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBlockAddress(LLVMValueRef F, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBlockAddress(MemorySegment F, MemorySegment BB) {
        var mh$ = LLVMBlockAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBlockAddress", F, BB);
            }
            return (MemorySegment)mh$.invokeExact(F, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBlockAddressFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBlockAddressFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBlockAddressFunction(LLVMValueRef BlockAddr)
     * }
     */
    public static FunctionDescriptor LLVMGetBlockAddressFunction$descriptor() {
        return LLVMGetBlockAddressFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBlockAddressFunction(LLVMValueRef BlockAddr)
     * }
     */
    public static MethodHandle LLVMGetBlockAddressFunction$handle() {
        return LLVMGetBlockAddressFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBlockAddressFunction(LLVMValueRef BlockAddr)
     * }
     */
    public static MemorySegment LLVMGetBlockAddressFunction$address() {
        return LLVMGetBlockAddressFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBlockAddressFunction(LLVMValueRef BlockAddr)
     * }
     */
    public static MemorySegment LLVMGetBlockAddressFunction(MemorySegment BlockAddr) {
        var mh$ = LLVMGetBlockAddressFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBlockAddressFunction", BlockAddr);
            }
            return (MemorySegment)mh$.invokeExact(BlockAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBlockAddressBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBlockAddressBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetBlockAddressBasicBlock(LLVMValueRef BlockAddr)
     * }
     */
    public static FunctionDescriptor LLVMGetBlockAddressBasicBlock$descriptor() {
        return LLVMGetBlockAddressBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetBlockAddressBasicBlock(LLVMValueRef BlockAddr)
     * }
     */
    public static MethodHandle LLVMGetBlockAddressBasicBlock$handle() {
        return LLVMGetBlockAddressBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetBlockAddressBasicBlock(LLVMValueRef BlockAddr)
     * }
     */
    public static MemorySegment LLVMGetBlockAddressBasicBlock$address() {
        return LLVMGetBlockAddressBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetBlockAddressBasicBlock(LLVMValueRef BlockAddr)
     * }
     */
    public static MemorySegment LLVMGetBlockAddressBasicBlock(MemorySegment BlockAddr) {
        var mh$ = LLVMGetBlockAddressBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBlockAddressBasicBlock", BlockAddr);
            }
            return (MemorySegment)mh$.invokeExact(BlockAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMConstInlineAsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMConstInlineAsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInlineAsm(LLVMTypeRef Ty, const char *AsmString, const char *Constraints, LLVMBool HasSideEffects, LLVMBool IsAlignStack)
     * }
     */
    public static FunctionDescriptor LLVMConstInlineAsm$descriptor() {
        return LLVMConstInlineAsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInlineAsm(LLVMTypeRef Ty, const char *AsmString, const char *Constraints, LLVMBool HasSideEffects, LLVMBool IsAlignStack)
     * }
     */
    public static MethodHandle LLVMConstInlineAsm$handle() {
        return LLVMConstInlineAsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInlineAsm(LLVMTypeRef Ty, const char *AsmString, const char *Constraints, LLVMBool HasSideEffects, LLVMBool IsAlignStack)
     * }
     */
    public static MemorySegment LLVMConstInlineAsm$address() {
        return LLVMConstInlineAsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMConstInlineAsm(LLVMTypeRef Ty, const char *AsmString, const char *Constraints, LLVMBool HasSideEffects, LLVMBool IsAlignStack)
     * }
     */
    public static MemorySegment LLVMConstInlineAsm(MemorySegment Ty, MemorySegment AsmString, MemorySegment Constraints, int HasSideEffects, int IsAlignStack) {
        var mh$ = LLVMConstInlineAsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMConstInlineAsm", Ty, AsmString, Constraints, HasSideEffects, IsAlignStack);
            }
            return (MemorySegment)mh$.invokeExact(Ty, AsmString, Constraints, HasSideEffects, IsAlignStack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetGlobalParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetGlobalParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMGetGlobalParent(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGetGlobalParent$descriptor() {
        return LLVMGetGlobalParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMGetGlobalParent(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGetGlobalParent$handle() {
        return LLVMGetGlobalParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMModuleRef LLVMGetGlobalParent(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetGlobalParent$address() {
        return LLVMGetGlobalParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMModuleRef LLVMGetGlobalParent(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetGlobalParent(MemorySegment Global) {
        var mh$ = LLVMGetGlobalParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetGlobalParent", Global);
            }
            return (MemorySegment)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsDeclaration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsDeclaration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsDeclaration(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMIsDeclaration$descriptor() {
        return LLVMIsDeclaration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsDeclaration(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMIsDeclaration$handle() {
        return LLVMIsDeclaration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsDeclaration(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMIsDeclaration$address() {
        return LLVMIsDeclaration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsDeclaration(LLVMValueRef Global)
     * }
     */
    public static int LLVMIsDeclaration(MemorySegment Global) {
        var mh$ = LLVMIsDeclaration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsDeclaration", Global);
            }
            return (int)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLinkage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLinkage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMLinkage LLVMGetLinkage(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGetLinkage$descriptor() {
        return LLVMGetLinkage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMLinkage LLVMGetLinkage(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGetLinkage$handle() {
        return LLVMGetLinkage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMLinkage LLVMGetLinkage(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetLinkage$address() {
        return LLVMGetLinkage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMLinkage LLVMGetLinkage(LLVMValueRef Global)
     * }
     */
    public static int LLVMGetLinkage(MemorySegment Global) {
        var mh$ = LLVMGetLinkage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLinkage", Global);
            }
            return (int)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetLinkage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetLinkage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetLinkage(LLVMValueRef Global, LLVMLinkage Linkage)
     * }
     */
    public static FunctionDescriptor LLVMSetLinkage$descriptor() {
        return LLVMSetLinkage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetLinkage(LLVMValueRef Global, LLVMLinkage Linkage)
     * }
     */
    public static MethodHandle LLVMSetLinkage$handle() {
        return LLVMSetLinkage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetLinkage(LLVMValueRef Global, LLVMLinkage Linkage)
     * }
     */
    public static MemorySegment LLVMSetLinkage$address() {
        return LLVMSetLinkage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetLinkage(LLVMValueRef Global, LLVMLinkage Linkage)
     * }
     */
    public static void LLVMSetLinkage(MemorySegment Global, int Linkage) {
        var mh$ = LLVMSetLinkage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetLinkage", Global, Linkage);
            }
            mh$.invokeExact(Global, Linkage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetSection(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGetSection$descriptor() {
        return LLVMGetSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetSection(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGetSection$handle() {
        return LLVMGetSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetSection(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetSection$address() {
        return LLVMGetSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetSection(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetSection(MemorySegment Global) {
        var mh$ = LLVMGetSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetSection", Global);
            }
            return (MemorySegment)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetSection(LLVMValueRef Global, const char *Section)
     * }
     */
    public static FunctionDescriptor LLVMSetSection$descriptor() {
        return LLVMSetSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetSection(LLVMValueRef Global, const char *Section)
     * }
     */
    public static MethodHandle LLVMSetSection$handle() {
        return LLVMSetSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetSection(LLVMValueRef Global, const char *Section)
     * }
     */
    public static MemorySegment LLVMSetSection$address() {
        return LLVMSetSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetSection(LLVMValueRef Global, const char *Section)
     * }
     */
    public static void LLVMSetSection(MemorySegment Global, MemorySegment Section) {
        var mh$ = LLVMSetSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetSection", Global, Section);
            }
            mh$.invokeExact(Global, Section);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetVisibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetVisibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMVisibility LLVMGetVisibility(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGetVisibility$descriptor() {
        return LLVMGetVisibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMVisibility LLVMGetVisibility(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGetVisibility$handle() {
        return LLVMGetVisibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMVisibility LLVMGetVisibility(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetVisibility$address() {
        return LLVMGetVisibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMVisibility LLVMGetVisibility(LLVMValueRef Global)
     * }
     */
    public static int LLVMGetVisibility(MemorySegment Global) {
        var mh$ = LLVMGetVisibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetVisibility", Global);
            }
            return (int)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetVisibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetVisibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetVisibility(LLVMValueRef Global, LLVMVisibility Viz)
     * }
     */
    public static FunctionDescriptor LLVMSetVisibility$descriptor() {
        return LLVMSetVisibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetVisibility(LLVMValueRef Global, LLVMVisibility Viz)
     * }
     */
    public static MethodHandle LLVMSetVisibility$handle() {
        return LLVMSetVisibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetVisibility(LLVMValueRef Global, LLVMVisibility Viz)
     * }
     */
    public static MemorySegment LLVMSetVisibility$address() {
        return LLVMSetVisibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetVisibility(LLVMValueRef Global, LLVMVisibility Viz)
     * }
     */
    public static void LLVMSetVisibility(MemorySegment Global, int Viz) {
        var mh$ = LLVMSetVisibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetVisibility", Global, Viz);
            }
            mh$.invokeExact(Global, Viz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetDLLStorageClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetDLLStorageClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDLLStorageClass LLVMGetDLLStorageClass(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGetDLLStorageClass$descriptor() {
        return LLVMGetDLLStorageClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDLLStorageClass LLVMGetDLLStorageClass(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGetDLLStorageClass$handle() {
        return LLVMGetDLLStorageClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDLLStorageClass LLVMGetDLLStorageClass(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetDLLStorageClass$address() {
        return LLVMGetDLLStorageClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDLLStorageClass LLVMGetDLLStorageClass(LLVMValueRef Global)
     * }
     */
    public static int LLVMGetDLLStorageClass(MemorySegment Global) {
        var mh$ = LLVMGetDLLStorageClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetDLLStorageClass", Global);
            }
            return (int)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetDLLStorageClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetDLLStorageClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetDLLStorageClass(LLVMValueRef Global, LLVMDLLStorageClass Class)
     * }
     */
    public static FunctionDescriptor LLVMSetDLLStorageClass$descriptor() {
        return LLVMSetDLLStorageClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetDLLStorageClass(LLVMValueRef Global, LLVMDLLStorageClass Class)
     * }
     */
    public static MethodHandle LLVMSetDLLStorageClass$handle() {
        return LLVMSetDLLStorageClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetDLLStorageClass(LLVMValueRef Global, LLVMDLLStorageClass Class)
     * }
     */
    public static MemorySegment LLVMSetDLLStorageClass$address() {
        return LLVMSetDLLStorageClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetDLLStorageClass(LLVMValueRef Global, LLVMDLLStorageClass Class)
     * }
     */
    public static void LLVMSetDLLStorageClass(MemorySegment Global, int Class_) {
        var mh$ = LLVMSetDLLStorageClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetDLLStorageClass", Global, Class_);
            }
            mh$.invokeExact(Global, Class_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetUnnamedAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetUnnamedAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMUnnamedAddr LLVMGetUnnamedAddress(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGetUnnamedAddress$descriptor() {
        return LLVMGetUnnamedAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMUnnamedAddr LLVMGetUnnamedAddress(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGetUnnamedAddress$handle() {
        return LLVMGetUnnamedAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMUnnamedAddr LLVMGetUnnamedAddress(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGetUnnamedAddress$address() {
        return LLVMGetUnnamedAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMUnnamedAddr LLVMGetUnnamedAddress(LLVMValueRef Global)
     * }
     */
    public static int LLVMGetUnnamedAddress(MemorySegment Global) {
        var mh$ = LLVMGetUnnamedAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetUnnamedAddress", Global);
            }
            return (int)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetUnnamedAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetUnnamedAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetUnnamedAddress(LLVMValueRef Global, LLVMUnnamedAddr UnnamedAddr)
     * }
     */
    public static FunctionDescriptor LLVMSetUnnamedAddress$descriptor() {
        return LLVMSetUnnamedAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetUnnamedAddress(LLVMValueRef Global, LLVMUnnamedAddr UnnamedAddr)
     * }
     */
    public static MethodHandle LLVMSetUnnamedAddress$handle() {
        return LLVMSetUnnamedAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetUnnamedAddress(LLVMValueRef Global, LLVMUnnamedAddr UnnamedAddr)
     * }
     */
    public static MemorySegment LLVMSetUnnamedAddress$address() {
        return LLVMSetUnnamedAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetUnnamedAddress(LLVMValueRef Global, LLVMUnnamedAddr UnnamedAddr)
     * }
     */
    public static void LLVMSetUnnamedAddress(MemorySegment Global, int UnnamedAddr) {
        var mh$ = LLVMSetUnnamedAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetUnnamedAddress", Global, UnnamedAddr);
            }
            mh$.invokeExact(Global, UnnamedAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGlobalGetValueType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGlobalGetValueType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGlobalGetValueType(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGlobalGetValueType$descriptor() {
        return LLVMGlobalGetValueType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGlobalGetValueType(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGlobalGetValueType$handle() {
        return LLVMGlobalGetValueType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGlobalGetValueType(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGlobalGetValueType$address() {
        return LLVMGlobalGetValueType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGlobalGetValueType(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGlobalGetValueType(MemorySegment Global) {
        var mh$ = LLVMGlobalGetValueType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGlobalGetValueType", Global);
            }
            return (MemorySegment)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMHasUnnamedAddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMHasUnnamedAddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasUnnamedAddr(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMHasUnnamedAddr$descriptor() {
        return LLVMHasUnnamedAddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasUnnamedAddr(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMHasUnnamedAddr$handle() {
        return LLVMHasUnnamedAddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasUnnamedAddr(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMHasUnnamedAddr$address() {
        return LLVMHasUnnamedAddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMHasUnnamedAddr(LLVMValueRef Global)
     * }
     */
    public static int LLVMHasUnnamedAddr(MemorySegment Global) {
        var mh$ = LLVMHasUnnamedAddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMHasUnnamedAddr", Global);
            }
            return (int)mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetUnnamedAddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetUnnamedAddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetUnnamedAddr(LLVMValueRef Global, LLVMBool HasUnnamedAddr)
     * }
     */
    public static FunctionDescriptor LLVMSetUnnamedAddr$descriptor() {
        return LLVMSetUnnamedAddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetUnnamedAddr(LLVMValueRef Global, LLVMBool HasUnnamedAddr)
     * }
     */
    public static MethodHandle LLVMSetUnnamedAddr$handle() {
        return LLVMSetUnnamedAddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetUnnamedAddr(LLVMValueRef Global, LLVMBool HasUnnamedAddr)
     * }
     */
    public static MemorySegment LLVMSetUnnamedAddr$address() {
        return LLVMSetUnnamedAddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetUnnamedAddr(LLVMValueRef Global, LLVMBool HasUnnamedAddr)
     * }
     */
    public static void LLVMSetUnnamedAddr(MemorySegment Global, int HasUnnamedAddr) {
        var mh$ = LLVMSetUnnamedAddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetUnnamedAddr", Global, HasUnnamedAddr);
            }
            mh$.invokeExact(Global, HasUnnamedAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAlignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAlignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAlignment(LLVMValueRef V)
     * }
     */
    public static FunctionDescriptor LLVMGetAlignment$descriptor() {
        return LLVMGetAlignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAlignment(LLVMValueRef V)
     * }
     */
    public static MethodHandle LLVMGetAlignment$handle() {
        return LLVMGetAlignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAlignment(LLVMValueRef V)
     * }
     */
    public static MemorySegment LLVMGetAlignment$address() {
        return LLVMGetAlignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetAlignment(LLVMValueRef V)
     * }
     */
    public static int LLVMGetAlignment(MemorySegment V) {
        var mh$ = LLVMGetAlignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAlignment", V);
            }
            return (int)mh$.invokeExact(V);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetAlignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetAlignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetAlignment(LLVMValueRef V, unsigned int Bytes)
     * }
     */
    public static FunctionDescriptor LLVMSetAlignment$descriptor() {
        return LLVMSetAlignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetAlignment(LLVMValueRef V, unsigned int Bytes)
     * }
     */
    public static MethodHandle LLVMSetAlignment$handle() {
        return LLVMSetAlignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetAlignment(LLVMValueRef V, unsigned int Bytes)
     * }
     */
    public static MemorySegment LLVMSetAlignment$address() {
        return LLVMSetAlignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetAlignment(LLVMValueRef V, unsigned int Bytes)
     * }
     */
    public static void LLVMSetAlignment(MemorySegment V, int Bytes) {
        var mh$ = LLVMSetAlignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetAlignment", V, Bytes);
            }
            mh$.invokeExact(V, Bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGlobalSetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGlobalSetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGlobalSetMetadata(LLVMValueRef Global, unsigned int Kind, LLVMMetadataRef MD)
     * }
     */
    public static FunctionDescriptor LLVMGlobalSetMetadata$descriptor() {
        return LLVMGlobalSetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGlobalSetMetadata(LLVMValueRef Global, unsigned int Kind, LLVMMetadataRef MD)
     * }
     */
    public static MethodHandle LLVMGlobalSetMetadata$handle() {
        return LLVMGlobalSetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGlobalSetMetadata(LLVMValueRef Global, unsigned int Kind, LLVMMetadataRef MD)
     * }
     */
    public static MemorySegment LLVMGlobalSetMetadata$address() {
        return LLVMGlobalSetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGlobalSetMetadata(LLVMValueRef Global, unsigned int Kind, LLVMMetadataRef MD)
     * }
     */
    public static void LLVMGlobalSetMetadata(MemorySegment Global, int Kind, MemorySegment MD) {
        var mh$ = LLVMGlobalSetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGlobalSetMetadata", Global, Kind, MD);
            }
            mh$.invokeExact(Global, Kind, MD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGlobalEraseMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGlobalEraseMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGlobalEraseMetadata(LLVMValueRef Global, unsigned int Kind)
     * }
     */
    public static FunctionDescriptor LLVMGlobalEraseMetadata$descriptor() {
        return LLVMGlobalEraseMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGlobalEraseMetadata(LLVMValueRef Global, unsigned int Kind)
     * }
     */
    public static MethodHandle LLVMGlobalEraseMetadata$handle() {
        return LLVMGlobalEraseMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGlobalEraseMetadata(LLVMValueRef Global, unsigned int Kind)
     * }
     */
    public static MemorySegment LLVMGlobalEraseMetadata$address() {
        return LLVMGlobalEraseMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGlobalEraseMetadata(LLVMValueRef Global, unsigned int Kind)
     * }
     */
    public static void LLVMGlobalEraseMetadata(MemorySegment Global, int Kind) {
        var mh$ = LLVMGlobalEraseMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGlobalEraseMetadata", Global, Kind);
            }
            mh$.invokeExact(Global, Kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGlobalClearMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGlobalClearMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGlobalClearMetadata(LLVMValueRef Global)
     * }
     */
    public static FunctionDescriptor LLVMGlobalClearMetadata$descriptor() {
        return LLVMGlobalClearMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGlobalClearMetadata(LLVMValueRef Global)
     * }
     */
    public static MethodHandle LLVMGlobalClearMetadata$handle() {
        return LLVMGlobalClearMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGlobalClearMetadata(LLVMValueRef Global)
     * }
     */
    public static MemorySegment LLVMGlobalClearMetadata$address() {
        return LLVMGlobalClearMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGlobalClearMetadata(LLVMValueRef Global)
     * }
     */
    public static void LLVMGlobalClearMetadata(MemorySegment Global) {
        var mh$ = LLVMGlobalClearMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGlobalClearMetadata", Global);
            }
            mh$.invokeExact(Global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGlobalCopyAllMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGlobalCopyAllMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMGlobalCopyAllMetadata(LLVMValueRef Value, size_t *NumEntries)
     * }
     */
    public static FunctionDescriptor LLVMGlobalCopyAllMetadata$descriptor() {
        return LLVMGlobalCopyAllMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMGlobalCopyAllMetadata(LLVMValueRef Value, size_t *NumEntries)
     * }
     */
    public static MethodHandle LLVMGlobalCopyAllMetadata$handle() {
        return LLVMGlobalCopyAllMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMGlobalCopyAllMetadata(LLVMValueRef Value, size_t *NumEntries)
     * }
     */
    public static MemorySegment LLVMGlobalCopyAllMetadata$address() {
        return LLVMGlobalCopyAllMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMGlobalCopyAllMetadata(LLVMValueRef Value, size_t *NumEntries)
     * }
     */
    public static MemorySegment LLVMGlobalCopyAllMetadata(MemorySegment Value, MemorySegment NumEntries) {
        var mh$ = LLVMGlobalCopyAllMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGlobalCopyAllMetadata", Value, NumEntries);
            }
            return (MemorySegment)mh$.invokeExact(Value, NumEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeValueMetadataEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeValueMetadataEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeValueMetadataEntries(LLVMValueMetadataEntry *Entries)
     * }
     */
    public static FunctionDescriptor LLVMDisposeValueMetadataEntries$descriptor() {
        return LLVMDisposeValueMetadataEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeValueMetadataEntries(LLVMValueMetadataEntry *Entries)
     * }
     */
    public static MethodHandle LLVMDisposeValueMetadataEntries$handle() {
        return LLVMDisposeValueMetadataEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeValueMetadataEntries(LLVMValueMetadataEntry *Entries)
     * }
     */
    public static MemorySegment LLVMDisposeValueMetadataEntries$address() {
        return LLVMDisposeValueMetadataEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeValueMetadataEntries(LLVMValueMetadataEntry *Entries)
     * }
     */
    public static void LLVMDisposeValueMetadataEntries(MemorySegment Entries) {
        var mh$ = LLVMDisposeValueMetadataEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeValueMetadataEntries", Entries);
            }
            mh$.invokeExact(Entries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMValueMetadataEntriesGetKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMValueMetadataEntriesGetKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMValueMetadataEntriesGetKind(LLVMValueMetadataEntry *Entries, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMValueMetadataEntriesGetKind$descriptor() {
        return LLVMValueMetadataEntriesGetKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMValueMetadataEntriesGetKind(LLVMValueMetadataEntry *Entries, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMValueMetadataEntriesGetKind$handle() {
        return LLVMValueMetadataEntriesGetKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMValueMetadataEntriesGetKind(LLVMValueMetadataEntry *Entries, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMValueMetadataEntriesGetKind$address() {
        return LLVMValueMetadataEntriesGetKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMValueMetadataEntriesGetKind(LLVMValueMetadataEntry *Entries, unsigned int Index)
     * }
     */
    public static int LLVMValueMetadataEntriesGetKind(MemorySegment Entries, int Index) {
        var mh$ = LLVMValueMetadataEntriesGetKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMValueMetadataEntriesGetKind", Entries, Index);
            }
            return (int)mh$.invokeExact(Entries, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMValueMetadataEntriesGetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMValueMetadataEntriesGetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueMetadataEntriesGetMetadata(LLVMValueMetadataEntry *Entries, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMValueMetadataEntriesGetMetadata$descriptor() {
        return LLVMValueMetadataEntriesGetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueMetadataEntriesGetMetadata(LLVMValueMetadataEntry *Entries, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMValueMetadataEntriesGetMetadata$handle() {
        return LLVMValueMetadataEntriesGetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueMetadataEntriesGetMetadata(LLVMValueMetadataEntry *Entries, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMValueMetadataEntriesGetMetadata$address() {
        return LLVMValueMetadataEntriesGetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueMetadataEntriesGetMetadata(LLVMValueMetadataEntry *Entries, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMValueMetadataEntriesGetMetadata(MemorySegment Entries, int Index) {
        var mh$ = LLVMValueMetadataEntriesGetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMValueMetadataEntriesGetMetadata", Entries, Index);
            }
            return (MemorySegment)mh$.invokeExact(Entries, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobal(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMAddGlobal$descriptor() {
        return LLVMAddGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobal(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMAddGlobal$handle() {
        return LLVMAddGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobal(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMAddGlobal$address() {
        return LLVMAddGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobal(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMAddGlobal(MemorySegment M, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMAddGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddGlobal", M, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(M, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddGlobalInAddressSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddGlobalInAddressSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name, unsigned int AddressSpace)
     * }
     */
    public static FunctionDescriptor LLVMAddGlobalInAddressSpace$descriptor() {
        return LLVMAddGlobalInAddressSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name, unsigned int AddressSpace)
     * }
     */
    public static MethodHandle LLVMAddGlobalInAddressSpace$handle() {
        return LLVMAddGlobalInAddressSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name, unsigned int AddressSpace)
     * }
     */
    public static MemorySegment LLVMAddGlobalInAddressSpace$address() {
        return LLVMAddGlobalInAddressSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMModuleRef M, LLVMTypeRef Ty, const char *Name, unsigned int AddressSpace)
     * }
     */
    public static MemorySegment LLVMAddGlobalInAddressSpace(MemorySegment M, MemorySegment Ty, MemorySegment Name, int AddressSpace) {
        var mh$ = LLVMAddGlobalInAddressSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddGlobalInAddressSpace", M, Ty, Name, AddressSpace);
            }
            return (MemorySegment)mh$.invokeExact(M, Ty, Name, AddressSpace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobal(LLVMModuleRef M, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedGlobal$descriptor() {
        return LLVMGetNamedGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobal(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MethodHandle LLVMGetNamedGlobal$handle() {
        return LLVMGetNamedGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobal(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobal$address() {
        return LLVMGetNamedGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobal(LLVMModuleRef M, const char *Name)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobal(MemorySegment M, MemorySegment Name) {
        var mh$ = LLVMGetNamedGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedGlobal", M, Name);
            }
            return (MemorySegment)mh$.invokeExact(M, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedGlobalWithLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedGlobalWithLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalWithLength(LLVMModuleRef M, const char *Name, size_t Length)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedGlobalWithLength$descriptor() {
        return LLVMGetNamedGlobalWithLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalWithLength(LLVMModuleRef M, const char *Name, size_t Length)
     * }
     */
    public static MethodHandle LLVMGetNamedGlobalWithLength$handle() {
        return LLVMGetNamedGlobalWithLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalWithLength(LLVMModuleRef M, const char *Name, size_t Length)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobalWithLength$address() {
        return LLVMGetNamedGlobalWithLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalWithLength(LLVMModuleRef M, const char *Name, size_t Length)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobalWithLength(MemorySegment M, MemorySegment Name, long Length) {
        var mh$ = LLVMGetNamedGlobalWithLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedGlobalWithLength", M, Name, Length);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobal(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstGlobal$descriptor() {
        return LLVMGetFirstGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobal(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetFirstGlobal$handle() {
        return LLVMGetFirstGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobal(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstGlobal$address() {
        return LLVMGetFirstGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobal(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstGlobal(MemorySegment M) {
        var mh$ = LLVMGetFirstGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstGlobal", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobal(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetLastGlobal$descriptor() {
        return LLVMGetLastGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobal(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetLastGlobal$handle() {
        return LLVMGetLastGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobal(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastGlobal$address() {
        return LLVMGetLastGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobal(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastGlobal(MemorySegment M) {
        var mh$ = LLVMGetLastGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastGlobal", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMGetNextGlobal$descriptor() {
        return LLVMGetNextGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMGetNextGlobal$handle() {
        return LLVMGetNextGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMGetNextGlobal$address() {
        return LLVMGetNextGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMGetNextGlobal(MemorySegment GlobalVar) {
        var mh$ = LLVMGetNextGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextGlobal", GlobalVar);
            }
            return (MemorySegment)mh$.invokeExact(GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousGlobal$descriptor() {
        return LLVMGetPreviousGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMGetPreviousGlobal$handle() {
        return LLVMGetPreviousGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMGetPreviousGlobal$address() {
        return LLVMGetPreviousGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMGetPreviousGlobal(MemorySegment GlobalVar) {
        var mh$ = LLVMGetPreviousGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousGlobal", GlobalVar);
            }
            return (MemorySegment)mh$.invokeExact(GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDeleteGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDeleteGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDeleteGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMDeleteGlobal$descriptor() {
        return LLVMDeleteGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDeleteGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMDeleteGlobal$handle() {
        return LLVMDeleteGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDeleteGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMDeleteGlobal$address() {
        return LLVMDeleteGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDeleteGlobal(LLVMValueRef GlobalVar)
     * }
     */
    public static void LLVMDeleteGlobal(MemorySegment GlobalVar) {
        var mh$ = LLVMDeleteGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDeleteGlobal", GlobalVar);
            }
            mh$.invokeExact(GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInitializer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInitializer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetInitializer(LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMGetInitializer$descriptor() {
        return LLVMGetInitializer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetInitializer(LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMGetInitializer$handle() {
        return LLVMGetInitializer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetInitializer(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMGetInitializer$address() {
        return LLVMGetInitializer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetInitializer(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMGetInitializer(MemorySegment GlobalVar) {
        var mh$ = LLVMGetInitializer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInitializer", GlobalVar);
            }
            return (MemorySegment)mh$.invokeExact(GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetInitializer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetInitializer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetInitializer(LLVMValueRef GlobalVar, LLVMValueRef ConstantVal)
     * }
     */
    public static FunctionDescriptor LLVMSetInitializer$descriptor() {
        return LLVMSetInitializer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetInitializer(LLVMValueRef GlobalVar, LLVMValueRef ConstantVal)
     * }
     */
    public static MethodHandle LLVMSetInitializer$handle() {
        return LLVMSetInitializer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetInitializer(LLVMValueRef GlobalVar, LLVMValueRef ConstantVal)
     * }
     */
    public static MemorySegment LLVMSetInitializer$address() {
        return LLVMSetInitializer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetInitializer(LLVMValueRef GlobalVar, LLVMValueRef ConstantVal)
     * }
     */
    public static void LLVMSetInitializer(MemorySegment GlobalVar, MemorySegment ConstantVal) {
        var mh$ = LLVMSetInitializer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetInitializer", GlobalVar, ConstantVal);
            }
            mh$.invokeExact(GlobalVar, ConstantVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsThreadLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsThreadLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsThreadLocal(LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMIsThreadLocal$descriptor() {
        return LLVMIsThreadLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsThreadLocal(LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMIsThreadLocal$handle() {
        return LLVMIsThreadLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsThreadLocal(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMIsThreadLocal$address() {
        return LLVMIsThreadLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsThreadLocal(LLVMValueRef GlobalVar)
     * }
     */
    public static int LLVMIsThreadLocal(MemorySegment GlobalVar) {
        var mh$ = LLVMIsThreadLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsThreadLocal", GlobalVar);
            }
            return (int)mh$.invokeExact(GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetThreadLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetThreadLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetThreadLocal(LLVMValueRef GlobalVar, LLVMBool IsThreadLocal)
     * }
     */
    public static FunctionDescriptor LLVMSetThreadLocal$descriptor() {
        return LLVMSetThreadLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetThreadLocal(LLVMValueRef GlobalVar, LLVMBool IsThreadLocal)
     * }
     */
    public static MethodHandle LLVMSetThreadLocal$handle() {
        return LLVMSetThreadLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetThreadLocal(LLVMValueRef GlobalVar, LLVMBool IsThreadLocal)
     * }
     */
    public static MemorySegment LLVMSetThreadLocal$address() {
        return LLVMSetThreadLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetThreadLocal(LLVMValueRef GlobalVar, LLVMBool IsThreadLocal)
     * }
     */
    public static void LLVMSetThreadLocal(MemorySegment GlobalVar, int IsThreadLocal) {
        var mh$ = LLVMSetThreadLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetThreadLocal", GlobalVar, IsThreadLocal);
            }
            mh$.invokeExact(GlobalVar, IsThreadLocal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsGlobalConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsGlobalConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsGlobalConstant(LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMIsGlobalConstant$descriptor() {
        return LLVMIsGlobalConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsGlobalConstant(LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMIsGlobalConstant$handle() {
        return LLVMIsGlobalConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsGlobalConstant(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMIsGlobalConstant$address() {
        return LLVMIsGlobalConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsGlobalConstant(LLVMValueRef GlobalVar)
     * }
     */
    public static int LLVMIsGlobalConstant(MemorySegment GlobalVar) {
        var mh$ = LLVMIsGlobalConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsGlobalConstant", GlobalVar);
            }
            return (int)mh$.invokeExact(GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetGlobalConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetGlobalConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetGlobalConstant(LLVMValueRef GlobalVar, LLVMBool IsConstant)
     * }
     */
    public static FunctionDescriptor LLVMSetGlobalConstant$descriptor() {
        return LLVMSetGlobalConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetGlobalConstant(LLVMValueRef GlobalVar, LLVMBool IsConstant)
     * }
     */
    public static MethodHandle LLVMSetGlobalConstant$handle() {
        return LLVMSetGlobalConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetGlobalConstant(LLVMValueRef GlobalVar, LLVMBool IsConstant)
     * }
     */
    public static MemorySegment LLVMSetGlobalConstant$address() {
        return LLVMSetGlobalConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetGlobalConstant(LLVMValueRef GlobalVar, LLVMBool IsConstant)
     * }
     */
    public static void LLVMSetGlobalConstant(MemorySegment GlobalVar, int IsConstant) {
        var mh$ = LLVMSetGlobalConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetGlobalConstant", GlobalVar, IsConstant);
            }
            mh$.invokeExact(GlobalVar, IsConstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetThreadLocalMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetThreadLocalMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMThreadLocalMode LLVMGetThreadLocalMode(LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMGetThreadLocalMode$descriptor() {
        return LLVMGetThreadLocalMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMThreadLocalMode LLVMGetThreadLocalMode(LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMGetThreadLocalMode$handle() {
        return LLVMGetThreadLocalMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMThreadLocalMode LLVMGetThreadLocalMode(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMGetThreadLocalMode$address() {
        return LLVMGetThreadLocalMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMThreadLocalMode LLVMGetThreadLocalMode(LLVMValueRef GlobalVar)
     * }
     */
    public static int LLVMGetThreadLocalMode(MemorySegment GlobalVar) {
        var mh$ = LLVMGetThreadLocalMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetThreadLocalMode", GlobalVar);
            }
            return (int)mh$.invokeExact(GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetThreadLocalMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetThreadLocalMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetThreadLocalMode(LLVMValueRef GlobalVar, LLVMThreadLocalMode Mode)
     * }
     */
    public static FunctionDescriptor LLVMSetThreadLocalMode$descriptor() {
        return LLVMSetThreadLocalMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetThreadLocalMode(LLVMValueRef GlobalVar, LLVMThreadLocalMode Mode)
     * }
     */
    public static MethodHandle LLVMSetThreadLocalMode$handle() {
        return LLVMSetThreadLocalMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetThreadLocalMode(LLVMValueRef GlobalVar, LLVMThreadLocalMode Mode)
     * }
     */
    public static MemorySegment LLVMSetThreadLocalMode$address() {
        return LLVMSetThreadLocalMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetThreadLocalMode(LLVMValueRef GlobalVar, LLVMThreadLocalMode Mode)
     * }
     */
    public static void LLVMSetThreadLocalMode(MemorySegment GlobalVar, int Mode) {
        var mh$ = LLVMSetThreadLocalMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetThreadLocalMode", GlobalVar, Mode);
            }
            mh$.invokeExact(GlobalVar, Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsExternallyInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsExternallyInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsExternallyInitialized(LLVMValueRef GlobalVar)
     * }
     */
    public static FunctionDescriptor LLVMIsExternallyInitialized$descriptor() {
        return LLVMIsExternallyInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsExternallyInitialized(LLVMValueRef GlobalVar)
     * }
     */
    public static MethodHandle LLVMIsExternallyInitialized$handle() {
        return LLVMIsExternallyInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsExternallyInitialized(LLVMValueRef GlobalVar)
     * }
     */
    public static MemorySegment LLVMIsExternallyInitialized$address() {
        return LLVMIsExternallyInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsExternallyInitialized(LLVMValueRef GlobalVar)
     * }
     */
    public static int LLVMIsExternallyInitialized(MemorySegment GlobalVar) {
        var mh$ = LLVMIsExternallyInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsExternallyInitialized", GlobalVar);
            }
            return (int)mh$.invokeExact(GlobalVar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetExternallyInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetExternallyInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetExternallyInitialized(LLVMValueRef GlobalVar, LLVMBool IsExtInit)
     * }
     */
    public static FunctionDescriptor LLVMSetExternallyInitialized$descriptor() {
        return LLVMSetExternallyInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetExternallyInitialized(LLVMValueRef GlobalVar, LLVMBool IsExtInit)
     * }
     */
    public static MethodHandle LLVMSetExternallyInitialized$handle() {
        return LLVMSetExternallyInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetExternallyInitialized(LLVMValueRef GlobalVar, LLVMBool IsExtInit)
     * }
     */
    public static MemorySegment LLVMSetExternallyInitialized$address() {
        return LLVMSetExternallyInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetExternallyInitialized(LLVMValueRef GlobalVar, LLVMBool IsExtInit)
     * }
     */
    public static void LLVMSetExternallyInitialized(MemorySegment GlobalVar, int IsExtInit) {
        var mh$ = LLVMSetExternallyInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetExternallyInitialized", GlobalVar, IsExtInit);
            }
            mh$.invokeExact(GlobalVar, IsExtInit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddAlias2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddAlias2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddAlias2(LLVMModuleRef M, LLVMTypeRef ValueTy, unsigned int AddrSpace, LLVMValueRef Aliasee, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMAddAlias2$descriptor() {
        return LLVMAddAlias2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddAlias2(LLVMModuleRef M, LLVMTypeRef ValueTy, unsigned int AddrSpace, LLVMValueRef Aliasee, const char *Name)
     * }
     */
    public static MethodHandle LLVMAddAlias2$handle() {
        return LLVMAddAlias2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddAlias2(LLVMModuleRef M, LLVMTypeRef ValueTy, unsigned int AddrSpace, LLVMValueRef Aliasee, const char *Name)
     * }
     */
    public static MemorySegment LLVMAddAlias2$address() {
        return LLVMAddAlias2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddAlias2(LLVMModuleRef M, LLVMTypeRef ValueTy, unsigned int AddrSpace, LLVMValueRef Aliasee, const char *Name)
     * }
     */
    public static MemorySegment LLVMAddAlias2(MemorySegment M, MemorySegment ValueTy, int AddrSpace, MemorySegment Aliasee, MemorySegment Name) {
        var mh$ = LLVMAddAlias2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddAlias2", M, ValueTy, AddrSpace, Aliasee, Name);
            }
            return (MemorySegment)mh$.invokeExact(M, ValueTy, AddrSpace, Aliasee, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedGlobalAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedGlobalAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalAlias(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedGlobalAlias$descriptor() {
        return LLVMGetNamedGlobalAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalAlias(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MethodHandle LLVMGetNamedGlobalAlias$handle() {
        return LLVMGetNamedGlobalAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalAlias(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobalAlias$address() {
        return LLVMGetNamedGlobalAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalAlias(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobalAlias(MemorySegment M, MemorySegment Name, long NameLen) {
        var mh$ = LLVMGetNamedGlobalAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedGlobalAlias", M, Name, NameLen);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, NameLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstGlobalAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstGlobalAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalAlias(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstGlobalAlias$descriptor() {
        return LLVMGetFirstGlobalAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalAlias(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetFirstGlobalAlias$handle() {
        return LLVMGetFirstGlobalAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalAlias(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstGlobalAlias$address() {
        return LLVMGetFirstGlobalAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalAlias(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstGlobalAlias(MemorySegment M) {
        var mh$ = LLVMGetFirstGlobalAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstGlobalAlias", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastGlobalAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastGlobalAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalAlias(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetLastGlobalAlias$descriptor() {
        return LLVMGetLastGlobalAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalAlias(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetLastGlobalAlias$handle() {
        return LLVMGetLastGlobalAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalAlias(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastGlobalAlias$address() {
        return LLVMGetLastGlobalAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalAlias(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastGlobalAlias(MemorySegment M) {
        var mh$ = LLVMGetLastGlobalAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastGlobalAlias", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextGlobalAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextGlobalAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalAlias(LLVMValueRef GA)
     * }
     */
    public static FunctionDescriptor LLVMGetNextGlobalAlias$descriptor() {
        return LLVMGetNextGlobalAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalAlias(LLVMValueRef GA)
     * }
     */
    public static MethodHandle LLVMGetNextGlobalAlias$handle() {
        return LLVMGetNextGlobalAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalAlias(LLVMValueRef GA)
     * }
     */
    public static MemorySegment LLVMGetNextGlobalAlias$address() {
        return LLVMGetNextGlobalAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalAlias(LLVMValueRef GA)
     * }
     */
    public static MemorySegment LLVMGetNextGlobalAlias(MemorySegment GA) {
        var mh$ = LLVMGetNextGlobalAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextGlobalAlias", GA);
            }
            return (MemorySegment)mh$.invokeExact(GA);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousGlobalAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousGlobalAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalAlias(LLVMValueRef GA)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousGlobalAlias$descriptor() {
        return LLVMGetPreviousGlobalAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalAlias(LLVMValueRef GA)
     * }
     */
    public static MethodHandle LLVMGetPreviousGlobalAlias$handle() {
        return LLVMGetPreviousGlobalAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalAlias(LLVMValueRef GA)
     * }
     */
    public static MemorySegment LLVMGetPreviousGlobalAlias$address() {
        return LLVMGetPreviousGlobalAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalAlias(LLVMValueRef GA)
     * }
     */
    public static MemorySegment LLVMGetPreviousGlobalAlias(MemorySegment GA) {
        var mh$ = LLVMGetPreviousGlobalAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousGlobalAlias", GA);
            }
            return (MemorySegment)mh$.invokeExact(GA);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAliasGetAliasee {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAliasGetAliasee");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAliasGetAliasee(LLVMValueRef Alias)
     * }
     */
    public static FunctionDescriptor LLVMAliasGetAliasee$descriptor() {
        return LLVMAliasGetAliasee.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAliasGetAliasee(LLVMValueRef Alias)
     * }
     */
    public static MethodHandle LLVMAliasGetAliasee$handle() {
        return LLVMAliasGetAliasee.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAliasGetAliasee(LLVMValueRef Alias)
     * }
     */
    public static MemorySegment LLVMAliasGetAliasee$address() {
        return LLVMAliasGetAliasee.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMAliasGetAliasee(LLVMValueRef Alias)
     * }
     */
    public static MemorySegment LLVMAliasGetAliasee(MemorySegment Alias) {
        var mh$ = LLVMAliasGetAliasee.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAliasGetAliasee", Alias);
            }
            return (MemorySegment)mh$.invokeExact(Alias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAliasSetAliasee {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAliasSetAliasee");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAliasSetAliasee(LLVMValueRef Alias, LLVMValueRef Aliasee)
     * }
     */
    public static FunctionDescriptor LLVMAliasSetAliasee$descriptor() {
        return LLVMAliasSetAliasee.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAliasSetAliasee(LLVMValueRef Alias, LLVMValueRef Aliasee)
     * }
     */
    public static MethodHandle LLVMAliasSetAliasee$handle() {
        return LLVMAliasSetAliasee.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAliasSetAliasee(LLVMValueRef Alias, LLVMValueRef Aliasee)
     * }
     */
    public static MemorySegment LLVMAliasSetAliasee$address() {
        return LLVMAliasSetAliasee.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAliasSetAliasee(LLVMValueRef Alias, LLVMValueRef Aliasee)
     * }
     */
    public static void LLVMAliasSetAliasee(MemorySegment Alias, MemorySegment Aliasee) {
        var mh$ = LLVMAliasSetAliasee.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAliasSetAliasee", Alias, Aliasee);
            }
            mh$.invokeExact(Alias, Aliasee);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDeleteFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDeleteFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDeleteFunction(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMDeleteFunction$descriptor() {
        return LLVMDeleteFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDeleteFunction(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMDeleteFunction$handle() {
        return LLVMDeleteFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDeleteFunction(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMDeleteFunction$address() {
        return LLVMDeleteFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDeleteFunction(LLVMValueRef Fn)
     * }
     */
    public static void LLVMDeleteFunction(MemorySegment Fn) {
        var mh$ = LLVMDeleteFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDeleteFunction", Fn);
            }
            mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMHasPersonalityFn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMHasPersonalityFn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPersonalityFn(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMHasPersonalityFn$descriptor() {
        return LLVMHasPersonalityFn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPersonalityFn(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMHasPersonalityFn$handle() {
        return LLVMHasPersonalityFn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPersonalityFn(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMHasPersonalityFn$address() {
        return LLVMHasPersonalityFn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMHasPersonalityFn(LLVMValueRef Fn)
     * }
     */
    public static int LLVMHasPersonalityFn(MemorySegment Fn) {
        var mh$ = LLVMHasPersonalityFn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMHasPersonalityFn", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPersonalityFn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPersonalityFn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPersonalityFn(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetPersonalityFn$descriptor() {
        return LLVMGetPersonalityFn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPersonalityFn(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetPersonalityFn$handle() {
        return LLVMGetPersonalityFn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPersonalityFn(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetPersonalityFn$address() {
        return LLVMGetPersonalityFn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPersonalityFn(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetPersonalityFn(MemorySegment Fn) {
        var mh$ = LLVMGetPersonalityFn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPersonalityFn", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetPersonalityFn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetPersonalityFn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetPersonalityFn(LLVMValueRef Fn, LLVMValueRef PersonalityFn)
     * }
     */
    public static FunctionDescriptor LLVMSetPersonalityFn$descriptor() {
        return LLVMSetPersonalityFn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetPersonalityFn(LLVMValueRef Fn, LLVMValueRef PersonalityFn)
     * }
     */
    public static MethodHandle LLVMSetPersonalityFn$handle() {
        return LLVMSetPersonalityFn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetPersonalityFn(LLVMValueRef Fn, LLVMValueRef PersonalityFn)
     * }
     */
    public static MemorySegment LLVMSetPersonalityFn$address() {
        return LLVMSetPersonalityFn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetPersonalityFn(LLVMValueRef Fn, LLVMValueRef PersonalityFn)
     * }
     */
    public static void LLVMSetPersonalityFn(MemorySegment Fn, MemorySegment PersonalityFn) {
        var mh$ = LLVMSetPersonalityFn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetPersonalityFn", Fn, PersonalityFn);
            }
            mh$.invokeExact(Fn, PersonalityFn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMLookupIntrinsicID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMLookupIntrinsicID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMLookupIntrinsicID(const char *Name, size_t NameLen)
     * }
     */
    public static FunctionDescriptor LLVMLookupIntrinsicID$descriptor() {
        return LLVMLookupIntrinsicID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMLookupIntrinsicID(const char *Name, size_t NameLen)
     * }
     */
    public static MethodHandle LLVMLookupIntrinsicID$handle() {
        return LLVMLookupIntrinsicID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMLookupIntrinsicID(const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMLookupIntrinsicID$address() {
        return LLVMLookupIntrinsicID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMLookupIntrinsicID(const char *Name, size_t NameLen)
     * }
     */
    public static int LLVMLookupIntrinsicID(MemorySegment Name, long NameLen) {
        var mh$ = LLVMLookupIntrinsicID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMLookupIntrinsicID", Name, NameLen);
            }
            return (int)mh$.invokeExact(Name, NameLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIntrinsicID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIntrinsicID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetIntrinsicID(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetIntrinsicID$descriptor() {
        return LLVMGetIntrinsicID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetIntrinsicID(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetIntrinsicID$handle() {
        return LLVMGetIntrinsicID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetIntrinsicID(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetIntrinsicID$address() {
        return LLVMGetIntrinsicID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetIntrinsicID(LLVMValueRef Fn)
     * }
     */
    public static int LLVMGetIntrinsicID(MemorySegment Fn) {
        var mh$ = LLVMGetIntrinsicID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIntrinsicID", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIntrinsicDeclaration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIntrinsicDeclaration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIntrinsicDeclaration(LLVMModuleRef Mod, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount)
     * }
     */
    public static FunctionDescriptor LLVMGetIntrinsicDeclaration$descriptor() {
        return LLVMGetIntrinsicDeclaration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIntrinsicDeclaration(LLVMModuleRef Mod, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount)
     * }
     */
    public static MethodHandle LLVMGetIntrinsicDeclaration$handle() {
        return LLVMGetIntrinsicDeclaration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIntrinsicDeclaration(LLVMModuleRef Mod, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount)
     * }
     */
    public static MemorySegment LLVMGetIntrinsicDeclaration$address() {
        return LLVMGetIntrinsicDeclaration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIntrinsicDeclaration(LLVMModuleRef Mod, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount)
     * }
     */
    public static MemorySegment LLVMGetIntrinsicDeclaration(MemorySegment Mod, int ID, MemorySegment ParamTypes, long ParamCount) {
        var mh$ = LLVMGetIntrinsicDeclaration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIntrinsicDeclaration", Mod, ID, ParamTypes, ParamCount);
            }
            return (MemorySegment)mh$.invokeExact(Mod, ID, ParamTypes, ParamCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntrinsicGetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntrinsicGetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntrinsicGetType(LLVMContextRef Ctx, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount)
     * }
     */
    public static FunctionDescriptor LLVMIntrinsicGetType$descriptor() {
        return LLVMIntrinsicGetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntrinsicGetType(LLVMContextRef Ctx, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount)
     * }
     */
    public static MethodHandle LLVMIntrinsicGetType$handle() {
        return LLVMIntrinsicGetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntrinsicGetType(LLVMContextRef Ctx, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount)
     * }
     */
    public static MemorySegment LLVMIntrinsicGetType$address() {
        return LLVMIntrinsicGetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMIntrinsicGetType(LLVMContextRef Ctx, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount)
     * }
     */
    public static MemorySegment LLVMIntrinsicGetType(MemorySegment Ctx, int ID, MemorySegment ParamTypes, long ParamCount) {
        var mh$ = LLVMIntrinsicGetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntrinsicGetType", Ctx, ID, ParamTypes, ParamCount);
            }
            return (MemorySegment)mh$.invokeExact(Ctx, ID, ParamTypes, ParamCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntrinsicGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntrinsicGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMIntrinsicGetName(unsigned int ID, size_t *NameLength)
     * }
     */
    public static FunctionDescriptor LLVMIntrinsicGetName$descriptor() {
        return LLVMIntrinsicGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMIntrinsicGetName(unsigned int ID, size_t *NameLength)
     * }
     */
    public static MethodHandle LLVMIntrinsicGetName$handle() {
        return LLVMIntrinsicGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMIntrinsicGetName(unsigned int ID, size_t *NameLength)
     * }
     */
    public static MemorySegment LLVMIntrinsicGetName$address() {
        return LLVMIntrinsicGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMIntrinsicGetName(unsigned int ID, size_t *NameLength)
     * }
     */
    public static MemorySegment LLVMIntrinsicGetName(int ID, MemorySegment NameLength) {
        var mh$ = LLVMIntrinsicGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntrinsicGetName", ID, NameLength);
            }
            return (MemorySegment)mh$.invokeExact(ID, NameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntrinsicCopyOverloadedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntrinsicCopyOverloadedName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMIntrinsicCopyOverloadedName(unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount, size_t *NameLength)
     * }
     */
    public static FunctionDescriptor LLVMIntrinsicCopyOverloadedName$descriptor() {
        return LLVMIntrinsicCopyOverloadedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMIntrinsicCopyOverloadedName(unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount, size_t *NameLength)
     * }
     */
    public static MethodHandle LLVMIntrinsicCopyOverloadedName$handle() {
        return LLVMIntrinsicCopyOverloadedName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMIntrinsicCopyOverloadedName(unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount, size_t *NameLength)
     * }
     */
    public static MemorySegment LLVMIntrinsicCopyOverloadedName$address() {
        return LLVMIntrinsicCopyOverloadedName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMIntrinsicCopyOverloadedName(unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount, size_t *NameLength)
     * }
     */
    public static MemorySegment LLVMIntrinsicCopyOverloadedName(int ID, MemorySegment ParamTypes, long ParamCount, MemorySegment NameLength) {
        var mh$ = LLVMIntrinsicCopyOverloadedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntrinsicCopyOverloadedName", ID, ParamTypes, ParamCount, NameLength);
            }
            return (MemorySegment)mh$.invokeExact(ID, ParamTypes, ParamCount, NameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntrinsicCopyOverloadedName2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntrinsicCopyOverloadedName2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *LLVMIntrinsicCopyOverloadedName2(LLVMModuleRef Mod, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount, size_t *NameLength)
     * }
     */
    public static FunctionDescriptor LLVMIntrinsicCopyOverloadedName2$descriptor() {
        return LLVMIntrinsicCopyOverloadedName2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *LLVMIntrinsicCopyOverloadedName2(LLVMModuleRef Mod, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount, size_t *NameLength)
     * }
     */
    public static MethodHandle LLVMIntrinsicCopyOverloadedName2$handle() {
        return LLVMIntrinsicCopyOverloadedName2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *LLVMIntrinsicCopyOverloadedName2(LLVMModuleRef Mod, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount, size_t *NameLength)
     * }
     */
    public static MemorySegment LLVMIntrinsicCopyOverloadedName2$address() {
        return LLVMIntrinsicCopyOverloadedName2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *LLVMIntrinsicCopyOverloadedName2(LLVMModuleRef Mod, unsigned int ID, LLVMTypeRef *ParamTypes, size_t ParamCount, size_t *NameLength)
     * }
     */
    public static MemorySegment LLVMIntrinsicCopyOverloadedName2(MemorySegment Mod, int ID, MemorySegment ParamTypes, long ParamCount, MemorySegment NameLength) {
        var mh$ = LLVMIntrinsicCopyOverloadedName2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntrinsicCopyOverloadedName2", Mod, ID, ParamTypes, ParamCount, NameLength);
            }
            return (MemorySegment)mh$.invokeExact(Mod, ID, ParamTypes, ParamCount, NameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIntrinsicIsOverloaded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIntrinsicIsOverloaded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIntrinsicIsOverloaded(unsigned int ID)
     * }
     */
    public static FunctionDescriptor LLVMIntrinsicIsOverloaded$descriptor() {
        return LLVMIntrinsicIsOverloaded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIntrinsicIsOverloaded(unsigned int ID)
     * }
     */
    public static MethodHandle LLVMIntrinsicIsOverloaded$handle() {
        return LLVMIntrinsicIsOverloaded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIntrinsicIsOverloaded(unsigned int ID)
     * }
     */
    public static MemorySegment LLVMIntrinsicIsOverloaded$address() {
        return LLVMIntrinsicIsOverloaded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIntrinsicIsOverloaded(unsigned int ID)
     * }
     */
    public static int LLVMIntrinsicIsOverloaded(int ID) {
        var mh$ = LLVMIntrinsicIsOverloaded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIntrinsicIsOverloaded", ID);
            }
            return (int)mh$.invokeExact(ID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFunctionCallConv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFunctionCallConv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetFunctionCallConv(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetFunctionCallConv$descriptor() {
        return LLVMGetFunctionCallConv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetFunctionCallConv(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetFunctionCallConv$handle() {
        return LLVMGetFunctionCallConv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetFunctionCallConv(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFunctionCallConv$address() {
        return LLVMGetFunctionCallConv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetFunctionCallConv(LLVMValueRef Fn)
     * }
     */
    public static int LLVMGetFunctionCallConv(MemorySegment Fn) {
        var mh$ = LLVMGetFunctionCallConv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFunctionCallConv", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetFunctionCallConv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetFunctionCallConv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetFunctionCallConv(LLVMValueRef Fn, unsigned int CC)
     * }
     */
    public static FunctionDescriptor LLVMSetFunctionCallConv$descriptor() {
        return LLVMSetFunctionCallConv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetFunctionCallConv(LLVMValueRef Fn, unsigned int CC)
     * }
     */
    public static MethodHandle LLVMSetFunctionCallConv$handle() {
        return LLVMSetFunctionCallConv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetFunctionCallConv(LLVMValueRef Fn, unsigned int CC)
     * }
     */
    public static MemorySegment LLVMSetFunctionCallConv$address() {
        return LLVMSetFunctionCallConv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetFunctionCallConv(LLVMValueRef Fn, unsigned int CC)
     * }
     */
    public static void LLVMSetFunctionCallConv(MemorySegment Fn, int CC) {
        var mh$ = LLVMSetFunctionCallConv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetFunctionCallConv", Fn, CC);
            }
            mh$.invokeExact(Fn, CC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetGC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetGC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetGC(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetGC$descriptor() {
        return LLVMGetGC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetGC(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetGC$handle() {
        return LLVMGetGC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetGC(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetGC$address() {
        return LLVMGetGC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetGC(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetGC(MemorySegment Fn) {
        var mh$ = LLVMGetGC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetGC", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetGC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetGC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetGC(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMSetGC$descriptor() {
        return LLVMSetGC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetGC(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MethodHandle LLVMSetGC$handle() {
        return LLVMSetGC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetGC(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMSetGC$address() {
        return LLVMSetGC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetGC(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static void LLVMSetGC(MemorySegment Fn, MemorySegment Name) {
        var mh$ = LLVMSetGC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetGC", Fn, Name);
            }
            mh$.invokeExact(Fn, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPrefixData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPrefixData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPrefixData(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetPrefixData$descriptor() {
        return LLVMGetPrefixData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPrefixData(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetPrefixData$handle() {
        return LLVMGetPrefixData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPrefixData(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetPrefixData$address() {
        return LLVMGetPrefixData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPrefixData(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetPrefixData(MemorySegment Fn) {
        var mh$ = LLVMGetPrefixData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPrefixData", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMHasPrefixData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMHasPrefixData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPrefixData(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMHasPrefixData$descriptor() {
        return LLVMHasPrefixData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPrefixData(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMHasPrefixData$handle() {
        return LLVMHasPrefixData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPrefixData(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMHasPrefixData$address() {
        return LLVMHasPrefixData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMHasPrefixData(LLVMValueRef Fn)
     * }
     */
    public static int LLVMHasPrefixData(MemorySegment Fn) {
        var mh$ = LLVMHasPrefixData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMHasPrefixData", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetPrefixData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetPrefixData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetPrefixData(LLVMValueRef Fn, LLVMValueRef prefixData)
     * }
     */
    public static FunctionDescriptor LLVMSetPrefixData$descriptor() {
        return LLVMSetPrefixData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetPrefixData(LLVMValueRef Fn, LLVMValueRef prefixData)
     * }
     */
    public static MethodHandle LLVMSetPrefixData$handle() {
        return LLVMSetPrefixData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetPrefixData(LLVMValueRef Fn, LLVMValueRef prefixData)
     * }
     */
    public static MemorySegment LLVMSetPrefixData$address() {
        return LLVMSetPrefixData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetPrefixData(LLVMValueRef Fn, LLVMValueRef prefixData)
     * }
     */
    public static void LLVMSetPrefixData(MemorySegment Fn, MemorySegment prefixData) {
        var mh$ = LLVMSetPrefixData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetPrefixData", Fn, prefixData);
            }
            mh$.invokeExact(Fn, prefixData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPrologueData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPrologueData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPrologueData(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetPrologueData$descriptor() {
        return LLVMGetPrologueData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPrologueData(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetPrologueData$handle() {
        return LLVMGetPrologueData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPrologueData(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetPrologueData$address() {
        return LLVMGetPrologueData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPrologueData(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetPrologueData(MemorySegment Fn) {
        var mh$ = LLVMGetPrologueData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPrologueData", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMHasPrologueData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMHasPrologueData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPrologueData(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMHasPrologueData$descriptor() {
        return LLVMHasPrologueData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPrologueData(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMHasPrologueData$handle() {
        return LLVMHasPrologueData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMHasPrologueData(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMHasPrologueData$address() {
        return LLVMHasPrologueData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMHasPrologueData(LLVMValueRef Fn)
     * }
     */
    public static int LLVMHasPrologueData(MemorySegment Fn) {
        var mh$ = LLVMHasPrologueData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMHasPrologueData", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetPrologueData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetPrologueData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetPrologueData(LLVMValueRef Fn, LLVMValueRef prologueData)
     * }
     */
    public static FunctionDescriptor LLVMSetPrologueData$descriptor() {
        return LLVMSetPrologueData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetPrologueData(LLVMValueRef Fn, LLVMValueRef prologueData)
     * }
     */
    public static MethodHandle LLVMSetPrologueData$handle() {
        return LLVMSetPrologueData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetPrologueData(LLVMValueRef Fn, LLVMValueRef prologueData)
     * }
     */
    public static MemorySegment LLVMSetPrologueData$address() {
        return LLVMSetPrologueData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetPrologueData(LLVMValueRef Fn, LLVMValueRef prologueData)
     * }
     */
    public static void LLVMSetPrologueData(MemorySegment Fn, MemorySegment prologueData) {
        var mh$ = LLVMSetPrologueData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetPrologueData", Fn, prologueData);
            }
            mh$.invokeExact(Fn, prologueData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMAddAttributeAtIndex$descriptor() {
        return LLVMAddAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMAddAttributeAtIndex$handle() {
        return LLVMAddAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMAddAttributeAtIndex$address() {
        return LLVMAddAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static void LLVMAddAttributeAtIndex(MemorySegment F, int Idx, MemorySegment A) {
        var mh$ = LLVMAddAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddAttributeAtIndex", F, Idx, A);
            }
            mh$.invokeExact(F, Idx, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAttributeCountAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAttributeCountAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAttributeCountAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetAttributeCountAtIndex$descriptor() {
        return LLVMGetAttributeCountAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAttributeCountAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx)
     * }
     */
    public static MethodHandle LLVMGetAttributeCountAtIndex$handle() {
        return LLVMGetAttributeCountAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAttributeCountAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx)
     * }
     */
    public static MemorySegment LLVMGetAttributeCountAtIndex$address() {
        return LLVMGetAttributeCountAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetAttributeCountAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx)
     * }
     */
    public static int LLVMGetAttributeCountAtIndex(MemorySegment F, int Idx) {
        var mh$ = LLVMGetAttributeCountAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAttributeCountAtIndex", F, Idx);
            }
            return (int)mh$.invokeExact(F, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAttributesAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAttributesAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetAttributesAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static FunctionDescriptor LLVMGetAttributesAtIndex$descriptor() {
        return LLVMGetAttributesAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetAttributesAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static MethodHandle LLVMGetAttributesAtIndex$handle() {
        return LLVMGetAttributesAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetAttributesAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static MemorySegment LLVMGetAttributesAtIndex$address() {
        return LLVMGetAttributesAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetAttributesAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static void LLVMGetAttributesAtIndex(MemorySegment F, int Idx, MemorySegment Attrs) {
        var mh$ = LLVMGetAttributesAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAttributesAtIndex", F, Idx, Attrs);
            }
            mh$.invokeExact(F, Idx, Attrs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetEnumAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetEnumAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMGetEnumAttributeAtIndex$descriptor() {
        return LLVMGetEnumAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMGetEnumAttributeAtIndex$handle() {
        return LLVMGetEnumAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetEnumAttributeAtIndex$address() {
        return LLVMGetEnumAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetEnumAttributeAtIndex(MemorySegment F, int Idx, int KindID) {
        var mh$ = LLVMGetEnumAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetEnumAttributeAtIndex", F, Idx, KindID);
            }
            return (MemorySegment)mh$.invokeExact(F, Idx, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetStringAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetStringAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static FunctionDescriptor LLVMGetStringAttributeAtIndex$descriptor() {
        return LLVMGetStringAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MethodHandle LLVMGetStringAttributeAtIndex$handle() {
        return LLVMGetStringAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMGetStringAttributeAtIndex$address() {
        return LLVMGetStringAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMGetStringAttributeAtIndex(MemorySegment F, int Idx, MemorySegment K, int KLen) {
        var mh$ = LLVMGetStringAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetStringAttributeAtIndex", F, Idx, K, KLen);
            }
            return (MemorySegment)mh$.invokeExact(F, Idx, K, KLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveEnumAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveEnumAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMRemoveEnumAttributeAtIndex$descriptor() {
        return LLVMRemoveEnumAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMRemoveEnumAttributeAtIndex$handle() {
        return LLVMRemoveEnumAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMRemoveEnumAttributeAtIndex$address() {
        return LLVMRemoveEnumAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveEnumAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static void LLVMRemoveEnumAttributeAtIndex(MemorySegment F, int Idx, int KindID) {
        var mh$ = LLVMRemoveEnumAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveEnumAttributeAtIndex", F, Idx, KindID);
            }
            mh$.invokeExact(F, Idx, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveStringAttributeAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveStringAttributeAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static FunctionDescriptor LLVMRemoveStringAttributeAtIndex$descriptor() {
        return LLVMRemoveStringAttributeAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MethodHandle LLVMRemoveStringAttributeAtIndex$handle() {
        return LLVMRemoveStringAttributeAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMRemoveStringAttributeAtIndex$address() {
        return LLVMRemoveStringAttributeAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveStringAttributeAtIndex(LLVMValueRef F, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static void LLVMRemoveStringAttributeAtIndex(MemorySegment F, int Idx, MemorySegment K, int KLen) {
        var mh$ = LLVMRemoveStringAttributeAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveStringAttributeAtIndex", F, Idx, K, KLen);
            }
            mh$.invokeExact(F, Idx, K, KLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddTargetDependentFunctionAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddTargetDependentFunctionAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A, const char *V)
     * }
     */
    public static FunctionDescriptor LLVMAddTargetDependentFunctionAttr$descriptor() {
        return LLVMAddTargetDependentFunctionAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A, const char *V)
     * }
     */
    public static MethodHandle LLVMAddTargetDependentFunctionAttr$handle() {
        return LLVMAddTargetDependentFunctionAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A, const char *V)
     * }
     */
    public static MemorySegment LLVMAddTargetDependentFunctionAttr$address() {
        return LLVMAddTargetDependentFunctionAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddTargetDependentFunctionAttr(LLVMValueRef Fn, const char *A, const char *V)
     * }
     */
    public static void LLVMAddTargetDependentFunctionAttr(MemorySegment Fn, MemorySegment A, MemorySegment V) {
        var mh$ = LLVMAddTargetDependentFunctionAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddTargetDependentFunctionAttr", Fn, A, V);
            }
            mh$.invokeExact(Fn, A, V);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCountParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCountParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParams(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMCountParams$descriptor() {
        return LLVMCountParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParams(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMCountParams$handle() {
        return LLVMCountParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCountParams(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMCountParams$address() {
        return LLVMCountParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCountParams(LLVMValueRef Fn)
     * }
     */
    public static int LLVMCountParams(MemorySegment Fn) {
        var mh$ = LLVMCountParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCountParams", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params)
     * }
     */
    public static FunctionDescriptor LLVMGetParams$descriptor() {
        return LLVMGetParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params)
     * }
     */
    public static MethodHandle LLVMGetParams$handle() {
        return LLVMGetParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params)
     * }
     */
    public static MemorySegment LLVMGetParams$address() {
        return LLVMGetParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetParams(LLVMValueRef Fn, LLVMValueRef *Params)
     * }
     */
    public static void LLVMGetParams(MemorySegment Fn, MemorySegment Params) {
        var mh$ = LLVMGetParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParams", Fn, Params);
            }
            mh$.invokeExact(Fn, Params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetParam$descriptor() {
        return LLVMGetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetParam$handle() {
        return LLVMGetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetParam$address() {
        return LLVMGetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParam(LLVMValueRef Fn, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetParam(MemorySegment Fn, int Index) {
        var mh$ = LLVMGetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParam", Fn, Index);
            }
            return (MemorySegment)mh$.invokeExact(Fn, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParamParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParamParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetParamParent$descriptor() {
        return LLVMGetParamParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetParamParent$handle() {
        return LLVMGetParamParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetParamParent$address() {
        return LLVMGetParamParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParamParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetParamParent(MemorySegment Inst) {
        var mh$ = LLVMGetParamParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParamParent", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstParam$descriptor() {
        return LLVMGetFirstParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetFirstParam$handle() {
        return LLVMGetFirstParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFirstParam$address() {
        return LLVMGetFirstParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstParam(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFirstParam(MemorySegment Fn) {
        var mh$ = LLVMGetFirstParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstParam", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetLastParam$descriptor() {
        return LLVMGetLastParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetLastParam$handle() {
        return LLVMGetLastParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetLastParam$address() {
        return LLVMGetLastParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastParam(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetLastParam(MemorySegment Fn) {
        var mh$ = LLVMGetLastParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastParam", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg)
     * }
     */
    public static FunctionDescriptor LLVMGetNextParam$descriptor() {
        return LLVMGetNextParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg)
     * }
     */
    public static MethodHandle LLVMGetNextParam$handle() {
        return LLVMGetNextParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg)
     * }
     */
    public static MemorySegment LLVMGetNextParam$address() {
        return LLVMGetNextParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextParam(LLVMValueRef Arg)
     * }
     */
    public static MemorySegment LLVMGetNextParam(MemorySegment Arg) {
        var mh$ = LLVMGetNextParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextParam", Arg);
            }
            return (MemorySegment)mh$.invokeExact(Arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousParam$descriptor() {
        return LLVMGetPreviousParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg)
     * }
     */
    public static MethodHandle LLVMGetPreviousParam$handle() {
        return LLVMGetPreviousParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg)
     * }
     */
    public static MemorySegment LLVMGetPreviousParam$address() {
        return LLVMGetPreviousParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousParam(LLVMValueRef Arg)
     * }
     */
    public static MemorySegment LLVMGetPreviousParam(MemorySegment Arg) {
        var mh$ = LLVMGetPreviousParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousParam", Arg);
            }
            return (MemorySegment)mh$.invokeExact(Arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetParamAlignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetParamAlignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned int Align)
     * }
     */
    public static FunctionDescriptor LLVMSetParamAlignment$descriptor() {
        return LLVMSetParamAlignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned int Align)
     * }
     */
    public static MethodHandle LLVMSetParamAlignment$handle() {
        return LLVMSetParamAlignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned int Align)
     * }
     */
    public static MemorySegment LLVMSetParamAlignment$address() {
        return LLVMSetParamAlignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetParamAlignment(LLVMValueRef Arg, unsigned int Align)
     * }
     */
    public static void LLVMSetParamAlignment(MemorySegment Arg, int Align) {
        var mh$ = LLVMSetParamAlignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetParamAlignment", Arg, Align);
            }
            mh$.invokeExact(Arg, Align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty, unsigned int AddrSpace, LLVMValueRef Resolver)
     * }
     */
    public static FunctionDescriptor LLVMAddGlobalIFunc$descriptor() {
        return LLVMAddGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty, unsigned int AddrSpace, LLVMValueRef Resolver)
     * }
     */
    public static MethodHandle LLVMAddGlobalIFunc$handle() {
        return LLVMAddGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty, unsigned int AddrSpace, LLVMValueRef Resolver)
     * }
     */
    public static MemorySegment LLVMAddGlobalIFunc$address() {
        return LLVMAddGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMAddGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty, unsigned int AddrSpace, LLVMValueRef Resolver)
     * }
     */
    public static MemorySegment LLVMAddGlobalIFunc(MemorySegment M, MemorySegment Name, long NameLen, MemorySegment Ty, int AddrSpace, MemorySegment Resolver) {
        var mh$ = LLVMAddGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddGlobalIFunc", M, Name, NameLen, Ty, AddrSpace, Resolver);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, NameLen, Ty, AddrSpace, Resolver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNamedGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNamedGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static FunctionDescriptor LLVMGetNamedGlobalIFunc$descriptor() {
        return LLVMGetNamedGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MethodHandle LLVMGetNamedGlobalIFunc$handle() {
        return LLVMGetNamedGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobalIFunc$address() {
        return LLVMGetNamedGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNamedGlobalIFunc(LLVMModuleRef M, const char *Name, size_t NameLen)
     * }
     */
    public static MemorySegment LLVMGetNamedGlobalIFunc(MemorySegment M, MemorySegment Name, long NameLen) {
        var mh$ = LLVMGetNamedGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNamedGlobalIFunc", M, Name, NameLen);
            }
            return (MemorySegment)mh$.invokeExact(M, Name, NameLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstGlobalIFunc$descriptor() {
        return LLVMGetFirstGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetFirstGlobalIFunc$handle() {
        return LLVMGetFirstGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstGlobalIFunc$address() {
        return LLVMGetFirstGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetFirstGlobalIFunc(MemorySegment M) {
        var mh$ = LLVMGetFirstGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstGlobalIFunc", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMGetLastGlobalIFunc$descriptor() {
        return LLVMGetLastGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMGetLastGlobalIFunc$handle() {
        return LLVMGetLastGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastGlobalIFunc$address() {
        return LLVMGetLastGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastGlobalIFunc(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMGetLastGlobalIFunc(MemorySegment M) {
        var mh$ = LLVMGetLastGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastGlobalIFunc", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMGetNextGlobalIFunc$descriptor() {
        return LLVMGetNextGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMGetNextGlobalIFunc$handle() {
        return LLVMGetNextGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetNextGlobalIFunc$address() {
        return LLVMGetNextGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetNextGlobalIFunc(MemorySegment IFunc) {
        var mh$ = LLVMGetNextGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextGlobalIFunc", IFunc);
            }
            return (MemorySegment)mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousGlobalIFunc$descriptor() {
        return LLVMGetPreviousGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMGetPreviousGlobalIFunc$handle() {
        return LLVMGetPreviousGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetPreviousGlobalIFunc$address() {
        return LLVMGetPreviousGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetPreviousGlobalIFunc(MemorySegment IFunc) {
        var mh$ = LLVMGetPreviousGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousGlobalIFunc", IFunc);
            }
            return (MemorySegment)mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetGlobalIFuncResolver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetGlobalIFuncResolver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetGlobalIFuncResolver(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMGetGlobalIFuncResolver$descriptor() {
        return LLVMGetGlobalIFuncResolver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetGlobalIFuncResolver(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMGetGlobalIFuncResolver$handle() {
        return LLVMGetGlobalIFuncResolver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetGlobalIFuncResolver(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetGlobalIFuncResolver$address() {
        return LLVMGetGlobalIFuncResolver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetGlobalIFuncResolver(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMGetGlobalIFuncResolver(MemorySegment IFunc) {
        var mh$ = LLVMGetGlobalIFuncResolver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetGlobalIFuncResolver", IFunc);
            }
            return (MemorySegment)mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetGlobalIFuncResolver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetGlobalIFuncResolver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetGlobalIFuncResolver(LLVMValueRef IFunc, LLVMValueRef Resolver)
     * }
     */
    public static FunctionDescriptor LLVMSetGlobalIFuncResolver$descriptor() {
        return LLVMSetGlobalIFuncResolver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetGlobalIFuncResolver(LLVMValueRef IFunc, LLVMValueRef Resolver)
     * }
     */
    public static MethodHandle LLVMSetGlobalIFuncResolver$handle() {
        return LLVMSetGlobalIFuncResolver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetGlobalIFuncResolver(LLVMValueRef IFunc, LLVMValueRef Resolver)
     * }
     */
    public static MemorySegment LLVMSetGlobalIFuncResolver$address() {
        return LLVMSetGlobalIFuncResolver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetGlobalIFuncResolver(LLVMValueRef IFunc, LLVMValueRef Resolver)
     * }
     */
    public static void LLVMSetGlobalIFuncResolver(MemorySegment IFunc, MemorySegment Resolver) {
        var mh$ = LLVMSetGlobalIFuncResolver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetGlobalIFuncResolver", IFunc, Resolver);
            }
            mh$.invokeExact(IFunc, Resolver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMEraseGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMEraseGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMEraseGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMEraseGlobalIFunc$descriptor() {
        return LLVMEraseGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMEraseGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMEraseGlobalIFunc$handle() {
        return LLVMEraseGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMEraseGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMEraseGlobalIFunc$address() {
        return LLVMEraseGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMEraseGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static void LLVMEraseGlobalIFunc(MemorySegment IFunc) {
        var mh$ = LLVMEraseGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMEraseGlobalIFunc", IFunc);
            }
            mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveGlobalIFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveGlobalIFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static FunctionDescriptor LLVMRemoveGlobalIFunc$descriptor() {
        return LLVMRemoveGlobalIFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MethodHandle LLVMRemoveGlobalIFunc$handle() {
        return LLVMRemoveGlobalIFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static MemorySegment LLVMRemoveGlobalIFunc$address() {
        return LLVMRemoveGlobalIFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveGlobalIFunc(LLVMValueRef IFunc)
     * }
     */
    public static void LLVMRemoveGlobalIFunc(MemorySegment IFunc) {
        var mh$ = LLVMRemoveGlobalIFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveGlobalIFunc", IFunc);
            }
            mh$.invokeExact(IFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDStringInContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDStringInContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDStringInContext2(LLVMContextRef C, const char *Str, size_t SLen)
     * }
     */
    public static FunctionDescriptor LLVMMDStringInContext2$descriptor() {
        return LLVMMDStringInContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDStringInContext2(LLVMContextRef C, const char *Str, size_t SLen)
     * }
     */
    public static MethodHandle LLVMMDStringInContext2$handle() {
        return LLVMMDStringInContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDStringInContext2(LLVMContextRef C, const char *Str, size_t SLen)
     * }
     */
    public static MemorySegment LLVMMDStringInContext2$address() {
        return LLVMMDStringInContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDStringInContext2(LLVMContextRef C, const char *Str, size_t SLen)
     * }
     */
    public static MemorySegment LLVMMDStringInContext2(MemorySegment C, MemorySegment Str, long SLen) {
        var mh$ = LLVMMDStringInContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDStringInContext2", C, Str, SLen);
            }
            return (MemorySegment)mh$.invokeExact(C, Str, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDNodeInContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDNodeInContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDNodeInContext2(LLVMContextRef C, LLVMMetadataRef *MDs, size_t Count)
     * }
     */
    public static FunctionDescriptor LLVMMDNodeInContext2$descriptor() {
        return LLVMMDNodeInContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDNodeInContext2(LLVMContextRef C, LLVMMetadataRef *MDs, size_t Count)
     * }
     */
    public static MethodHandle LLVMMDNodeInContext2$handle() {
        return LLVMMDNodeInContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDNodeInContext2(LLVMContextRef C, LLVMMetadataRef *MDs, size_t Count)
     * }
     */
    public static MemorySegment LLVMMDNodeInContext2$address() {
        return LLVMMDNodeInContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMMDNodeInContext2(LLVMContextRef C, LLVMMetadataRef *MDs, size_t Count)
     * }
     */
    public static MemorySegment LLVMMDNodeInContext2(MemorySegment C, MemorySegment MDs, long Count) {
        var mh$ = LLVMMDNodeInContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDNodeInContext2", C, MDs, Count);
            }
            return (MemorySegment)mh$.invokeExact(C, MDs, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMetadataAsValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMetadataAsValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD)
     * }
     */
    public static FunctionDescriptor LLVMMetadataAsValue$descriptor() {
        return LLVMMetadataAsValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD)
     * }
     */
    public static MethodHandle LLVMMetadataAsValue$handle() {
        return LLVMMetadataAsValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD)
     * }
     */
    public static MemorySegment LLVMMetadataAsValue$address() {
        return LLVMMetadataAsValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD)
     * }
     */
    public static MemorySegment LLVMMetadataAsValue(MemorySegment C, MemorySegment MD) {
        var mh$ = LLVMMetadataAsValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMetadataAsValue", C, MD);
            }
            return (MemorySegment)mh$.invokeExact(C, MD);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMValueAsMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMValueAsMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMValueAsMetadata$descriptor() {
        return LLVMValueAsMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMValueAsMetadata$handle() {
        return LLVMValueAsMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueAsMetadata$address() {
        return LLVMValueAsMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMValueAsMetadata(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueAsMetadata(MemorySegment Val) {
        var mh$ = LLVMValueAsMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMValueAsMetadata", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMDString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMDString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetMDString(LLVMValueRef V, unsigned int *Length)
     * }
     */
    public static FunctionDescriptor LLVMGetMDString$descriptor() {
        return LLVMGetMDString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetMDString(LLVMValueRef V, unsigned int *Length)
     * }
     */
    public static MethodHandle LLVMGetMDString$handle() {
        return LLVMGetMDString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetMDString(LLVMValueRef V, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetMDString$address() {
        return LLVMGetMDString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetMDString(LLVMValueRef V, unsigned int *Length)
     * }
     */
    public static MemorySegment LLVMGetMDString(MemorySegment V, MemorySegment Length) {
        var mh$ = LLVMGetMDString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMDString", V, Length);
            }
            return (MemorySegment)mh$.invokeExact(V, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMDNodeNumOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMDNodeNumOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDNodeNumOperands(LLVMValueRef V)
     * }
     */
    public static FunctionDescriptor LLVMGetMDNodeNumOperands$descriptor() {
        return LLVMGetMDNodeNumOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDNodeNumOperands(LLVMValueRef V)
     * }
     */
    public static MethodHandle LLVMGetMDNodeNumOperands$handle() {
        return LLVMGetMDNodeNumOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetMDNodeNumOperands(LLVMValueRef V)
     * }
     */
    public static MemorySegment LLVMGetMDNodeNumOperands$address() {
        return LLVMGetMDNodeNumOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetMDNodeNumOperands(LLVMValueRef V)
     * }
     */
    public static int LLVMGetMDNodeNumOperands(MemorySegment V) {
        var mh$ = LLVMGetMDNodeNumOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMDNodeNumOperands", V);
            }
            return (int)mh$.invokeExact(V);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMDNodeOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMDNodeOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)
     * }
     */
    public static FunctionDescriptor LLVMGetMDNodeOperands$descriptor() {
        return LLVMGetMDNodeOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)
     * }
     */
    public static MethodHandle LLVMGetMDNodeOperands$handle() {
        return LLVMGetMDNodeOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)
     * }
     */
    public static MemorySegment LLVMGetMDNodeOperands$address() {
        return LLVMGetMDNodeOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetMDNodeOperands(LLVMValueRef V, LLVMValueRef *Dest)
     * }
     */
    public static void LLVMGetMDNodeOperands(MemorySegment V, MemorySegment Dest) {
        var mh$ = LLVMGetMDNodeOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMDNodeOperands", V, Dest);
            }
            mh$.invokeExact(V, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMReplaceMDNodeOperandWith {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMReplaceMDNodeOperandWith");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMReplaceMDNodeOperandWith(LLVMValueRef V, unsigned int Index, LLVMMetadataRef Replacement)
     * }
     */
    public static FunctionDescriptor LLVMReplaceMDNodeOperandWith$descriptor() {
        return LLVMReplaceMDNodeOperandWith.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMReplaceMDNodeOperandWith(LLVMValueRef V, unsigned int Index, LLVMMetadataRef Replacement)
     * }
     */
    public static MethodHandle LLVMReplaceMDNodeOperandWith$handle() {
        return LLVMReplaceMDNodeOperandWith.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMReplaceMDNodeOperandWith(LLVMValueRef V, unsigned int Index, LLVMMetadataRef Replacement)
     * }
     */
    public static MemorySegment LLVMReplaceMDNodeOperandWith$address() {
        return LLVMReplaceMDNodeOperandWith.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMReplaceMDNodeOperandWith(LLVMValueRef V, unsigned int Index, LLVMMetadataRef Replacement)
     * }
     */
    public static void LLVMReplaceMDNodeOperandWith(MemorySegment V, int Index, MemorySegment Replacement) {
        var mh$ = LLVMReplaceMDNodeOperandWith.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMReplaceMDNodeOperandWith", V, Index, Replacement);
            }
            mh$.invokeExact(V, Index, Replacement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDStringInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDStringInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str, unsigned int SLen)
     * }
     */
    public static FunctionDescriptor LLVMMDStringInContext$descriptor() {
        return LLVMMDStringInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str, unsigned int SLen)
     * }
     */
    public static MethodHandle LLVMMDStringInContext$handle() {
        return LLVMMDStringInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMMDStringInContext$address() {
        return LLVMMDStringInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDStringInContext(LLVMContextRef C, const char *Str, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMMDStringInContext(MemorySegment C, MemorySegment Str, int SLen) {
        var mh$ = LLVMMDStringInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDStringInContext", C, Str, SLen);
            }
            return (MemorySegment)mh$.invokeExact(C, Str, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDString(const char *Str, unsigned int SLen)
     * }
     */
    public static FunctionDescriptor LLVMMDString$descriptor() {
        return LLVMMDString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDString(const char *Str, unsigned int SLen)
     * }
     */
    public static MethodHandle LLVMMDString$handle() {
        return LLVMMDString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDString(const char *Str, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMMDString$address() {
        return LLVMMDString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDString(const char *Str, unsigned int SLen)
     * }
     */
    public static MemorySegment LLVMMDString(MemorySegment Str, int SLen) {
        var mh$ = LLVMMDString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDString", Str, SLen);
            }
            return (MemorySegment)mh$.invokeExact(Str, SLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDNodeInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDNodeInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static FunctionDescriptor LLVMMDNodeInContext$descriptor() {
        return LLVMMDNodeInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MethodHandle LLVMMDNodeInContext$handle() {
        return LLVMMDNodeInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMMDNodeInContext$address() {
        return LLVMMDNodeInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNodeInContext(LLVMContextRef C, LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMMDNodeInContext(MemorySegment C, MemorySegment Vals, int Count) {
        var mh$ = LLVMMDNodeInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDNodeInContext", C, Vals, Count);
            }
            return (MemorySegment)mh$.invokeExact(C, Vals, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMDNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMDNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static FunctionDescriptor LLVMMDNode$descriptor() {
        return LLVMMDNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MethodHandle LLVMMDNode$handle() {
        return LLVMMDNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMMDNode$address() {
        return LLVMMDNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMMDNode(LLVMValueRef *Vals, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMMDNode(MemorySegment Vals, int Count) {
        var mh$ = LLVMMDNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMDNode", Vals, Count);
            }
            return (MemorySegment)mh$.invokeExact(Vals, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateOperandBundle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateOperandBundle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMCreateOperandBundle(const char *Tag, size_t TagLen, LLVMValueRef *Args, unsigned int NumArgs)
     * }
     */
    public static FunctionDescriptor LLVMCreateOperandBundle$descriptor() {
        return LLVMCreateOperandBundle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMCreateOperandBundle(const char *Tag, size_t TagLen, LLVMValueRef *Args, unsigned int NumArgs)
     * }
     */
    public static MethodHandle LLVMCreateOperandBundle$handle() {
        return LLVMCreateOperandBundle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMCreateOperandBundle(const char *Tag, size_t TagLen, LLVMValueRef *Args, unsigned int NumArgs)
     * }
     */
    public static MemorySegment LLVMCreateOperandBundle$address() {
        return LLVMCreateOperandBundle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMCreateOperandBundle(const char *Tag, size_t TagLen, LLVMValueRef *Args, unsigned int NumArgs)
     * }
     */
    public static MemorySegment LLVMCreateOperandBundle(MemorySegment Tag, long TagLen, MemorySegment Args, int NumArgs) {
        var mh$ = LLVMCreateOperandBundle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateOperandBundle", Tag, TagLen, Args, NumArgs);
            }
            return (MemorySegment)mh$.invokeExact(Tag, TagLen, Args, NumArgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeOperandBundle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeOperandBundle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeOperandBundle(LLVMOperandBundleRef Bundle)
     * }
     */
    public static FunctionDescriptor LLVMDisposeOperandBundle$descriptor() {
        return LLVMDisposeOperandBundle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeOperandBundle(LLVMOperandBundleRef Bundle)
     * }
     */
    public static MethodHandle LLVMDisposeOperandBundle$handle() {
        return LLVMDisposeOperandBundle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeOperandBundle(LLVMOperandBundleRef Bundle)
     * }
     */
    public static MemorySegment LLVMDisposeOperandBundle$address() {
        return LLVMDisposeOperandBundle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeOperandBundle(LLVMOperandBundleRef Bundle)
     * }
     */
    public static void LLVMDisposeOperandBundle(MemorySegment Bundle) {
        var mh$ = LLVMDisposeOperandBundle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeOperandBundle", Bundle);
            }
            mh$.invokeExact(Bundle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

