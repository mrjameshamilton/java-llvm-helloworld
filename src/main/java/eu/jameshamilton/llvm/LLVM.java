// Generated by jextract

package eu.jameshamilton.llvm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class LLVM extends LLVM_1 {

    LLVM() {
        // Should not be called directly
    }

    private static class LLVMGetOperandBundleTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOperandBundleTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetOperandBundleTag(LLVMOperandBundleRef Bundle, size_t *Len)
     * }
     */
    public static FunctionDescriptor LLVMGetOperandBundleTag$descriptor() {
        return LLVMGetOperandBundleTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetOperandBundleTag(LLVMOperandBundleRef Bundle, size_t *Len)
     * }
     */
    public static MethodHandle LLVMGetOperandBundleTag$handle() {
        return LLVMGetOperandBundleTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetOperandBundleTag(LLVMOperandBundleRef Bundle, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleTag$address() {
        return LLVMGetOperandBundleTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetOperandBundleTag(LLVMOperandBundleRef Bundle, size_t *Len)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleTag(MemorySegment Bundle, MemorySegment Len) {
        var mh$ = LLVMGetOperandBundleTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOperandBundleTag", Bundle, Len);
            }
            return (MemorySegment)mh$.invokeExact(Bundle, Len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumOperandBundleArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumOperandBundleArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundleArgs(LLVMOperandBundleRef Bundle)
     * }
     */
    public static FunctionDescriptor LLVMGetNumOperandBundleArgs$descriptor() {
        return LLVMGetNumOperandBundleArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundleArgs(LLVMOperandBundleRef Bundle)
     * }
     */
    public static MethodHandle LLVMGetNumOperandBundleArgs$handle() {
        return LLVMGetNumOperandBundleArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundleArgs(LLVMOperandBundleRef Bundle)
     * }
     */
    public static MemorySegment LLVMGetNumOperandBundleArgs$address() {
        return LLVMGetNumOperandBundleArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundleArgs(LLVMOperandBundleRef Bundle)
     * }
     */
    public static int LLVMGetNumOperandBundleArgs(MemorySegment Bundle) {
        var mh$ = LLVMGetNumOperandBundleArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumOperandBundleArgs", Bundle);
            }
            return (int)mh$.invokeExact(Bundle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOperandBundleArgAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOperandBundleArgAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperandBundleArgAtIndex(LLVMOperandBundleRef Bundle, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetOperandBundleArgAtIndex$descriptor() {
        return LLVMGetOperandBundleArgAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperandBundleArgAtIndex(LLVMOperandBundleRef Bundle, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetOperandBundleArgAtIndex$handle() {
        return LLVMGetOperandBundleArgAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperandBundleArgAtIndex(LLVMOperandBundleRef Bundle, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleArgAtIndex$address() {
        return LLVMGetOperandBundleArgAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetOperandBundleArgAtIndex(LLVMOperandBundleRef Bundle, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleArgAtIndex(MemorySegment Bundle, int Index) {
        var mh$ = LLVMGetOperandBundleArgAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOperandBundleArgAtIndex", Bundle, Index);
            }
            return (MemorySegment)mh$.invokeExact(Bundle, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBasicBlockAsValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBasicBlockAsValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMBasicBlockAsValue$descriptor() {
        return LLVMBasicBlockAsValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMBasicBlockAsValue$handle() {
        return LLVMBasicBlockAsValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBasicBlockAsValue$address() {
        return LLVMBasicBlockAsValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBasicBlockAsValue(MemorySegment BB) {
        var mh$ = LLVMBasicBlockAsValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBasicBlockAsValue", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMValueIsBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMValueIsBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMValueIsBasicBlock$descriptor() {
        return LLVMValueIsBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMValueIsBasicBlock$handle() {
        return LLVMValueIsBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueIsBasicBlock$address() {
        return LLVMValueIsBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMValueIsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static int LLVMValueIsBasicBlock(MemorySegment Val) {
        var mh$ = LLVMValueIsBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMValueIsBasicBlock", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMValueAsBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMValueAsBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMValueAsBasicBlock$descriptor() {
        return LLVMValueAsBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMValueAsBasicBlock$handle() {
        return LLVMValueAsBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueAsBasicBlock$address() {
        return LLVMValueAsBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMValueAsBasicBlock(MemorySegment Val) {
        var mh$ = LLVMValueAsBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMValueAsBasicBlock", Val);
            }
            return (MemorySegment)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBasicBlockName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBasicBlockName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetBasicBlockName$descriptor() {
        return LLVMGetBasicBlockName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetBasicBlockName$handle() {
        return LLVMGetBasicBlockName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockName$address() {
        return LLVMGetBasicBlockName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetBasicBlockName(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockName(MemorySegment BB) {
        var mh$ = LLVMGetBasicBlockName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBasicBlockName", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBasicBlockParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBasicBlockParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetBasicBlockParent$descriptor() {
        return LLVMGetBasicBlockParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetBasicBlockParent$handle() {
        return LLVMGetBasicBlockParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockParent$address() {
        return LLVMGetBasicBlockParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockParent(MemorySegment BB) {
        var mh$ = LLVMGetBasicBlockParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBasicBlockParent", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBasicBlockTerminator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBasicBlockTerminator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetBasicBlockTerminator$descriptor() {
        return LLVMGetBasicBlockTerminator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetBasicBlockTerminator$handle() {
        return LLVMGetBasicBlockTerminator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockTerminator$address() {
        return LLVMGetBasicBlockTerminator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetBasicBlockTerminator(MemorySegment BB) {
        var mh$ = LLVMGetBasicBlockTerminator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBasicBlockTerminator", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCountBasicBlocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCountBasicBlocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCountBasicBlocks(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMCountBasicBlocks$descriptor() {
        return LLVMCountBasicBlocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCountBasicBlocks(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMCountBasicBlocks$handle() {
        return LLVMCountBasicBlocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCountBasicBlocks(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMCountBasicBlocks$address() {
        return LLVMCountBasicBlocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCountBasicBlocks(LLVMValueRef Fn)
     * }
     */
    public static int LLVMCountBasicBlocks(MemorySegment Fn) {
        var mh$ = LLVMCountBasicBlocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCountBasicBlocks", Fn);
            }
            return (int)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBasicBlocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBasicBlocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks)
     * }
     */
    public static FunctionDescriptor LLVMGetBasicBlocks$descriptor() {
        return LLVMGetBasicBlocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks)
     * }
     */
    public static MethodHandle LLVMGetBasicBlocks$handle() {
        return LLVMGetBasicBlocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks)
     * }
     */
    public static MemorySegment LLVMGetBasicBlocks$address() {
        return LLVMGetBasicBlocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetBasicBlocks(LLVMValueRef Fn, LLVMBasicBlockRef *BasicBlocks)
     * }
     */
    public static void LLVMGetBasicBlocks(MemorySegment Fn, MemorySegment BasicBlocks) {
        var mh$ = LLVMGetBasicBlocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBasicBlocks", Fn, BasicBlocks);
            }
            mh$.invokeExact(Fn, BasicBlocks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstBasicBlock$descriptor() {
        return LLVMGetFirstBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetFirstBasicBlock$handle() {
        return LLVMGetFirstBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFirstBasicBlock$address() {
        return LLVMGetFirstBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetFirstBasicBlock(MemorySegment Fn) {
        var mh$ = LLVMGetFirstBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstBasicBlock", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetLastBasicBlock$descriptor() {
        return LLVMGetLastBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetLastBasicBlock$handle() {
        return LLVMGetLastBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetLastBasicBlock$address() {
        return LLVMGetLastBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetLastBasicBlock(MemorySegment Fn) {
        var mh$ = LLVMGetLastBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastBasicBlock", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetNextBasicBlock$descriptor() {
        return LLVMGetNextBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetNextBasicBlock$handle() {
        return LLVMGetNextBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetNextBasicBlock$address() {
        return LLVMGetNextBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetNextBasicBlock(MemorySegment BB) {
        var mh$ = LLVMGetNextBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextBasicBlock", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousBasicBlock$descriptor() {
        return LLVMGetPreviousBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetPreviousBasicBlock$handle() {
        return LLVMGetPreviousBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetPreviousBasicBlock$address() {
        return LLVMGetPreviousBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetPreviousBasicBlock(MemorySegment BB) {
        var mh$ = LLVMGetPreviousBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousBasicBlock", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetEntryBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetEntryBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static FunctionDescriptor LLVMGetEntryBasicBlock$descriptor() {
        return LLVMGetEntryBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MethodHandle LLVMGetEntryBasicBlock$handle() {
        return LLVMGetEntryBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetEntryBasicBlock$address() {
        return LLVMGetEntryBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef Fn)
     * }
     */
    public static MemorySegment LLVMGetEntryBasicBlock(MemorySegment Fn) {
        var mh$ = LLVMGetEntryBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetEntryBasicBlock", Fn);
            }
            return (MemorySegment)mh$.invokeExact(Fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertExistingBasicBlockAfterInsertBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertExistingBasicBlockAfterInsertBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInsertExistingBasicBlockAfterInsertBlock(LLVMBuilderRef Builder, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMInsertExistingBasicBlockAfterInsertBlock$descriptor() {
        return LLVMInsertExistingBasicBlockAfterInsertBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInsertExistingBasicBlockAfterInsertBlock(LLVMBuilderRef Builder, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMInsertExistingBasicBlockAfterInsertBlock$handle() {
        return LLVMInsertExistingBasicBlockAfterInsertBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInsertExistingBasicBlockAfterInsertBlock(LLVMBuilderRef Builder, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMInsertExistingBasicBlockAfterInsertBlock$address() {
        return LLVMInsertExistingBasicBlockAfterInsertBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInsertExistingBasicBlockAfterInsertBlock(LLVMBuilderRef Builder, LLVMBasicBlockRef BB)
     * }
     */
    public static void LLVMInsertExistingBasicBlockAfterInsertBlock(MemorySegment Builder, MemorySegment BB) {
        var mh$ = LLVMInsertExistingBasicBlockAfterInsertBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertExistingBasicBlockAfterInsertBlock", Builder, BB);
            }
            mh$.invokeExact(Builder, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAppendExistingBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAppendExistingBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAppendExistingBasicBlock(LLVMValueRef Fn, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMAppendExistingBasicBlock$descriptor() {
        return LLVMAppendExistingBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAppendExistingBasicBlock(LLVMValueRef Fn, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMAppendExistingBasicBlock$handle() {
        return LLVMAppendExistingBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAppendExistingBasicBlock(LLVMValueRef Fn, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMAppendExistingBasicBlock$address() {
        return LLVMAppendExistingBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAppendExistingBasicBlock(LLVMValueRef Fn, LLVMBasicBlockRef BB)
     * }
     */
    public static void LLVMAppendExistingBasicBlock(MemorySegment Fn, MemorySegment BB) {
        var mh$ = LLVMAppendExistingBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAppendExistingBasicBlock", Fn, BB);
            }
            mh$.invokeExact(Fn, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateBasicBlockInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateBasicBlockInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMCreateBasicBlockInContext(LLVMContextRef C, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMCreateBasicBlockInContext$descriptor() {
        return LLVMCreateBasicBlockInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMCreateBasicBlockInContext(LLVMContextRef C, const char *Name)
     * }
     */
    public static MethodHandle LLVMCreateBasicBlockInContext$handle() {
        return LLVMCreateBasicBlockInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMCreateBasicBlockInContext(LLVMContextRef C, const char *Name)
     * }
     */
    public static MemorySegment LLVMCreateBasicBlockInContext$address() {
        return LLVMCreateBasicBlockInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMCreateBasicBlockInContext(LLVMContextRef C, const char *Name)
     * }
     */
    public static MemorySegment LLVMCreateBasicBlockInContext(MemorySegment C, MemorySegment Name) {
        var mh$ = LLVMCreateBasicBlockInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateBasicBlockInContext", C, Name);
            }
            return (MemorySegment)mh$.invokeExact(C, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAppendBasicBlockInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAppendBasicBlockInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C, LLVMValueRef Fn, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMAppendBasicBlockInContext$descriptor() {
        return LLVMAppendBasicBlockInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C, LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MethodHandle LLVMAppendBasicBlockInContext$handle() {
        return LLVMAppendBasicBlockInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C, LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMAppendBasicBlockInContext$address() {
        return LLVMAppendBasicBlockInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef C, LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMAppendBasicBlockInContext(MemorySegment C, MemorySegment Fn, MemorySegment Name) {
        var mh$ = LLVMAppendBasicBlockInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAppendBasicBlockInContext", C, Fn, Name);
            }
            return (MemorySegment)mh$.invokeExact(C, Fn, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAppendBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAppendBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMAppendBasicBlock$descriptor() {
        return LLVMAppendBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MethodHandle LLVMAppendBasicBlock$handle() {
        return LLVMAppendBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMAppendBasicBlock$address() {
        return LLVMAppendBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef Fn, const char *Name)
     * }
     */
    public static MemorySegment LLVMAppendBasicBlock(MemorySegment Fn, MemorySegment Name) {
        var mh$ = LLVMAppendBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAppendBasicBlock", Fn, Name);
            }
            return (MemorySegment)mh$.invokeExact(Fn, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertBasicBlockInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertBasicBlockInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C, LLVMBasicBlockRef BB, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMInsertBasicBlockInContext$descriptor() {
        return LLVMInsertBasicBlockInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C, LLVMBasicBlockRef BB, const char *Name)
     * }
     */
    public static MethodHandle LLVMInsertBasicBlockInContext$handle() {
        return LLVMInsertBasicBlockInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C, LLVMBasicBlockRef BB, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertBasicBlockInContext$address() {
        return LLVMInsertBasicBlockInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef C, LLVMBasicBlockRef BB, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertBasicBlockInContext(MemorySegment C, MemorySegment BB, MemorySegment Name) {
        var mh$ = LLVMInsertBasicBlockInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertBasicBlockInContext", C, BB, Name);
            }
            return (MemorySegment)mh$.invokeExact(C, BB, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMInsertBasicBlock$descriptor() {
        return LLVMInsertBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB, const char *Name)
     * }
     */
    public static MethodHandle LLVMInsertBasicBlock$handle() {
        return LLVMInsertBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertBasicBlock$address() {
        return LLVMInsertBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef InsertBeforeBB, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertBasicBlock(MemorySegment InsertBeforeBB, MemorySegment Name) {
        var mh$ = LLVMInsertBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertBasicBlock", InsertBeforeBB, Name);
            }
            return (MemorySegment)mh$.invokeExact(InsertBeforeBB, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDeleteBasicBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDeleteBasicBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMDeleteBasicBlock$descriptor() {
        return LLVMDeleteBasicBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMDeleteBasicBlock$handle() {
        return LLVMDeleteBasicBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMDeleteBasicBlock$address() {
        return LLVMDeleteBasicBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDeleteBasicBlock(LLVMBasicBlockRef BB)
     * }
     */
    public static void LLVMDeleteBasicBlock(MemorySegment BB) {
        var mh$ = LLVMDeleteBasicBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDeleteBasicBlock", BB);
            }
            mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveBasicBlockFromParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveBasicBlockFromParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMRemoveBasicBlockFromParent$descriptor() {
        return LLVMRemoveBasicBlockFromParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMRemoveBasicBlockFromParent$handle() {
        return LLVMRemoveBasicBlockFromParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMRemoveBasicBlockFromParent$address() {
        return LLVMRemoveBasicBlockFromParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef BB)
     * }
     */
    public static void LLVMRemoveBasicBlockFromParent(MemorySegment BB) {
        var mh$ = LLVMRemoveBasicBlockFromParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveBasicBlockFromParent", BB);
            }
            mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMoveBasicBlockBefore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMoveBasicBlockBefore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static FunctionDescriptor LLVMMoveBasicBlockBefore$descriptor() {
        return LLVMMoveBasicBlockBefore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static MethodHandle LLVMMoveBasicBlockBefore$handle() {
        return LLVMMoveBasicBlockBefore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static MemorySegment LLVMMoveBasicBlockBefore$address() {
        return LLVMMoveBasicBlockBefore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static void LLVMMoveBasicBlockBefore(MemorySegment BB, MemorySegment MovePos) {
        var mh$ = LLVMMoveBasicBlockBefore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMoveBasicBlockBefore", BB, MovePos);
            }
            mh$.invokeExact(BB, MovePos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMMoveBasicBlockAfter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMMoveBasicBlockAfter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static FunctionDescriptor LLVMMoveBasicBlockAfter$descriptor() {
        return LLVMMoveBasicBlockAfter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static MethodHandle LLVMMoveBasicBlockAfter$handle() {
        return LLVMMoveBasicBlockAfter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static MemorySegment LLVMMoveBasicBlockAfter$address() {
        return LLVMMoveBasicBlockAfter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef BB, LLVMBasicBlockRef MovePos)
     * }
     */
    public static void LLVMMoveBasicBlockAfter(MemorySegment BB, MemorySegment MovePos) {
        var mh$ = LLVMMoveBasicBlockAfter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMMoveBasicBlockAfter", BB, MovePos);
            }
            mh$.invokeExact(BB, MovePos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstInstruction$descriptor() {
        return LLVMGetFirstInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetFirstInstruction$handle() {
        return LLVMGetFirstInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetFirstInstruction$address() {
        return LLVMGetFirstInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetFirstInstruction(MemorySegment BB) {
        var mh$ = LLVMGetFirstInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstInstruction", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMGetLastInstruction$descriptor() {
        return LLVMGetLastInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMGetLastInstruction$handle() {
        return LLVMGetLastInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetLastInstruction$address() {
        return LLVMGetLastInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMGetLastInstruction(MemorySegment BB) {
        var mh$ = LLVMGetLastInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastInstruction", BB);
            }
            return (MemorySegment)mh$.invokeExact(BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMHasMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMHasMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LLVMHasMetadata(LLVMValueRef Val)
     * }
     */
    public static FunctionDescriptor LLVMHasMetadata$descriptor() {
        return LLVMHasMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LLVMHasMetadata(LLVMValueRef Val)
     * }
     */
    public static MethodHandle LLVMHasMetadata$handle() {
        return LLVMHasMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LLVMHasMetadata(LLVMValueRef Val)
     * }
     */
    public static MemorySegment LLVMHasMetadata$address() {
        return LLVMHasMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LLVMHasMetadata(LLVMValueRef Val)
     * }
     */
    public static int LLVMHasMetadata(MemorySegment Val) {
        var mh$ = LLVMHasMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMHasMetadata", Val);
            }
            return (int)mh$.invokeExact(Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMGetMetadata$descriptor() {
        return LLVMGetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMGetMetadata$handle() {
        return LLVMGetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetMetadata$address() {
        return LLVMGetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetMetadata(LLVMValueRef Val, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetMetadata(MemorySegment Val, int KindID) {
        var mh$ = LLVMGetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMetadata", Val, KindID);
            }
            return (MemorySegment)mh$.invokeExact(Val, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetMetadata(LLVMValueRef Val, unsigned int KindID, LLVMValueRef Node)
     * }
     */
    public static FunctionDescriptor LLVMSetMetadata$descriptor() {
        return LLVMSetMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetMetadata(LLVMValueRef Val, unsigned int KindID, LLVMValueRef Node)
     * }
     */
    public static MethodHandle LLVMSetMetadata$handle() {
        return LLVMSetMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetMetadata(LLVMValueRef Val, unsigned int KindID, LLVMValueRef Node)
     * }
     */
    public static MemorySegment LLVMSetMetadata$address() {
        return LLVMSetMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetMetadata(LLVMValueRef Val, unsigned int KindID, LLVMValueRef Node)
     * }
     */
    public static void LLVMSetMetadata(MemorySegment Val, int KindID, MemorySegment Node) {
        var mh$ = LLVMSetMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetMetadata", Val, KindID, Node);
            }
            mh$.invokeExact(Val, KindID, Node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInstructionGetAllMetadataOtherThanDebugLoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstructionGetAllMetadataOtherThanDebugLoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMInstructionGetAllMetadataOtherThanDebugLoc(LLVMValueRef Instr, size_t *NumEntries)
     * }
     */
    public static FunctionDescriptor LLVMInstructionGetAllMetadataOtherThanDebugLoc$descriptor() {
        return LLVMInstructionGetAllMetadataOtherThanDebugLoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMInstructionGetAllMetadataOtherThanDebugLoc(LLVMValueRef Instr, size_t *NumEntries)
     * }
     */
    public static MethodHandle LLVMInstructionGetAllMetadataOtherThanDebugLoc$handle() {
        return LLVMInstructionGetAllMetadataOtherThanDebugLoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMInstructionGetAllMetadataOtherThanDebugLoc(LLVMValueRef Instr, size_t *NumEntries)
     * }
     */
    public static MemorySegment LLVMInstructionGetAllMetadataOtherThanDebugLoc$address() {
        return LLVMInstructionGetAllMetadataOtherThanDebugLoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueMetadataEntry *LLVMInstructionGetAllMetadataOtherThanDebugLoc(LLVMValueRef Instr, size_t *NumEntries)
     * }
     */
    public static MemorySegment LLVMInstructionGetAllMetadataOtherThanDebugLoc(MemorySegment Instr, MemorySegment NumEntries) {
        var mh$ = LLVMInstructionGetAllMetadataOtherThanDebugLoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstructionGetAllMetadataOtherThanDebugLoc", Instr, NumEntries);
            }
            return (MemorySegment)mh$.invokeExact(Instr, NumEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInstructionParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInstructionParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetInstructionParent$descriptor() {
        return LLVMGetInstructionParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetInstructionParent$handle() {
        return LLVMGetInstructionParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetInstructionParent$address() {
        return LLVMGetInstructionParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetInstructionParent(MemorySegment Inst) {
        var mh$ = LLVMGetInstructionParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInstructionParent", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetNextInstruction$descriptor() {
        return LLVMGetNextInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetNextInstruction$handle() {
        return LLVMGetNextInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetNextInstruction$address() {
        return LLVMGetNextInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetNextInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetNextInstruction(MemorySegment Inst) {
        var mh$ = LLVMGetNextInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextInstruction", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousInstruction$descriptor() {
        return LLVMGetPreviousInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetPreviousInstruction$handle() {
        return LLVMGetPreviousInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetPreviousInstruction$address() {
        return LLVMGetPreviousInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetPreviousInstruction(MemorySegment Inst) {
        var mh$ = LLVMGetPreviousInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousInstruction", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInstructionRemoveFromParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstructionRemoveFromParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInstructionRemoveFromParent(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMInstructionRemoveFromParent$descriptor() {
        return LLVMInstructionRemoveFromParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInstructionRemoveFromParent(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMInstructionRemoveFromParent$handle() {
        return LLVMInstructionRemoveFromParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInstructionRemoveFromParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMInstructionRemoveFromParent$address() {
        return LLVMInstructionRemoveFromParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInstructionRemoveFromParent(LLVMValueRef Inst)
     * }
     */
    public static void LLVMInstructionRemoveFromParent(MemorySegment Inst) {
        var mh$ = LLVMInstructionRemoveFromParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstructionRemoveFromParent", Inst);
            }
            mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInstructionEraseFromParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstructionEraseFromParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInstructionEraseFromParent(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMInstructionEraseFromParent$descriptor() {
        return LLVMInstructionEraseFromParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInstructionEraseFromParent(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMInstructionEraseFromParent$handle() {
        return LLVMInstructionEraseFromParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInstructionEraseFromParent(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMInstructionEraseFromParent$address() {
        return LLVMInstructionEraseFromParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInstructionEraseFromParent(LLVMValueRef Inst)
     * }
     */
    public static void LLVMInstructionEraseFromParent(MemorySegment Inst) {
        var mh$ = LLVMInstructionEraseFromParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstructionEraseFromParent", Inst);
            }
            mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDeleteInstruction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDeleteInstruction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDeleteInstruction(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMDeleteInstruction$descriptor() {
        return LLVMDeleteInstruction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDeleteInstruction(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMDeleteInstruction$handle() {
        return LLVMDeleteInstruction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDeleteInstruction(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMDeleteInstruction$address() {
        return LLVMDeleteInstruction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDeleteInstruction(LLVMValueRef Inst)
     * }
     */
    public static void LLVMDeleteInstruction(MemorySegment Inst) {
        var mh$ = LLVMDeleteInstruction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDeleteInstruction", Inst);
            }
            mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInstructionOpcode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInstructionOpcode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetInstructionOpcode$descriptor() {
        return LLVMGetInstructionOpcode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetInstructionOpcode$handle() {
        return LLVMGetInstructionOpcode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetInstructionOpcode$address() {
        return LLVMGetInstructionOpcode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetInstructionOpcode(MemorySegment Inst) {
        var mh$ = LLVMGetInstructionOpcode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInstructionOpcode", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetICmpPredicate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetICmpPredicate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetICmpPredicate$descriptor() {
        return LLVMGetICmpPredicate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetICmpPredicate$handle() {
        return LLVMGetICmpPredicate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetICmpPredicate$address() {
        return LLVMGetICmpPredicate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetICmpPredicate(MemorySegment Inst) {
        var mh$ = LLVMGetICmpPredicate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetICmpPredicate", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFCmpPredicate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFCmpPredicate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetFCmpPredicate$descriptor() {
        return LLVMGetFCmpPredicate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetFCmpPredicate$handle() {
        return LLVMGetFCmpPredicate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetFCmpPredicate$address() {
        return LLVMGetFCmpPredicate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMRealPredicate LLVMGetFCmpPredicate(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetFCmpPredicate(MemorySegment Inst) {
        var mh$ = LLVMGetFCmpPredicate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFCmpPredicate", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInstructionClone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInstructionClone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMInstructionClone$descriptor() {
        return LLVMInstructionClone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMInstructionClone$handle() {
        return LLVMInstructionClone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMInstructionClone$address() {
        return LLVMInstructionClone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMInstructionClone(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMInstructionClone(MemorySegment Inst) {
        var mh$ = LLVMInstructionClone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInstructionClone", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsATerminatorInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsATerminatorInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMIsATerminatorInst$descriptor() {
        return LLVMIsATerminatorInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMIsATerminatorInst$handle() {
        return LLVMIsATerminatorInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMIsATerminatorInst$address() {
        return LLVMIsATerminatorInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMIsATerminatorInst(MemorySegment Inst) {
        var mh$ = LLVMIsATerminatorInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsATerminatorInst", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFirstDbgRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFirstDbgRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetFirstDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetFirstDbgRecord$descriptor() {
        return LLVMGetFirstDbgRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetFirstDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetFirstDbgRecord$handle() {
        return LLVMGetFirstDbgRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetFirstDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetFirstDbgRecord$address() {
        return LLVMGetFirstDbgRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetFirstDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetFirstDbgRecord(MemorySegment Inst) {
        var mh$ = LLVMGetFirstDbgRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFirstDbgRecord", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetLastDbgRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetLastDbgRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetLastDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetLastDbgRecord$descriptor() {
        return LLVMGetLastDbgRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetLastDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetLastDbgRecord$handle() {
        return LLVMGetLastDbgRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetLastDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetLastDbgRecord$address() {
        return LLVMGetLastDbgRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetLastDbgRecord(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetLastDbgRecord(MemorySegment Inst) {
        var mh$ = LLVMGetLastDbgRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetLastDbgRecord", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNextDbgRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNextDbgRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetNextDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static FunctionDescriptor LLVMGetNextDbgRecord$descriptor() {
        return LLVMGetNextDbgRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetNextDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MethodHandle LLVMGetNextDbgRecord$handle() {
        return LLVMGetNextDbgRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetNextDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MemorySegment LLVMGetNextDbgRecord$address() {
        return LLVMGetNextDbgRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetNextDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MemorySegment LLVMGetNextDbgRecord(MemorySegment DbgRecord) {
        var mh$ = LLVMGetNextDbgRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNextDbgRecord", DbgRecord);
            }
            return (MemorySegment)mh$.invokeExact(DbgRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetPreviousDbgRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetPreviousDbgRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetPreviousDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static FunctionDescriptor LLVMGetPreviousDbgRecord$descriptor() {
        return LLVMGetPreviousDbgRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetPreviousDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MethodHandle LLVMGetPreviousDbgRecord$handle() {
        return LLVMGetPreviousDbgRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetPreviousDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MemorySegment LLVMGetPreviousDbgRecord$address() {
        return LLVMGetPreviousDbgRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMDbgRecordRef LLVMGetPreviousDbgRecord(LLVMDbgRecordRef DbgRecord)
     * }
     */
    public static MemorySegment LLVMGetPreviousDbgRecord(MemorySegment DbgRecord) {
        var mh$ = LLVMGetPreviousDbgRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetPreviousDbgRecord", DbgRecord);
            }
            return (MemorySegment)mh$.invokeExact(DbgRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumArgOperands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumArgOperands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumArgOperands(LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMGetNumArgOperands$descriptor() {
        return LLVMGetNumArgOperands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumArgOperands(LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMGetNumArgOperands$handle() {
        return LLVMGetNumArgOperands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumArgOperands(LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMGetNumArgOperands$address() {
        return LLVMGetNumArgOperands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumArgOperands(LLVMValueRef Instr)
     * }
     */
    public static int LLVMGetNumArgOperands(MemorySegment Instr) {
        var mh$ = LLVMGetNumArgOperands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumArgOperands", Instr);
            }
            return (int)mh$.invokeExact(Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetInstructionCallConv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetInstructionCallConv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned int CC)
     * }
     */
    public static FunctionDescriptor LLVMSetInstructionCallConv$descriptor() {
        return LLVMSetInstructionCallConv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned int CC)
     * }
     */
    public static MethodHandle LLVMSetInstructionCallConv$handle() {
        return LLVMSetInstructionCallConv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned int CC)
     * }
     */
    public static MemorySegment LLVMSetInstructionCallConv$address() {
        return LLVMSetInstructionCallConv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetInstructionCallConv(LLVMValueRef Instr, unsigned int CC)
     * }
     */
    public static void LLVMSetInstructionCallConv(MemorySegment Instr, int CC) {
        var mh$ = LLVMSetInstructionCallConv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetInstructionCallConv", Instr, CC);
            }
            mh$.invokeExact(Instr, CC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInstructionCallConv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInstructionCallConv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetInstructionCallConv(LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMGetInstructionCallConv$descriptor() {
        return LLVMGetInstructionCallConv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetInstructionCallConv(LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMGetInstructionCallConv$handle() {
        return LLVMGetInstructionCallConv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetInstructionCallConv(LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMGetInstructionCallConv$address() {
        return LLVMGetInstructionCallConv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetInstructionCallConv(LLVMValueRef Instr)
     * }
     */
    public static int LLVMGetInstructionCallConv(MemorySegment Instr) {
        var mh$ = LLVMGetInstructionCallConv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInstructionCallConv", Instr);
            }
            return (int)mh$.invokeExact(Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetInstrParamAlignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetInstrParamAlignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetInstrParamAlignment(LLVMValueRef Instr, LLVMAttributeIndex Idx, unsigned int Align)
     * }
     */
    public static FunctionDescriptor LLVMSetInstrParamAlignment$descriptor() {
        return LLVMSetInstrParamAlignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetInstrParamAlignment(LLVMValueRef Instr, LLVMAttributeIndex Idx, unsigned int Align)
     * }
     */
    public static MethodHandle LLVMSetInstrParamAlignment$handle() {
        return LLVMSetInstrParamAlignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetInstrParamAlignment(LLVMValueRef Instr, LLVMAttributeIndex Idx, unsigned int Align)
     * }
     */
    public static MemorySegment LLVMSetInstrParamAlignment$address() {
        return LLVMSetInstrParamAlignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetInstrParamAlignment(LLVMValueRef Instr, LLVMAttributeIndex Idx, unsigned int Align)
     * }
     */
    public static void LLVMSetInstrParamAlignment(MemorySegment Instr, int Idx, int Align) {
        var mh$ = LLVMSetInstrParamAlignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetInstrParamAlignment", Instr, Idx, Align);
            }
            mh$.invokeExact(Instr, Idx, Align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddCallSiteAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddCallSiteAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static FunctionDescriptor LLVMAddCallSiteAttribute$descriptor() {
        return LLVMAddCallSiteAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static MethodHandle LLVMAddCallSiteAttribute$handle() {
        return LLVMAddCallSiteAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static MemorySegment LLVMAddCallSiteAttribute$address() {
        return LLVMAddCallSiteAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddCallSiteAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef A)
     * }
     */
    public static void LLVMAddCallSiteAttribute(MemorySegment C, int Idx, MemorySegment A) {
        var mh$ = LLVMAddCallSiteAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddCallSiteAttribute", C, Idx, A);
            }
            mh$.invokeExact(C, Idx, A);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallSiteAttributeCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallSiteAttributeCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetCallSiteAttributeCount$descriptor() {
        return LLVMGetCallSiteAttributeCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx)
     * }
     */
    public static MethodHandle LLVMGetCallSiteAttributeCount$handle() {
        return LLVMGetCallSiteAttributeCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx)
     * }
     */
    public static MemorySegment LLVMGetCallSiteAttributeCount$address() {
        return LLVMGetCallSiteAttributeCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetCallSiteAttributeCount(LLVMValueRef C, LLVMAttributeIndex Idx)
     * }
     */
    public static int LLVMGetCallSiteAttributeCount(MemorySegment C, int Idx) {
        var mh$ = LLVMGetCallSiteAttributeCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallSiteAttributeCount", C, Idx);
            }
            return (int)mh$.invokeExact(C, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallSiteAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallSiteAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static FunctionDescriptor LLVMGetCallSiteAttributes$descriptor() {
        return LLVMGetCallSiteAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static MethodHandle LLVMGetCallSiteAttributes$handle() {
        return LLVMGetCallSiteAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static MemorySegment LLVMGetCallSiteAttributes$address() {
        return LLVMGetCallSiteAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetCallSiteAttributes(LLVMValueRef C, LLVMAttributeIndex Idx, LLVMAttributeRef *Attrs)
     * }
     */
    public static void LLVMGetCallSiteAttributes(MemorySegment C, int Idx, MemorySegment Attrs) {
        var mh$ = LLVMGetCallSiteAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallSiteAttributes", C, Idx, Attrs);
            }
            mh$.invokeExact(C, Idx, Attrs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallSiteEnumAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallSiteEnumAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMGetCallSiteEnumAttribute$descriptor() {
        return LLVMGetCallSiteEnumAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMGetCallSiteEnumAttribute$handle() {
        return LLVMGetCallSiteEnumAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetCallSiteEnumAttribute$address() {
        return LLVMGetCallSiteEnumAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMGetCallSiteEnumAttribute(MemorySegment C, int Idx, int KindID) {
        var mh$ = LLVMGetCallSiteEnumAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallSiteEnumAttribute", C, Idx, KindID);
            }
            return (MemorySegment)mh$.invokeExact(C, Idx, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallSiteStringAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallSiteStringAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static FunctionDescriptor LLVMGetCallSiteStringAttribute$descriptor() {
        return LLVMGetCallSiteStringAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MethodHandle LLVMGetCallSiteStringAttribute$handle() {
        return LLVMGetCallSiteStringAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMGetCallSiteStringAttribute$address() {
        return LLVMGetCallSiteStringAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAttributeRef LLVMGetCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMGetCallSiteStringAttribute(MemorySegment C, int Idx, MemorySegment K, int KLen) {
        var mh$ = LLVMGetCallSiteStringAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallSiteStringAttribute", C, Idx, K, KLen);
            }
            return (MemorySegment)mh$.invokeExact(C, Idx, K, KLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveCallSiteEnumAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveCallSiteEnumAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static FunctionDescriptor LLVMRemoveCallSiteEnumAttribute$descriptor() {
        return LLVMRemoveCallSiteEnumAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MethodHandle LLVMRemoveCallSiteEnumAttribute$handle() {
        return LLVMRemoveCallSiteEnumAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static MemorySegment LLVMRemoveCallSiteEnumAttribute$address() {
        return LLVMRemoveCallSiteEnumAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteEnumAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, unsigned int KindID)
     * }
     */
    public static void LLVMRemoveCallSiteEnumAttribute(MemorySegment C, int Idx, int KindID) {
        var mh$ = LLVMRemoveCallSiteEnumAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveCallSiteEnumAttribute", C, Idx, KindID);
            }
            mh$.invokeExact(C, Idx, KindID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRemoveCallSiteStringAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRemoveCallSiteStringAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static FunctionDescriptor LLVMRemoveCallSiteStringAttribute$descriptor() {
        return LLVMRemoveCallSiteStringAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MethodHandle LLVMRemoveCallSiteStringAttribute$handle() {
        return LLVMRemoveCallSiteStringAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static MemorySegment LLVMRemoveCallSiteStringAttribute$address() {
        return LLVMRemoveCallSiteStringAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMRemoveCallSiteStringAttribute(LLVMValueRef C, LLVMAttributeIndex Idx, const char *K, unsigned int KLen)
     * }
     */
    public static void LLVMRemoveCallSiteStringAttribute(MemorySegment C, int Idx, MemorySegment K, int KLen) {
        var mh$ = LLVMRemoveCallSiteStringAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRemoveCallSiteStringAttribute", C, Idx, K, KLen);
            }
            mh$.invokeExact(C, Idx, K, KLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCalledFunctionType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCalledFunctionType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetCalledFunctionType(LLVMValueRef C)
     * }
     */
    public static FunctionDescriptor LLVMGetCalledFunctionType$descriptor() {
        return LLVMGetCalledFunctionType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetCalledFunctionType(LLVMValueRef C)
     * }
     */
    public static MethodHandle LLVMGetCalledFunctionType$handle() {
        return LLVMGetCalledFunctionType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetCalledFunctionType(LLVMValueRef C)
     * }
     */
    public static MemorySegment LLVMGetCalledFunctionType$address() {
        return LLVMGetCalledFunctionType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetCalledFunctionType(LLVMValueRef C)
     * }
     */
    public static MemorySegment LLVMGetCalledFunctionType(MemorySegment C) {
        var mh$ = LLVMGetCalledFunctionType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCalledFunctionType", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCalledValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCalledValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMGetCalledValue$descriptor() {
        return LLVMGetCalledValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMGetCalledValue$handle() {
        return LLVMGetCalledValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMGetCalledValue$address() {
        return LLVMGetCalledValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCalledValue(LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMGetCalledValue(MemorySegment Instr) {
        var mh$ = LLVMGetCalledValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCalledValue", Instr);
            }
            return (MemorySegment)mh$.invokeExact(Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumOperandBundles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumOperandBundles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundles(LLVMValueRef C)
     * }
     */
    public static FunctionDescriptor LLVMGetNumOperandBundles$descriptor() {
        return LLVMGetNumOperandBundles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundles(LLVMValueRef C)
     * }
     */
    public static MethodHandle LLVMGetNumOperandBundles$handle() {
        return LLVMGetNumOperandBundles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundles(LLVMValueRef C)
     * }
     */
    public static MemorySegment LLVMGetNumOperandBundles$address() {
        return LLVMGetNumOperandBundles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumOperandBundles(LLVMValueRef C)
     * }
     */
    public static int LLVMGetNumOperandBundles(MemorySegment C) {
        var mh$ = LLVMGetNumOperandBundles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumOperandBundles", C);
            }
            return (int)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOperandBundleAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOperandBundleAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMGetOperandBundleAtIndex(LLVMValueRef C, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetOperandBundleAtIndex$descriptor() {
        return LLVMGetOperandBundleAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMGetOperandBundleAtIndex(LLVMValueRef C, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetOperandBundleAtIndex$handle() {
        return LLVMGetOperandBundleAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMGetOperandBundleAtIndex(LLVMValueRef C, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleAtIndex$address() {
        return LLVMGetOperandBundleAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOperandBundleRef LLVMGetOperandBundleAtIndex(LLVMValueRef C, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetOperandBundleAtIndex(MemorySegment C, int Index) {
        var mh$ = LLVMGetOperandBundleAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOperandBundleAtIndex", C, Index);
            }
            return (MemorySegment)mh$.invokeExact(C, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsTailCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsTailCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTailCall(LLVMValueRef CallInst)
     * }
     */
    public static FunctionDescriptor LLVMIsTailCall$descriptor() {
        return LLVMIsTailCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTailCall(LLVMValueRef CallInst)
     * }
     */
    public static MethodHandle LLVMIsTailCall$handle() {
        return LLVMIsTailCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsTailCall(LLVMValueRef CallInst)
     * }
     */
    public static MemorySegment LLVMIsTailCall$address() {
        return LLVMIsTailCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsTailCall(LLVMValueRef CallInst)
     * }
     */
    public static int LLVMIsTailCall(MemorySegment CallInst) {
        var mh$ = LLVMIsTailCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsTailCall", CallInst);
            }
            return (int)mh$.invokeExact(CallInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTailCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTailCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall)
     * }
     */
    public static FunctionDescriptor LLVMSetTailCall$descriptor() {
        return LLVMSetTailCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall)
     * }
     */
    public static MethodHandle LLVMSetTailCall$handle() {
        return LLVMSetTailCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall)
     * }
     */
    public static MemorySegment LLVMSetTailCall$address() {
        return LLVMSetTailCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTailCall(LLVMValueRef CallInst, LLVMBool IsTailCall)
     * }
     */
    public static void LLVMSetTailCall(MemorySegment CallInst, int IsTailCall) {
        var mh$ = LLVMSetTailCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTailCall", CallInst, IsTailCall);
            }
            mh$.invokeExact(CallInst, IsTailCall);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetTailCallKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetTailCallKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTailCallKind LLVMGetTailCallKind(LLVMValueRef CallInst)
     * }
     */
    public static FunctionDescriptor LLVMGetTailCallKind$descriptor() {
        return LLVMGetTailCallKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTailCallKind LLVMGetTailCallKind(LLVMValueRef CallInst)
     * }
     */
    public static MethodHandle LLVMGetTailCallKind$handle() {
        return LLVMGetTailCallKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTailCallKind LLVMGetTailCallKind(LLVMValueRef CallInst)
     * }
     */
    public static MemorySegment LLVMGetTailCallKind$address() {
        return LLVMGetTailCallKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTailCallKind LLVMGetTailCallKind(LLVMValueRef CallInst)
     * }
     */
    public static int LLVMGetTailCallKind(MemorySegment CallInst) {
        var mh$ = LLVMGetTailCallKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetTailCallKind", CallInst);
            }
            return (int)mh$.invokeExact(CallInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetTailCallKind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetTailCallKind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetTailCallKind(LLVMValueRef CallInst, LLVMTailCallKind kind)
     * }
     */
    public static FunctionDescriptor LLVMSetTailCallKind$descriptor() {
        return LLVMSetTailCallKind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetTailCallKind(LLVMValueRef CallInst, LLVMTailCallKind kind)
     * }
     */
    public static MethodHandle LLVMSetTailCallKind$handle() {
        return LLVMSetTailCallKind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetTailCallKind(LLVMValueRef CallInst, LLVMTailCallKind kind)
     * }
     */
    public static MemorySegment LLVMSetTailCallKind$address() {
        return LLVMSetTailCallKind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetTailCallKind(LLVMValueRef CallInst, LLVMTailCallKind kind)
     * }
     */
    public static void LLVMSetTailCallKind(MemorySegment CallInst, int kind) {
        var mh$ = LLVMSetTailCallKind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetTailCallKind", CallInst, kind);
            }
            mh$.invokeExact(CallInst, kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNormalDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNormalDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNormalDest$descriptor() {
        return LLVMGetNormalDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MethodHandle LLVMGetNormalDest$handle() {
        return LLVMGetNormalDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MemorySegment LLVMGetNormalDest$address() {
        return LLVMGetNormalDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetNormalDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MemorySegment LLVMGetNormalDest(MemorySegment InvokeInst) {
        var mh$ = LLVMGetNormalDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNormalDest", InvokeInst);
            }
            return (MemorySegment)mh$.invokeExact(InvokeInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetUnwindDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetUnwindDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst)
     * }
     */
    public static FunctionDescriptor LLVMGetUnwindDest$descriptor() {
        return LLVMGetUnwindDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MethodHandle LLVMGetUnwindDest$handle() {
        return LLVMGetUnwindDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MemorySegment LLVMGetUnwindDest$address() {
        return LLVMGetUnwindDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetUnwindDest(LLVMValueRef InvokeInst)
     * }
     */
    public static MemorySegment LLVMGetUnwindDest(MemorySegment InvokeInst) {
        var mh$ = LLVMGetUnwindDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetUnwindDest", InvokeInst);
            }
            return (MemorySegment)mh$.invokeExact(InvokeInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetNormalDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetNormalDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static FunctionDescriptor LLVMSetNormalDest$descriptor() {
        return LLVMSetNormalDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static MethodHandle LLVMSetNormalDest$handle() {
        return LLVMSetNormalDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static MemorySegment LLVMSetNormalDest$address() {
        return LLVMSetNormalDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetNormalDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static void LLVMSetNormalDest(MemorySegment InvokeInst, MemorySegment B) {
        var mh$ = LLVMSetNormalDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetNormalDest", InvokeInst, B);
            }
            mh$.invokeExact(InvokeInst, B);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetUnwindDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetUnwindDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static FunctionDescriptor LLVMSetUnwindDest$descriptor() {
        return LLVMSetUnwindDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static MethodHandle LLVMSetUnwindDest$handle() {
        return LLVMSetUnwindDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static MemorySegment LLVMSetUnwindDest$address() {
        return LLVMSetUnwindDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetUnwindDest(LLVMValueRef InvokeInst, LLVMBasicBlockRef B)
     * }
     */
    public static void LLVMSetUnwindDest(MemorySegment InvokeInst, MemorySegment B) {
        var mh$ = LLVMSetUnwindDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetUnwindDest", InvokeInst, B);
            }
            mh$.invokeExact(InvokeInst, B);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallBrDefaultDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallBrDefaultDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrDefaultDest(LLVMValueRef CallBr)
     * }
     */
    public static FunctionDescriptor LLVMGetCallBrDefaultDest$descriptor() {
        return LLVMGetCallBrDefaultDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrDefaultDest(LLVMValueRef CallBr)
     * }
     */
    public static MethodHandle LLVMGetCallBrDefaultDest$handle() {
        return LLVMGetCallBrDefaultDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrDefaultDest(LLVMValueRef CallBr)
     * }
     */
    public static MemorySegment LLVMGetCallBrDefaultDest$address() {
        return LLVMGetCallBrDefaultDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrDefaultDest(LLVMValueRef CallBr)
     * }
     */
    public static MemorySegment LLVMGetCallBrDefaultDest(MemorySegment CallBr) {
        var mh$ = LLVMGetCallBrDefaultDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallBrDefaultDest", CallBr);
            }
            return (MemorySegment)mh$.invokeExact(CallBr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallBrNumIndirectDests {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallBrNumIndirectDests");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallBrNumIndirectDests(LLVMValueRef CallBr)
     * }
     */
    public static FunctionDescriptor LLVMGetCallBrNumIndirectDests$descriptor() {
        return LLVMGetCallBrNumIndirectDests.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallBrNumIndirectDests(LLVMValueRef CallBr)
     * }
     */
    public static MethodHandle LLVMGetCallBrNumIndirectDests$handle() {
        return LLVMGetCallBrNumIndirectDests.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetCallBrNumIndirectDests(LLVMValueRef CallBr)
     * }
     */
    public static MemorySegment LLVMGetCallBrNumIndirectDests$address() {
        return LLVMGetCallBrNumIndirectDests.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetCallBrNumIndirectDests(LLVMValueRef CallBr)
     * }
     */
    public static int LLVMGetCallBrNumIndirectDests(MemorySegment CallBr) {
        var mh$ = LLVMGetCallBrNumIndirectDests.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallBrNumIndirectDests", CallBr);
            }
            return (int)mh$.invokeExact(CallBr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCallBrIndirectDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCallBrIndirectDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrIndirectDest(LLVMValueRef CallBr, unsigned int Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetCallBrIndirectDest$descriptor() {
        return LLVMGetCallBrIndirectDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrIndirectDest(LLVMValueRef CallBr, unsigned int Idx)
     * }
     */
    public static MethodHandle LLVMGetCallBrIndirectDest$handle() {
        return LLVMGetCallBrIndirectDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrIndirectDest(LLVMValueRef CallBr, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetCallBrIndirectDest$address() {
        return LLVMGetCallBrIndirectDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetCallBrIndirectDest(LLVMValueRef CallBr, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetCallBrIndirectDest(MemorySegment CallBr, int Idx) {
        var mh$ = LLVMGetCallBrIndirectDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCallBrIndirectDest", CallBr, Idx);
            }
            return (MemorySegment)mh$.invokeExact(CallBr, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumSuccessors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumSuccessors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumSuccessors(LLVMValueRef Term)
     * }
     */
    public static FunctionDescriptor LLVMGetNumSuccessors$descriptor() {
        return LLVMGetNumSuccessors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumSuccessors(LLVMValueRef Term)
     * }
     */
    public static MethodHandle LLVMGetNumSuccessors$handle() {
        return LLVMGetNumSuccessors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumSuccessors(LLVMValueRef Term)
     * }
     */
    public static MemorySegment LLVMGetNumSuccessors$address() {
        return LLVMGetNumSuccessors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumSuccessors(LLVMValueRef Term)
     * }
     */
    public static int LLVMGetNumSuccessors(MemorySegment Term) {
        var mh$ = LLVMGetNumSuccessors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumSuccessors", Term);
            }
            return (int)mh$.invokeExact(Term);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetSuccessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetSuccessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned int i)
     * }
     */
    public static FunctionDescriptor LLVMGetSuccessor$descriptor() {
        return LLVMGetSuccessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned int i)
     * }
     */
    public static MethodHandle LLVMGetSuccessor$handle() {
        return LLVMGetSuccessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned int i)
     * }
     */
    public static MemorySegment LLVMGetSuccessor$address() {
        return LLVMGetSuccessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSuccessor(LLVMValueRef Term, unsigned int i)
     * }
     */
    public static MemorySegment LLVMGetSuccessor(MemorySegment Term, int i) {
        var mh$ = LLVMGetSuccessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetSuccessor", Term, i);
            }
            return (MemorySegment)mh$.invokeExact(Term, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetSuccessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetSuccessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetSuccessor(LLVMValueRef Term, unsigned int i, LLVMBasicBlockRef block)
     * }
     */
    public static FunctionDescriptor LLVMSetSuccessor$descriptor() {
        return LLVMSetSuccessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetSuccessor(LLVMValueRef Term, unsigned int i, LLVMBasicBlockRef block)
     * }
     */
    public static MethodHandle LLVMSetSuccessor$handle() {
        return LLVMSetSuccessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetSuccessor(LLVMValueRef Term, unsigned int i, LLVMBasicBlockRef block)
     * }
     */
    public static MemorySegment LLVMSetSuccessor$address() {
        return LLVMSetSuccessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetSuccessor(LLVMValueRef Term, unsigned int i, LLVMBasicBlockRef block)
     * }
     */
    public static void LLVMSetSuccessor(MemorySegment Term, int i, MemorySegment block) {
        var mh$ = LLVMSetSuccessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetSuccessor", Term, i, block);
            }
            mh$.invokeExact(Term, i, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsConditional {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsConditional");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConditional(LLVMValueRef Branch)
     * }
     */
    public static FunctionDescriptor LLVMIsConditional$descriptor() {
        return LLVMIsConditional.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConditional(LLVMValueRef Branch)
     * }
     */
    public static MethodHandle LLVMIsConditional$handle() {
        return LLVMIsConditional.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsConditional(LLVMValueRef Branch)
     * }
     */
    public static MemorySegment LLVMIsConditional$address() {
        return LLVMIsConditional.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsConditional(LLVMValueRef Branch)
     * }
     */
    public static int LLVMIsConditional(MemorySegment Branch) {
        var mh$ = LLVMIsConditional.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsConditional", Branch);
            }
            return (int)mh$.invokeExact(Branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCondition(LLVMValueRef Branch)
     * }
     */
    public static FunctionDescriptor LLVMGetCondition$descriptor() {
        return LLVMGetCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCondition(LLVMValueRef Branch)
     * }
     */
    public static MethodHandle LLVMGetCondition$handle() {
        return LLVMGetCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCondition(LLVMValueRef Branch)
     * }
     */
    public static MemorySegment LLVMGetCondition$address() {
        return LLVMGetCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCondition(LLVMValueRef Branch)
     * }
     */
    public static MemorySegment LLVMGetCondition(MemorySegment Branch) {
        var mh$ = LLVMGetCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCondition", Branch);
            }
            return (MemorySegment)mh$.invokeExact(Branch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond)
     * }
     */
    public static FunctionDescriptor LLVMSetCondition$descriptor() {
        return LLVMSetCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond)
     * }
     */
    public static MethodHandle LLVMSetCondition$handle() {
        return LLVMSetCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond)
     * }
     */
    public static MemorySegment LLVMSetCondition$address() {
        return LLVMSetCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCondition(LLVMValueRef Branch, LLVMValueRef Cond)
     * }
     */
    public static void LLVMSetCondition(MemorySegment Branch, MemorySegment Cond) {
        var mh$ = LLVMSetCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCondition", Branch, Cond);
            }
            mh$.invokeExact(Branch, Cond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetSwitchDefaultDest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetSwitchDefaultDest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr)
     * }
     */
    public static FunctionDescriptor LLVMGetSwitchDefaultDest$descriptor() {
        return LLVMGetSwitchDefaultDest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr)
     * }
     */
    public static MethodHandle LLVMGetSwitchDefaultDest$handle() {
        return LLVMGetSwitchDefaultDest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr)
     * }
     */
    public static MemorySegment LLVMGetSwitchDefaultDest$address() {
        return LLVMGetSwitchDefaultDest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef SwitchInstr)
     * }
     */
    public static MemorySegment LLVMGetSwitchDefaultDest(MemorySegment SwitchInstr) {
        var mh$ = LLVMGetSwitchDefaultDest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetSwitchDefaultDest", SwitchInstr);
            }
            return (MemorySegment)mh$.invokeExact(SwitchInstr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAllocatedType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAllocatedType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca)
     * }
     */
    public static FunctionDescriptor LLVMGetAllocatedType$descriptor() {
        return LLVMGetAllocatedType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca)
     * }
     */
    public static MethodHandle LLVMGetAllocatedType$handle() {
        return LLVMGetAllocatedType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca)
     * }
     */
    public static MemorySegment LLVMGetAllocatedType$address() {
        return LLVMGetAllocatedType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetAllocatedType(LLVMValueRef Alloca)
     * }
     */
    public static MemorySegment LLVMGetAllocatedType(MemorySegment Alloca) {
        var mh$ = LLVMGetAllocatedType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAllocatedType", Alloca);
            }
            return (MemorySegment)mh$.invokeExact(Alloca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsInBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsInBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsInBounds(LLVMValueRef GEP)
     * }
     */
    public static FunctionDescriptor LLVMIsInBounds$descriptor() {
        return LLVMIsInBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsInBounds(LLVMValueRef GEP)
     * }
     */
    public static MethodHandle LLVMIsInBounds$handle() {
        return LLVMIsInBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsInBounds(LLVMValueRef GEP)
     * }
     */
    public static MemorySegment LLVMIsInBounds$address() {
        return LLVMIsInBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsInBounds(LLVMValueRef GEP)
     * }
     */
    public static int LLVMIsInBounds(MemorySegment GEP) {
        var mh$ = LLVMIsInBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsInBounds", GEP);
            }
            return (int)mh$.invokeExact(GEP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetIsInBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetIsInBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds)
     * }
     */
    public static FunctionDescriptor LLVMSetIsInBounds$descriptor() {
        return LLVMSetIsInBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds)
     * }
     */
    public static MethodHandle LLVMSetIsInBounds$handle() {
        return LLVMSetIsInBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds)
     * }
     */
    public static MemorySegment LLVMSetIsInBounds$address() {
        return LLVMSetIsInBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetIsInBounds(LLVMValueRef GEP, LLVMBool InBounds)
     * }
     */
    public static void LLVMSetIsInBounds(MemorySegment GEP, int InBounds) {
        var mh$ = LLVMSetIsInBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetIsInBounds", GEP, InBounds);
            }
            mh$.invokeExact(GEP, InBounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetGEPSourceElementType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetGEPSourceElementType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetGEPSourceElementType(LLVMValueRef GEP)
     * }
     */
    public static FunctionDescriptor LLVMGetGEPSourceElementType$descriptor() {
        return LLVMGetGEPSourceElementType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetGEPSourceElementType(LLVMValueRef GEP)
     * }
     */
    public static MethodHandle LLVMGetGEPSourceElementType$handle() {
        return LLVMGetGEPSourceElementType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetGEPSourceElementType(LLVMValueRef GEP)
     * }
     */
    public static MemorySegment LLVMGetGEPSourceElementType$address() {
        return LLVMGetGEPSourceElementType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMTypeRef LLVMGetGEPSourceElementType(LLVMValueRef GEP)
     * }
     */
    public static MemorySegment LLVMGetGEPSourceElementType(MemorySegment GEP) {
        var mh$ = LLVMGetGEPSourceElementType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetGEPSourceElementType", GEP);
            }
            return (MemorySegment)mh$.invokeExact(GEP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGEPGetNoWrapFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGEPGetNoWrapFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMGEPNoWrapFlags LLVMGEPGetNoWrapFlags(LLVMValueRef GEP)
     * }
     */
    public static FunctionDescriptor LLVMGEPGetNoWrapFlags$descriptor() {
        return LLVMGEPGetNoWrapFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMGEPNoWrapFlags LLVMGEPGetNoWrapFlags(LLVMValueRef GEP)
     * }
     */
    public static MethodHandle LLVMGEPGetNoWrapFlags$handle() {
        return LLVMGEPGetNoWrapFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMGEPNoWrapFlags LLVMGEPGetNoWrapFlags(LLVMValueRef GEP)
     * }
     */
    public static MemorySegment LLVMGEPGetNoWrapFlags$address() {
        return LLVMGEPGetNoWrapFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMGEPNoWrapFlags LLVMGEPGetNoWrapFlags(LLVMValueRef GEP)
     * }
     */
    public static int LLVMGEPGetNoWrapFlags(MemorySegment GEP) {
        var mh$ = LLVMGEPGetNoWrapFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGEPGetNoWrapFlags", GEP);
            }
            return (int)mh$.invokeExact(GEP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGEPSetNoWrapFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGEPSetNoWrapFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGEPSetNoWrapFlags(LLVMValueRef GEP, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static FunctionDescriptor LLVMGEPSetNoWrapFlags$descriptor() {
        return LLVMGEPSetNoWrapFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGEPSetNoWrapFlags(LLVMValueRef GEP, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MethodHandle LLVMGEPSetNoWrapFlags$handle() {
        return LLVMGEPSetNoWrapFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGEPSetNoWrapFlags(LLVMValueRef GEP, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MemorySegment LLVMGEPSetNoWrapFlags$address() {
        return LLVMGEPSetNoWrapFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGEPSetNoWrapFlags(LLVMValueRef GEP, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static void LLVMGEPSetNoWrapFlags(MemorySegment GEP, int NoWrapFlags) {
        var mh$ = LLVMGEPSetNoWrapFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGEPSetNoWrapFlags", GEP, NoWrapFlags);
            }
            mh$.invokeExact(GEP, NoWrapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddIncoming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddIncoming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues, LLVMBasicBlockRef *IncomingBlocks, unsigned int Count)
     * }
     */
    public static FunctionDescriptor LLVMAddIncoming$descriptor() {
        return LLVMAddIncoming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues, LLVMBasicBlockRef *IncomingBlocks, unsigned int Count)
     * }
     */
    public static MethodHandle LLVMAddIncoming$handle() {
        return LLVMAddIncoming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues, LLVMBasicBlockRef *IncomingBlocks, unsigned int Count)
     * }
     */
    public static MemorySegment LLVMAddIncoming$address() {
        return LLVMAddIncoming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddIncoming(LLVMValueRef PhiNode, LLVMValueRef *IncomingValues, LLVMBasicBlockRef *IncomingBlocks, unsigned int Count)
     * }
     */
    public static void LLVMAddIncoming(MemorySegment PhiNode, MemorySegment IncomingValues, MemorySegment IncomingBlocks, int Count) {
        var mh$ = LLVMAddIncoming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddIncoming", PhiNode, IncomingValues, IncomingBlocks, Count);
            }
            mh$.invokeExact(PhiNode, IncomingValues, IncomingBlocks, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCountIncoming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCountIncoming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMCountIncoming(LLVMValueRef PhiNode)
     * }
     */
    public static FunctionDescriptor LLVMCountIncoming$descriptor() {
        return LLVMCountIncoming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMCountIncoming(LLVMValueRef PhiNode)
     * }
     */
    public static MethodHandle LLVMCountIncoming$handle() {
        return LLVMCountIncoming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMCountIncoming(LLVMValueRef PhiNode)
     * }
     */
    public static MemorySegment LLVMCountIncoming$address() {
        return LLVMCountIncoming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMCountIncoming(LLVMValueRef PhiNode)
     * }
     */
    public static int LLVMCountIncoming(MemorySegment PhiNode) {
        var mh$ = LLVMCountIncoming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCountIncoming", PhiNode);
            }
            return (int)mh$.invokeExact(PhiNode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIncomingValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIncomingValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetIncomingValue$descriptor() {
        return LLVMGetIncomingValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetIncomingValue$handle() {
        return LLVMGetIncomingValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetIncomingValue$address() {
        return LLVMGetIncomingValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetIncomingValue(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetIncomingValue(MemorySegment PhiNode, int Index) {
        var mh$ = LLVMGetIncomingValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIncomingValue", PhiNode, Index);
            }
            return (MemorySegment)mh$.invokeExact(PhiNode, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIncomingBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIncomingBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static FunctionDescriptor LLVMGetIncomingBlock$descriptor() {
        return LLVMGetIncomingBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MethodHandle LLVMGetIncomingBlock$handle() {
        return LLVMGetIncomingBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetIncomingBlock$address() {
        return LLVMGetIncomingBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef PhiNode, unsigned int Index)
     * }
     */
    public static MemorySegment LLVMGetIncomingBlock(MemorySegment PhiNode, int Index) {
        var mh$ = LLVMGetIncomingBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIncomingBlock", PhiNode, Index);
            }
            return (MemorySegment)mh$.invokeExact(PhiNode, Index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumIndices(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetNumIndices$descriptor() {
        return LLVMGetNumIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumIndices(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetNumIndices$handle() {
        return LLVMGetNumIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumIndices(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetNumIndices$address() {
        return LLVMGetNumIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumIndices(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetNumIndices(MemorySegment Inst) {
        var mh$ = LLVMGetNumIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumIndices", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const unsigned int *LLVMGetIndices(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetIndices$descriptor() {
        return LLVMGetIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const unsigned int *LLVMGetIndices(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetIndices$handle() {
        return LLVMGetIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const unsigned int *LLVMGetIndices(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetIndices$address() {
        return LLVMGetIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const unsigned int *LLVMGetIndices(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetIndices(MemorySegment Inst) {
        var mh$ = LLVMGetIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIndices", Inst);
            }
            return (MemorySegment)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateBuilderInContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateBuilderInContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C)
     * }
     */
    public static FunctionDescriptor LLVMCreateBuilderInContext$descriptor() {
        return LLVMCreateBuilderInContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C)
     * }
     */
    public static MethodHandle LLVMCreateBuilderInContext$handle() {
        return LLVMCreateBuilderInContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMCreateBuilderInContext$address() {
        return LLVMCreateBuilderInContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef C)
     * }
     */
    public static MemorySegment LLVMCreateBuilderInContext(MemorySegment C) {
        var mh$ = LLVMCreateBuilderInContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateBuilderInContext", C);
            }
            return (MemorySegment)mh$.invokeExact(C);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateBuilder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateBuilder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilder()
     * }
     */
    public static FunctionDescriptor LLVMCreateBuilder$descriptor() {
        return LLVMCreateBuilder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilder()
     * }
     */
    public static MethodHandle LLVMCreateBuilder$handle() {
        return LLVMCreateBuilder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilder()
     * }
     */
    public static MemorySegment LLVMCreateBuilder$address() {
        return LLVMCreateBuilder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBuilderRef LLVMCreateBuilder()
     * }
     */
    public static MemorySegment LLVMCreateBuilder() {
        var mh$ = LLVMCreateBuilder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateBuilder");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilder$descriptor() {
        return LLVMPositionBuilder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMPositionBuilder$handle() {
        return LLVMPositionBuilder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMPositionBuilder$address() {
        return LLVMPositionBuilder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilder(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Instr)
     * }
     */
    public static void LLVMPositionBuilder(MemorySegment Builder, MemorySegment Block, MemorySegment Instr) {
        var mh$ = LLVMPositionBuilder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilder", Builder, Block, Instr);
            }
            mh$.invokeExact(Builder, Block, Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilderBeforeDbgRecords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilderBeforeDbgRecords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeDbgRecords(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilderBeforeDbgRecords$descriptor() {
        return LLVMPositionBuilderBeforeDbgRecords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeDbgRecords(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMPositionBuilderBeforeDbgRecords$handle() {
        return LLVMPositionBuilderBeforeDbgRecords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeDbgRecords(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMPositionBuilderBeforeDbgRecords$address() {
        return LLVMPositionBuilderBeforeDbgRecords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeDbgRecords(LLVMBuilderRef Builder, LLVMBasicBlockRef Block, LLVMValueRef Inst)
     * }
     */
    public static void LLVMPositionBuilderBeforeDbgRecords(MemorySegment Builder, MemorySegment Block, MemorySegment Inst) {
        var mh$ = LLVMPositionBuilderBeforeDbgRecords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilderBeforeDbgRecords", Builder, Block, Inst);
            }
            mh$.invokeExact(Builder, Block, Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilderBefore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilderBefore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilderBefore$descriptor() {
        return LLVMPositionBuilderBefore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMPositionBuilderBefore$handle() {
        return LLVMPositionBuilderBefore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMPositionBuilderBefore$address() {
        return LLVMPositionBuilderBefore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilderBefore(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static void LLVMPositionBuilderBefore(MemorySegment Builder, MemorySegment Instr) {
        var mh$ = LLVMPositionBuilderBefore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilderBefore", Builder, Instr);
            }
            mh$.invokeExact(Builder, Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilderBeforeInstrAndDbgRecords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilderBeforeInstrAndDbgRecords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilderBeforeInstrAndDbgRecords$descriptor() {
        return LLVMPositionBuilderBeforeInstrAndDbgRecords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMPositionBuilderBeforeInstrAndDbgRecords$handle() {
        return LLVMPositionBuilderBeforeInstrAndDbgRecords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMPositionBuilderBeforeInstrAndDbgRecords$address() {
        return LLVMPositionBuilderBeforeInstrAndDbgRecords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static void LLVMPositionBuilderBeforeInstrAndDbgRecords(MemorySegment Builder, MemorySegment Instr) {
        var mh$ = LLVMPositionBuilderBeforeInstrAndDbgRecords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilderBeforeInstrAndDbgRecords", Builder, Instr);
            }
            mh$.invokeExact(Builder, Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMPositionBuilderAtEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMPositionBuilderAtEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block)
     * }
     */
    public static FunctionDescriptor LLVMPositionBuilderAtEnd$descriptor() {
        return LLVMPositionBuilderAtEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block)
     * }
     */
    public static MethodHandle LLVMPositionBuilderAtEnd$handle() {
        return LLVMPositionBuilderAtEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block)
     * }
     */
    public static MemorySegment LLVMPositionBuilderAtEnd$address() {
        return LLVMPositionBuilderAtEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMPositionBuilderAtEnd(LLVMBuilderRef Builder, LLVMBasicBlockRef Block)
     * }
     */
    public static void LLVMPositionBuilderAtEnd(MemorySegment Builder, MemorySegment Block) {
        var mh$ = LLVMPositionBuilderAtEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMPositionBuilderAtEnd", Builder, Block);
            }
            mh$.invokeExact(Builder, Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetInsertBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetInsertBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMGetInsertBlock$descriptor() {
        return LLVMGetInsertBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMGetInsertBlock$handle() {
        return LLVMGetInsertBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetInsertBlock$address() {
        return LLVMGetInsertBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetInsertBlock(MemorySegment Builder) {
        var mh$ = LLVMGetInsertBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetInsertBlock", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMClearInsertionPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMClearInsertionPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMClearInsertionPosition(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMClearInsertionPosition$descriptor() {
        return LLVMClearInsertionPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMClearInsertionPosition(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMClearInsertionPosition$handle() {
        return LLVMClearInsertionPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMClearInsertionPosition(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMClearInsertionPosition$address() {
        return LLVMClearInsertionPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMClearInsertionPosition(LLVMBuilderRef Builder)
     * }
     */
    public static void LLVMClearInsertionPosition(MemorySegment Builder) {
        var mh$ = LLVMClearInsertionPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMClearInsertionPosition", Builder);
            }
            mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertIntoBuilder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertIntoBuilder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static FunctionDescriptor LLVMInsertIntoBuilder$descriptor() {
        return LLVMInsertIntoBuilder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MethodHandle LLVMInsertIntoBuilder$handle() {
        return LLVMInsertIntoBuilder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static MemorySegment LLVMInsertIntoBuilder$address() {
        return LLVMInsertIntoBuilder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilder(LLVMBuilderRef Builder, LLVMValueRef Instr)
     * }
     */
    public static void LLVMInsertIntoBuilder(MemorySegment Builder, MemorySegment Instr) {
        var mh$ = LLVMInsertIntoBuilder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertIntoBuilder", Builder, Instr);
            }
            mh$.invokeExact(Builder, Instr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInsertIntoBuilderWithName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInsertIntoBuilderWithName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMInsertIntoBuilderWithName$descriptor() {
        return LLVMInsertIntoBuilderWithName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr, const char *Name)
     * }
     */
    public static MethodHandle LLVMInsertIntoBuilderWithName$handle() {
        return LLVMInsertIntoBuilderWithName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr, const char *Name)
     * }
     */
    public static MemorySegment LLVMInsertIntoBuilderWithName$address() {
        return LLVMInsertIntoBuilderWithName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMInsertIntoBuilderWithName(LLVMBuilderRef Builder, LLVMValueRef Instr, const char *Name)
     * }
     */
    public static void LLVMInsertIntoBuilderWithName(MemorySegment Builder, MemorySegment Instr, MemorySegment Name) {
        var mh$ = LLVMInsertIntoBuilderWithName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInsertIntoBuilderWithName", Builder, Instr, Name);
            }
            mh$.invokeExact(Builder, Instr, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeBuilder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeBuilder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeBuilder(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMDisposeBuilder$descriptor() {
        return LLVMDisposeBuilder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeBuilder(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMDisposeBuilder$handle() {
        return LLVMDisposeBuilder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeBuilder(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMDisposeBuilder$address() {
        return LLVMDisposeBuilder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeBuilder(LLVMBuilderRef Builder)
     * }
     */
    public static void LLVMDisposeBuilder(MemorySegment Builder) {
        var mh$ = LLVMDisposeBuilder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeBuilder", Builder);
            }
            mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCurrentDebugLocation2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCurrentDebugLocation2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetCurrentDebugLocation2(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMGetCurrentDebugLocation2$descriptor() {
        return LLVMGetCurrentDebugLocation2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetCurrentDebugLocation2(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMGetCurrentDebugLocation2$handle() {
        return LLVMGetCurrentDebugLocation2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetCurrentDebugLocation2(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetCurrentDebugLocation2$address() {
        return LLVMGetCurrentDebugLocation2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMGetCurrentDebugLocation2(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetCurrentDebugLocation2(MemorySegment Builder) {
        var mh$ = LLVMGetCurrentDebugLocation2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCurrentDebugLocation2", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCurrentDebugLocation2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCurrentDebugLocation2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation2(LLVMBuilderRef Builder, LLVMMetadataRef Loc)
     * }
     */
    public static FunctionDescriptor LLVMSetCurrentDebugLocation2$descriptor() {
        return LLVMSetCurrentDebugLocation2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation2(LLVMBuilderRef Builder, LLVMMetadataRef Loc)
     * }
     */
    public static MethodHandle LLVMSetCurrentDebugLocation2$handle() {
        return LLVMSetCurrentDebugLocation2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation2(LLVMBuilderRef Builder, LLVMMetadataRef Loc)
     * }
     */
    public static MemorySegment LLVMSetCurrentDebugLocation2$address() {
        return LLVMSetCurrentDebugLocation2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation2(LLVMBuilderRef Builder, LLVMMetadataRef Loc)
     * }
     */
    public static void LLVMSetCurrentDebugLocation2(MemorySegment Builder, MemorySegment Loc) {
        var mh$ = LLVMSetCurrentDebugLocation2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCurrentDebugLocation2", Builder, Loc);
            }
            mh$.invokeExact(Builder, Loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetInstDebugLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetInstDebugLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMSetInstDebugLocation$descriptor() {
        return LLVMSetInstDebugLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMSetInstDebugLocation$handle() {
        return LLVMSetInstDebugLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMSetInstDebugLocation$address() {
        return LLVMSetInstDebugLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetInstDebugLocation(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static void LLVMSetInstDebugLocation(MemorySegment Builder, MemorySegment Inst) {
        var mh$ = LLVMSetInstDebugLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetInstDebugLocation", Builder, Inst);
            }
            mh$.invokeExact(Builder, Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddMetadataToInst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddMetadataToInst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddMetadataToInst(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMAddMetadataToInst$descriptor() {
        return LLVMAddMetadataToInst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddMetadataToInst(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMAddMetadataToInst$handle() {
        return LLVMAddMetadataToInst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddMetadataToInst(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMAddMetadataToInst$address() {
        return LLVMAddMetadataToInst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddMetadataToInst(LLVMBuilderRef Builder, LLVMValueRef Inst)
     * }
     */
    public static void LLVMAddMetadataToInst(MemorySegment Builder, MemorySegment Inst) {
        var mh$ = LLVMAddMetadataToInst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddMetadataToInst", Builder, Inst);
            }
            mh$.invokeExact(Builder, Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuilderGetDefaultFPMathTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuilderGetDefaultFPMathTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMBuilderGetDefaultFPMathTag(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMBuilderGetDefaultFPMathTag$descriptor() {
        return LLVMBuilderGetDefaultFPMathTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMBuilderGetDefaultFPMathTag(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMBuilderGetDefaultFPMathTag$handle() {
        return LLVMBuilderGetDefaultFPMathTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMBuilderGetDefaultFPMathTag(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMBuilderGetDefaultFPMathTag$address() {
        return LLVMBuilderGetDefaultFPMathTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMetadataRef LLVMBuilderGetDefaultFPMathTag(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMBuilderGetDefaultFPMathTag(MemorySegment Builder) {
        var mh$ = LLVMBuilderGetDefaultFPMathTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuilderGetDefaultFPMathTag", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuilderSetDefaultFPMathTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuilderSetDefaultFPMathTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMBuilderSetDefaultFPMathTag(LLVMBuilderRef Builder, LLVMMetadataRef FPMathTag)
     * }
     */
    public static FunctionDescriptor LLVMBuilderSetDefaultFPMathTag$descriptor() {
        return LLVMBuilderSetDefaultFPMathTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMBuilderSetDefaultFPMathTag(LLVMBuilderRef Builder, LLVMMetadataRef FPMathTag)
     * }
     */
    public static MethodHandle LLVMBuilderSetDefaultFPMathTag$handle() {
        return LLVMBuilderSetDefaultFPMathTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMBuilderSetDefaultFPMathTag(LLVMBuilderRef Builder, LLVMMetadataRef FPMathTag)
     * }
     */
    public static MemorySegment LLVMBuilderSetDefaultFPMathTag$address() {
        return LLVMBuilderSetDefaultFPMathTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMBuilderSetDefaultFPMathTag(LLVMBuilderRef Builder, LLVMMetadataRef FPMathTag)
     * }
     */
    public static void LLVMBuilderSetDefaultFPMathTag(MemorySegment Builder, MemorySegment FPMathTag) {
        var mh$ = LLVMBuilderSetDefaultFPMathTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuilderSetDefaultFPMathTag", Builder, FPMathTag);
            }
            mh$.invokeExact(Builder, FPMathTag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBuilderContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBuilderContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetBuilderContext(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMGetBuilderContext$descriptor() {
        return LLVMGetBuilderContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetBuilderContext(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMGetBuilderContext$handle() {
        return LLVMGetBuilderContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetBuilderContext(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetBuilderContext$address() {
        return LLVMGetBuilderContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMContextRef LLVMGetBuilderContext(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetBuilderContext(MemorySegment Builder) {
        var mh$ = LLVMGetBuilderContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBuilderContext", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCurrentDebugLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCurrentDebugLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L)
     * }
     */
    public static FunctionDescriptor LLVMSetCurrentDebugLocation$descriptor() {
        return LLVMSetCurrentDebugLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L)
     * }
     */
    public static MethodHandle LLVMSetCurrentDebugLocation$handle() {
        return LLVMSetCurrentDebugLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L)
     * }
     */
    public static MemorySegment LLVMSetCurrentDebugLocation$address() {
        return LLVMSetCurrentDebugLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCurrentDebugLocation(LLVMBuilderRef Builder, LLVMValueRef L)
     * }
     */
    public static void LLVMSetCurrentDebugLocation(MemorySegment Builder, MemorySegment L) {
        var mh$ = LLVMSetCurrentDebugLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCurrentDebugLocation", Builder, L);
            }
            mh$.invokeExact(Builder, L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCurrentDebugLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCurrentDebugLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder)
     * }
     */
    public static FunctionDescriptor LLVMGetCurrentDebugLocation$descriptor() {
        return LLVMGetCurrentDebugLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder)
     * }
     */
    public static MethodHandle LLVMGetCurrentDebugLocation$handle() {
        return LLVMGetCurrentDebugLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetCurrentDebugLocation$address() {
        return LLVMGetCurrentDebugLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef Builder)
     * }
     */
    public static MemorySegment LLVMGetCurrentDebugLocation(MemorySegment Builder) {
        var mh$ = LLVMGetCurrentDebugLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCurrentDebugLocation", Builder);
            }
            return (MemorySegment)mh$.invokeExact(Builder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildRetVoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildRetVoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)
     * }
     */
    public static FunctionDescriptor LLVMBuildRetVoid$descriptor() {
        return LLVMBuildRetVoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)
     * }
     */
    public static MethodHandle LLVMBuildRetVoid$handle() {
        return LLVMBuildRetVoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)
     * }
     */
    public static MemorySegment LLVMBuildRetVoid$address() {
        return LLVMBuildRetVoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)
     * }
     */
    public static MemorySegment LLVMBuildRetVoid(MemorySegment x0) {
        var mh$ = LLVMBuildRetVoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildRetVoid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildRet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildRet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V)
     * }
     */
    public static FunctionDescriptor LLVMBuildRet$descriptor() {
        return LLVMBuildRet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V)
     * }
     */
    public static MethodHandle LLVMBuildRet$handle() {
        return LLVMBuildRet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V)
     * }
     */
    public static MemorySegment LLVMBuildRet$address() {
        return LLVMBuildRet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef V)
     * }
     */
    public static MemorySegment LLVMBuildRet(MemorySegment x0, MemorySegment V) {
        var mh$ = LLVMBuildRet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildRet", x0, V);
            }
            return (MemorySegment)mh$.invokeExact(x0, V);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAggregateRet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAggregateRet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals, unsigned int N)
     * }
     */
    public static FunctionDescriptor LLVMBuildAggregateRet$descriptor() {
        return LLVMBuildAggregateRet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals, unsigned int N)
     * }
     */
    public static MethodHandle LLVMBuildAggregateRet$handle() {
        return LLVMBuildAggregateRet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals, unsigned int N)
     * }
     */
    public static MemorySegment LLVMBuildAggregateRet$address() {
        return LLVMBuildAggregateRet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef *RetVals, unsigned int N)
     * }
     */
    public static MemorySegment LLVMBuildAggregateRet(MemorySegment x0, MemorySegment RetVals, int N) {
        var mh$ = LLVMBuildAggregateRet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAggregateRet", x0, RetVals, N);
            }
            return (MemorySegment)mh$.invokeExact(x0, RetVals, N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildBr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildBr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest)
     * }
     */
    public static FunctionDescriptor LLVMBuildBr$descriptor() {
        return LLVMBuildBr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest)
     * }
     */
    public static MethodHandle LLVMBuildBr$handle() {
        return LLVMBuildBr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMBuildBr$address() {
        return LLVMBuildBr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMBuildBr(MemorySegment x0, MemorySegment Dest) {
        var mh$ = LLVMBuildBr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildBr", x0, Dest);
            }
            return (MemorySegment)mh$.invokeExact(x0, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCondBr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCondBr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else)
     * }
     */
    public static FunctionDescriptor LLVMBuildCondBr$descriptor() {
        return LLVMBuildCondBr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else)
     * }
     */
    public static MethodHandle LLVMBuildCondBr$handle() {
        return LLVMBuildCondBr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else)
     * }
     */
    public static MemorySegment LLVMBuildCondBr$address() {
        return LLVMBuildCondBr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef If, LLVMBasicBlockRef Then, LLVMBasicBlockRef Else)
     * }
     */
    public static MemorySegment LLVMBuildCondBr(MemorySegment x0, MemorySegment If, MemorySegment Then, MemorySegment Else) {
        var mh$ = LLVMBuildCondBr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCondBr", x0, If, Then, Else);
            }
            return (MemorySegment)mh$.invokeExact(x0, If, Then, Else);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSwitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSwitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V, LLVMBasicBlockRef Else, unsigned int NumCases)
     * }
     */
    public static FunctionDescriptor LLVMBuildSwitch$descriptor() {
        return LLVMBuildSwitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V, LLVMBasicBlockRef Else, unsigned int NumCases)
     * }
     */
    public static MethodHandle LLVMBuildSwitch$handle() {
        return LLVMBuildSwitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V, LLVMBasicBlockRef Else, unsigned int NumCases)
     * }
     */
    public static MemorySegment LLVMBuildSwitch$address() {
        return LLVMBuildSwitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef V, LLVMBasicBlockRef Else, unsigned int NumCases)
     * }
     */
    public static MemorySegment LLVMBuildSwitch(MemorySegment x0, MemorySegment V, MemorySegment Else, int NumCases) {
        var mh$ = LLVMBuildSwitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSwitch", x0, V, Else, NumCases);
            }
            return (MemorySegment)mh$.invokeExact(x0, V, Else, NumCases);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIndirectBr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIndirectBr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr, unsigned int NumDests)
     * }
     */
    public static FunctionDescriptor LLVMBuildIndirectBr$descriptor() {
        return LLVMBuildIndirectBr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr, unsigned int NumDests)
     * }
     */
    public static MethodHandle LLVMBuildIndirectBr$handle() {
        return LLVMBuildIndirectBr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr, unsigned int NumDests)
     * }
     */
    public static MemorySegment LLVMBuildIndirectBr$address() {
        return LLVMBuildIndirectBr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef B, LLVMValueRef Addr, unsigned int NumDests)
     * }
     */
    public static MemorySegment LLVMBuildIndirectBr(MemorySegment B, MemorySegment Addr, int NumDests) {
        var mh$ = LLVMBuildIndirectBr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIndirectBr", B, Addr, NumDests);
            }
            return (MemorySegment)mh$.invokeExact(B, Addr, NumDests);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCallBr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCallBr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallBr(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMBasicBlockRef DefaultDest, LLVMBasicBlockRef *IndirectDests, unsigned int NumIndirectDests, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCallBr$descriptor() {
        return LLVMBuildCallBr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallBr(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMBasicBlockRef DefaultDest, LLVMBasicBlockRef *IndirectDests, unsigned int NumIndirectDests, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCallBr$handle() {
        return LLVMBuildCallBr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallBr(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMBasicBlockRef DefaultDest, LLVMBasicBlockRef *IndirectDests, unsigned int NumIndirectDests, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCallBr$address() {
        return LLVMBuildCallBr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallBr(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMBasicBlockRef DefaultDest, LLVMBasicBlockRef *IndirectDests, unsigned int NumIndirectDests, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCallBr(MemorySegment B, MemorySegment Ty, MemorySegment Fn, MemorySegment DefaultDest, MemorySegment IndirectDests, int NumIndirectDests, MemorySegment Args, int NumArgs, MemorySegment Bundles, int NumBundles, MemorySegment Name) {
        var mh$ = LLVMBuildCallBr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCallBr", B, Ty, Fn, DefaultDest, IndirectDests, NumIndirectDests, Args, NumArgs, Bundles, NumBundles, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Fn, DefaultDest, IndirectDests, NumIndirectDests, Args, NumArgs, Bundles, NumBundles, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInvoke2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInvoke2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvoke2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInvoke2$descriptor() {
        return LLVMBuildInvoke2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvoke2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInvoke2$handle() {
        return LLVMBuildInvoke2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvoke2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInvoke2$address() {
        return LLVMBuildInvoke2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvoke2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInvoke2(MemorySegment x0, MemorySegment Ty, MemorySegment Fn, MemorySegment Args, int NumArgs, MemorySegment Then, MemorySegment Catch, MemorySegment Name) {
        var mh$ = LLVMBuildInvoke2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInvoke2", x0, Ty, Fn, Args, NumArgs, Then, Catch, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Fn, Args, NumArgs, Then, Catch, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInvokeWithOperandBundles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInvokeWithOperandBundles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvokeWithOperandBundles(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInvokeWithOperandBundles$descriptor() {
        return LLVMBuildInvokeWithOperandBundles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvokeWithOperandBundles(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInvokeWithOperandBundles$handle() {
        return LLVMBuildInvokeWithOperandBundles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvokeWithOperandBundles(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInvokeWithOperandBundles$address() {
        return LLVMBuildInvokeWithOperandBundles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInvokeWithOperandBundles(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInvokeWithOperandBundles(MemorySegment x0, MemorySegment Ty, MemorySegment Fn, MemorySegment Args, int NumArgs, MemorySegment Then, MemorySegment Catch, MemorySegment Bundles, int NumBundles, MemorySegment Name) {
        var mh$ = LLVMBuildInvokeWithOperandBundles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInvokeWithOperandBundles", x0, Ty, Fn, Args, NumArgs, Then, Catch, Bundles, NumBundles, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Fn, Args, NumArgs, Then, Catch, Bundles, NumBundles, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildUnreachable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildUnreachable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)
     * }
     */
    public static FunctionDescriptor LLVMBuildUnreachable$descriptor() {
        return LLVMBuildUnreachable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)
     * }
     */
    public static MethodHandle LLVMBuildUnreachable$handle() {
        return LLVMBuildUnreachable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)
     * }
     */
    public static MemorySegment LLVMBuildUnreachable$address() {
        return LLVMBuildUnreachable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)
     * }
     */
    public static MemorySegment LLVMBuildUnreachable(MemorySegment x0) {
        var mh$ = LLVMBuildUnreachable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildUnreachable", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildResume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildResume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn)
     * }
     */
    public static FunctionDescriptor LLVMBuildResume$descriptor() {
        return LLVMBuildResume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn)
     * }
     */
    public static MethodHandle LLVMBuildResume$handle() {
        return LLVMBuildResume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn)
     * }
     */
    public static MemorySegment LLVMBuildResume$address() {
        return LLVMBuildResume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildResume(LLVMBuilderRef B, LLVMValueRef Exn)
     * }
     */
    public static MemorySegment LLVMBuildResume(MemorySegment B, MemorySegment Exn) {
        var mh$ = LLVMBuildResume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildResume", B, Exn);
            }
            return (MemorySegment)mh$.invokeExact(B, Exn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildLandingPad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildLandingPad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, unsigned int NumClauses, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildLandingPad$descriptor() {
        return LLVMBuildLandingPad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, unsigned int NumClauses, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildLandingPad$handle() {
        return LLVMBuildLandingPad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, unsigned int NumClauses, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLandingPad$address() {
        return LLVMBuildLandingPad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef PersFn, unsigned int NumClauses, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLandingPad(MemorySegment B, MemorySegment Ty, MemorySegment PersFn, int NumClauses, MemorySegment Name) {
        var mh$ = LLVMBuildLandingPad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildLandingPad", B, Ty, PersFn, NumClauses, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, PersFn, NumClauses, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCleanupRet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCleanupRet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMBuildCleanupRet$descriptor() {
        return LLVMBuildCleanupRet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMBuildCleanupRet$handle() {
        return LLVMBuildCleanupRet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBuildCleanupRet$address() {
        return LLVMBuildCleanupRet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBuildCleanupRet(MemorySegment B, MemorySegment CatchPad, MemorySegment BB) {
        var mh$ = LLVMBuildCleanupRet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCleanupRet", B, CatchPad, BB);
            }
            return (MemorySegment)mh$.invokeExact(B, CatchPad, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCatchRet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCatchRet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static FunctionDescriptor LLVMBuildCatchRet$descriptor() {
        return LLVMBuildCatchRet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MethodHandle LLVMBuildCatchRet$handle() {
        return LLVMBuildCatchRet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBuildCatchRet$address() {
        return LLVMBuildCatchRet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchRet(LLVMBuilderRef B, LLVMValueRef CatchPad, LLVMBasicBlockRef BB)
     * }
     */
    public static MemorySegment LLVMBuildCatchRet(MemorySegment B, MemorySegment CatchPad, MemorySegment BB) {
        var mh$ = LLVMBuildCatchRet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCatchRet", B, CatchPad, BB);
            }
            return (MemorySegment)mh$.invokeExact(B, CatchPad, BB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCatchPad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCatchPad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCatchPad$descriptor() {
        return LLVMBuildCatchPad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCatchPad$handle() {
        return LLVMBuildCatchPad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCatchPad$address() {
        return LLVMBuildCatchPad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCatchPad(MemorySegment B, MemorySegment ParentPad, MemorySegment Args, int NumArgs, MemorySegment Name) {
        var mh$ = LLVMBuildCatchPad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCatchPad", B, ParentPad, Args, NumArgs, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ParentPad, Args, NumArgs, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCleanupPad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCleanupPad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCleanupPad$descriptor() {
        return LLVMBuildCleanupPad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCleanupPad$handle() {
        return LLVMBuildCleanupPad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCleanupPad$address() {
        return LLVMBuildCleanupPad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCleanupPad(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCleanupPad(MemorySegment B, MemorySegment ParentPad, MemorySegment Args, int NumArgs, MemorySegment Name) {
        var mh$ = LLVMBuildCleanupPad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCleanupPad", B, ParentPad, Args, NumArgs, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ParentPad, Args, NumArgs, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCatchSwitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCatchSwitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchSwitch(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, unsigned int NumHandlers, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCatchSwitch$descriptor() {
        return LLVMBuildCatchSwitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchSwitch(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, unsigned int NumHandlers, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCatchSwitch$handle() {
        return LLVMBuildCatchSwitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchSwitch(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, unsigned int NumHandlers, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCatchSwitch$address() {
        return LLVMBuildCatchSwitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCatchSwitch(LLVMBuilderRef B, LLVMValueRef ParentPad, LLVMBasicBlockRef UnwindBB, unsigned int NumHandlers, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCatchSwitch(MemorySegment B, MemorySegment ParentPad, MemorySegment UnwindBB, int NumHandlers, MemorySegment Name) {
        var mh$ = LLVMBuildCatchSwitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCatchSwitch", B, ParentPad, UnwindBB, NumHandlers, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ParentPad, UnwindBB, NumHandlers, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddCase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddCase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest)
     * }
     */
    public static FunctionDescriptor LLVMAddCase$descriptor() {
        return LLVMAddCase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest)
     * }
     */
    public static MethodHandle LLVMAddCase$handle() {
        return LLVMAddCase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMAddCase$address() {
        return LLVMAddCase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddCase(LLVMValueRef Switch, LLVMValueRef OnVal, LLVMBasicBlockRef Dest)
     * }
     */
    public static void LLVMAddCase(MemorySegment Switch, MemorySegment OnVal, MemorySegment Dest) {
        var mh$ = LLVMAddCase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddCase", Switch, OnVal, Dest);
            }
            mh$.invokeExact(Switch, OnVal, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddDestination {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddDestination");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest)
     * }
     */
    public static FunctionDescriptor LLVMAddDestination$descriptor() {
        return LLVMAddDestination.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest)
     * }
     */
    public static MethodHandle LLVMAddDestination$handle() {
        return LLVMAddDestination.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMAddDestination$address() {
        return LLVMAddDestination.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddDestination(LLVMValueRef IndirectBr, LLVMBasicBlockRef Dest)
     * }
     */
    public static void LLVMAddDestination(MemorySegment IndirectBr, MemorySegment Dest) {
        var mh$ = LLVMAddDestination.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddDestination", IndirectBr, Dest);
            }
            mh$.invokeExact(IndirectBr, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumClauses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumClauses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumClauses(LLVMValueRef LandingPad)
     * }
     */
    public static FunctionDescriptor LLVMGetNumClauses$descriptor() {
        return LLVMGetNumClauses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumClauses(LLVMValueRef LandingPad)
     * }
     */
    public static MethodHandle LLVMGetNumClauses$handle() {
        return LLVMGetNumClauses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumClauses(LLVMValueRef LandingPad)
     * }
     */
    public static MemorySegment LLVMGetNumClauses$address() {
        return LLVMGetNumClauses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumClauses(LLVMValueRef LandingPad)
     * }
     */
    public static int LLVMGetNumClauses(MemorySegment LandingPad) {
        var mh$ = LLVMGetNumClauses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumClauses", LandingPad);
            }
            return (int)mh$.invokeExact(LandingPad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetClause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetClause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned int Idx)
     * }
     */
    public static FunctionDescriptor LLVMGetClause$descriptor() {
        return LLVMGetClause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned int Idx)
     * }
     */
    public static MethodHandle LLVMGetClause$handle() {
        return LLVMGetClause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetClause$address() {
        return LLVMGetClause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetClause(LLVMValueRef LandingPad, unsigned int Idx)
     * }
     */
    public static MemorySegment LLVMGetClause(MemorySegment LandingPad, int Idx) {
        var mh$ = LLVMGetClause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetClause", LandingPad, Idx);
            }
            return (MemorySegment)mh$.invokeExact(LandingPad, Idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddClause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddClause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal)
     * }
     */
    public static FunctionDescriptor LLVMAddClause$descriptor() {
        return LLVMAddClause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal)
     * }
     */
    public static MethodHandle LLVMAddClause$handle() {
        return LLVMAddClause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal)
     * }
     */
    public static MemorySegment LLVMAddClause$address() {
        return LLVMAddClause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddClause(LLVMValueRef LandingPad, LLVMValueRef ClauseVal)
     * }
     */
    public static void LLVMAddClause(MemorySegment LandingPad, MemorySegment ClauseVal) {
        var mh$ = LLVMAddClause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddClause", LandingPad, ClauseVal);
            }
            mh$.invokeExact(LandingPad, ClauseVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsCleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsCleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad)
     * }
     */
    public static FunctionDescriptor LLVMIsCleanup$descriptor() {
        return LLVMIsCleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad)
     * }
     */
    public static MethodHandle LLVMIsCleanup$handle() {
        return LLVMIsCleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad)
     * }
     */
    public static MemorySegment LLVMIsCleanup$address() {
        return LLVMIsCleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsCleanup(LLVMValueRef LandingPad)
     * }
     */
    public static int LLVMIsCleanup(MemorySegment LandingPad) {
        var mh$ = LLVMIsCleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsCleanup", LandingPad);
            }
            return (int)mh$.invokeExact(LandingPad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val)
     * }
     */
    public static FunctionDescriptor LLVMSetCleanup$descriptor() {
        return LLVMSetCleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val)
     * }
     */
    public static MethodHandle LLVMSetCleanup$handle() {
        return LLVMSetCleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val)
     * }
     */
    public static MemorySegment LLVMSetCleanup$address() {
        return LLVMSetCleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCleanup(LLVMValueRef LandingPad, LLVMBool Val)
     * }
     */
    public static void LLVMSetCleanup(MemorySegment LandingPad, int Val) {
        var mh$ = LLVMSetCleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCleanup", LandingPad, Val);
            }
            mh$.invokeExact(LandingPad, Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMAddHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMAddHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMAddHandler(LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest)
     * }
     */
    public static FunctionDescriptor LLVMAddHandler$descriptor() {
        return LLVMAddHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMAddHandler(LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest)
     * }
     */
    public static MethodHandle LLVMAddHandler$handle() {
        return LLVMAddHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMAddHandler(LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest)
     * }
     */
    public static MemorySegment LLVMAddHandler$address() {
        return LLVMAddHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMAddHandler(LLVMValueRef CatchSwitch, LLVMBasicBlockRef Dest)
     * }
     */
    public static void LLVMAddHandler(MemorySegment CatchSwitch, MemorySegment Dest) {
        var mh$ = LLVMAddHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMAddHandler", CatchSwitch, Dest);
            }
            mh$.invokeExact(CatchSwitch, Dest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumHandlers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumHandlers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumHandlers(LLVMValueRef CatchSwitch)
     * }
     */
    public static FunctionDescriptor LLVMGetNumHandlers$descriptor() {
        return LLVMGetNumHandlers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumHandlers(LLVMValueRef CatchSwitch)
     * }
     */
    public static MethodHandle LLVMGetNumHandlers$handle() {
        return LLVMGetNumHandlers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumHandlers(LLVMValueRef CatchSwitch)
     * }
     */
    public static MemorySegment LLVMGetNumHandlers$address() {
        return LLVMGetNumHandlers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumHandlers(LLVMValueRef CatchSwitch)
     * }
     */
    public static int LLVMGetNumHandlers(MemorySegment CatchSwitch) {
        var mh$ = LLVMGetNumHandlers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumHandlers", CatchSwitch);
            }
            return (int)mh$.invokeExact(CatchSwitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetHandlers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetHandlers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMGetHandlers(LLVMValueRef CatchSwitch, LLVMBasicBlockRef *Handlers)
     * }
     */
    public static FunctionDescriptor LLVMGetHandlers$descriptor() {
        return LLVMGetHandlers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMGetHandlers(LLVMValueRef CatchSwitch, LLVMBasicBlockRef *Handlers)
     * }
     */
    public static MethodHandle LLVMGetHandlers$handle() {
        return LLVMGetHandlers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMGetHandlers(LLVMValueRef CatchSwitch, LLVMBasicBlockRef *Handlers)
     * }
     */
    public static MemorySegment LLVMGetHandlers$address() {
        return LLVMGetHandlers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMGetHandlers(LLVMValueRef CatchSwitch, LLVMBasicBlockRef *Handlers)
     * }
     */
    public static void LLVMGetHandlers(MemorySegment CatchSwitch, MemorySegment Handlers) {
        var mh$ = LLVMGetHandlers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetHandlers", CatchSwitch, Handlers);
            }
            mh$.invokeExact(CatchSwitch, Handlers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetArgOperand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetArgOperand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetArgOperand(LLVMValueRef Funclet, unsigned int i)
     * }
     */
    public static FunctionDescriptor LLVMGetArgOperand$descriptor() {
        return LLVMGetArgOperand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetArgOperand(LLVMValueRef Funclet, unsigned int i)
     * }
     */
    public static MethodHandle LLVMGetArgOperand$handle() {
        return LLVMGetArgOperand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetArgOperand(LLVMValueRef Funclet, unsigned int i)
     * }
     */
    public static MemorySegment LLVMGetArgOperand$address() {
        return LLVMGetArgOperand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetArgOperand(LLVMValueRef Funclet, unsigned int i)
     * }
     */
    public static MemorySegment LLVMGetArgOperand(MemorySegment Funclet, int i) {
        var mh$ = LLVMGetArgOperand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetArgOperand", Funclet, i);
            }
            return (MemorySegment)mh$.invokeExact(Funclet, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetArgOperand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetArgOperand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetArgOperand(LLVMValueRef Funclet, unsigned int i, LLVMValueRef value)
     * }
     */
    public static FunctionDescriptor LLVMSetArgOperand$descriptor() {
        return LLVMSetArgOperand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetArgOperand(LLVMValueRef Funclet, unsigned int i, LLVMValueRef value)
     * }
     */
    public static MethodHandle LLVMSetArgOperand$handle() {
        return LLVMSetArgOperand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetArgOperand(LLVMValueRef Funclet, unsigned int i, LLVMValueRef value)
     * }
     */
    public static MemorySegment LLVMSetArgOperand$address() {
        return LLVMSetArgOperand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetArgOperand(LLVMValueRef Funclet, unsigned int i, LLVMValueRef value)
     * }
     */
    public static void LLVMSetArgOperand(MemorySegment Funclet, int i, MemorySegment value) {
        var mh$ = LLVMSetArgOperand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetArgOperand", Funclet, i, value);
            }
            mh$.invokeExact(Funclet, i, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetParentCatchSwitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetParentCatchSwitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParentCatchSwitch(LLVMValueRef CatchPad)
     * }
     */
    public static FunctionDescriptor LLVMGetParentCatchSwitch$descriptor() {
        return LLVMGetParentCatchSwitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParentCatchSwitch(LLVMValueRef CatchPad)
     * }
     */
    public static MethodHandle LLVMGetParentCatchSwitch$handle() {
        return LLVMGetParentCatchSwitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParentCatchSwitch(LLVMValueRef CatchPad)
     * }
     */
    public static MemorySegment LLVMGetParentCatchSwitch$address() {
        return LLVMGetParentCatchSwitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMGetParentCatchSwitch(LLVMValueRef CatchPad)
     * }
     */
    public static MemorySegment LLVMGetParentCatchSwitch(MemorySegment CatchPad) {
        var mh$ = LLVMGetParentCatchSwitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetParentCatchSwitch", CatchPad);
            }
            return (MemorySegment)mh$.invokeExact(CatchPad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetParentCatchSwitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetParentCatchSwitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetParentCatchSwitch(LLVMValueRef CatchPad, LLVMValueRef CatchSwitch)
     * }
     */
    public static FunctionDescriptor LLVMSetParentCatchSwitch$descriptor() {
        return LLVMSetParentCatchSwitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetParentCatchSwitch(LLVMValueRef CatchPad, LLVMValueRef CatchSwitch)
     * }
     */
    public static MethodHandle LLVMSetParentCatchSwitch$handle() {
        return LLVMSetParentCatchSwitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetParentCatchSwitch(LLVMValueRef CatchPad, LLVMValueRef CatchSwitch)
     * }
     */
    public static MemorySegment LLVMSetParentCatchSwitch$address() {
        return LLVMSetParentCatchSwitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetParentCatchSwitch(LLVMValueRef CatchPad, LLVMValueRef CatchSwitch)
     * }
     */
    public static void LLVMSetParentCatchSwitch(MemorySegment CatchPad, MemorySegment CatchSwitch) {
        var mh$ = LLVMSetParentCatchSwitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetParentCatchSwitch", CatchPad, CatchSwitch);
            }
            mh$.invokeExact(CatchPad, CatchSwitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAdd$descriptor() {
        return LLVMBuildAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAdd$handle() {
        return LLVMBuildAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAdd$address() {
        return LLVMBuildAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAdd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAdd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNSWAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNSWAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNSWAdd$descriptor() {
        return LLVMBuildNSWAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNSWAdd$handle() {
        return LLVMBuildNSWAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWAdd$address() {
        return LLVMBuildNSWAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWAdd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNSWAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNSWAdd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNUWAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNUWAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNUWAdd$descriptor() {
        return LLVMBuildNUWAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNUWAdd$handle() {
        return LLVMBuildNUWAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWAdd$address() {
        return LLVMBuildNUWAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWAdd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNUWAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNUWAdd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFAdd$descriptor() {
        return LLVMBuildFAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFAdd$handle() {
        return LLVMBuildFAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFAdd$address() {
        return LLVMBuildFAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFAdd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFAdd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSub$descriptor() {
        return LLVMBuildSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSub$handle() {
        return LLVMBuildSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSub$address() {
        return LLVMBuildSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSub(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSub", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNSWSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNSWSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNSWSub$descriptor() {
        return LLVMBuildNSWSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNSWSub$handle() {
        return LLVMBuildNSWSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWSub$address() {
        return LLVMBuildNSWSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWSub(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNSWSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNSWSub", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNUWSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNUWSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNUWSub$descriptor() {
        return LLVMBuildNUWSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNUWSub$handle() {
        return LLVMBuildNUWSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWSub$address() {
        return LLVMBuildNUWSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWSub(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNUWSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNUWSub", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFSub$descriptor() {
        return LLVMBuildFSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFSub$handle() {
        return LLVMBuildFSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFSub$address() {
        return LLVMBuildFSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFSub(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFSub", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildMul$descriptor() {
        return LLVMBuildMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildMul$handle() {
        return LLVMBuildMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildMul$address() {
        return LLVMBuildMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildMul(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMul", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNSWMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNSWMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNSWMul$descriptor() {
        return LLVMBuildNSWMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNSWMul$handle() {
        return LLVMBuildNSWMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWMul$address() {
        return LLVMBuildNSWMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWMul(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNSWMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNSWMul", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNUWMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNUWMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNUWMul$descriptor() {
        return LLVMBuildNUWMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNUWMul$handle() {
        return LLVMBuildNUWMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWMul$address() {
        return LLVMBuildNUWMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWMul(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildNUWMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNUWMul", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFMul$descriptor() {
        return LLVMBuildFMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFMul$handle() {
        return LLVMBuildFMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFMul$address() {
        return LLVMBuildFMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFMul(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFMul", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildUDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildUDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildUDiv$descriptor() {
        return LLVMBuildUDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildUDiv$handle() {
        return LLVMBuildUDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildUDiv$address() {
        return LLVMBuildUDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildUDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildUDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildUDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildExactUDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildExactUDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildExactUDiv$descriptor() {
        return LLVMBuildExactUDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildExactUDiv$handle() {
        return LLVMBuildExactUDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExactUDiv$address() {
        return LLVMBuildExactUDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactUDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExactUDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildExactUDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildExactUDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSDiv$descriptor() {
        return LLVMBuildSDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSDiv$handle() {
        return LLVMBuildSDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSDiv$address() {
        return LLVMBuildSDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildSDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildExactSDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildExactSDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildExactSDiv$descriptor() {
        return LLVMBuildExactSDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildExactSDiv$handle() {
        return LLVMBuildExactSDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExactSDiv$address() {
        return LLVMBuildExactSDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExactSDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildExactSDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildExactSDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFDiv$descriptor() {
        return LLVMBuildFDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFDiv$handle() {
        return LLVMBuildFDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFDiv$address() {
        return LLVMBuildFDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFDiv(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFDiv", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildURem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildURem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildURem$descriptor() {
        return LLVMBuildURem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildURem$handle() {
        return LLVMBuildURem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildURem$address() {
        return LLVMBuildURem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildURem(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildURem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildURem", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSRem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSRem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSRem$descriptor() {
        return LLVMBuildSRem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSRem$handle() {
        return LLVMBuildSRem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSRem$address() {
        return LLVMBuildSRem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSRem(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildSRem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSRem", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFRem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFRem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFRem$descriptor() {
        return LLVMBuildFRem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFRem$handle() {
        return LLVMBuildFRem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFRem$address() {
        return LLVMBuildFRem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFRem(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFRem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFRem", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildShl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildShl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildShl$descriptor() {
        return LLVMBuildShl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildShl$handle() {
        return LLVMBuildShl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildShl$address() {
        return LLVMBuildShl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildShl(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildShl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildShl", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildLShr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildLShr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildLShr$descriptor() {
        return LLVMBuildLShr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildLShr$handle() {
        return LLVMBuildLShr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLShr$address() {
        return LLVMBuildLShr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLShr(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildLShr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildLShr", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAShr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAShr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAShr$descriptor() {
        return LLVMBuildAShr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAShr$handle() {
        return LLVMBuildAShr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAShr$address() {
        return LLVMBuildAShr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAShr(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildAShr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAShr", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAnd$descriptor() {
        return LLVMBuildAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAnd$handle() {
        return LLVMBuildAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAnd$address() {
        return LLVMBuildAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAnd(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAnd", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildOr$descriptor() {
        return LLVMBuildOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildOr$handle() {
        return LLVMBuildOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildOr$address() {
        return LLVMBuildOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildOr(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildOr", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildXor$descriptor() {
        return LLVMBuildXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildXor$handle() {
        return LLVMBuildXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildXor$address() {
        return LLVMBuildXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildXor(MemorySegment x0, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildXor", x0, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildBinOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildBinOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildBinOp$descriptor() {
        return LLVMBuildBinOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildBinOp$handle() {
        return LLVMBuildBinOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildBinOp$address() {
        return LLVMBuildBinOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildBinOp(MemorySegment B, int Op, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildBinOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildBinOp", B, Op, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Op, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNeg$descriptor() {
        return LLVMBuildNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNeg$handle() {
        return LLVMBuildNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNeg$address() {
        return LLVMBuildNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNeg(MemorySegment x0, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNeg", x0, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNSWNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNSWNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNSWNeg$descriptor() {
        return LLVMBuildNSWNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNSWNeg$handle() {
        return LLVMBuildNSWNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWNeg$address() {
        return LLVMBuildNSWNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNSWNeg(MemorySegment B, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildNSWNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNSWNeg", B, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNUWNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNUWNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNUWNeg$descriptor() {
        return LLVMBuildNUWNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNUWNeg$handle() {
        return LLVMBuildNUWNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWNeg$address() {
        return LLVMBuildNUWNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef B, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNUWNeg(MemorySegment B, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildNUWNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNUWNeg", B, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFNeg$descriptor() {
        return LLVMBuildFNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFNeg$handle() {
        return LLVMBuildFNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFNeg$address() {
        return LLVMBuildFNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFNeg(MemorySegment x0, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildFNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFNeg", x0, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildNot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildNot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildNot$descriptor() {
        return LLVMBuildNot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildNot$handle() {
        return LLVMBuildNot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNot$address() {
        return LLVMBuildNot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef V, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildNot(MemorySegment x0, MemorySegment V, MemorySegment Name) {
        var mh$ = LLVMBuildNot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildNot", x0, V, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, V, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNUW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNUW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNUW(LLVMValueRef ArithInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNUW$descriptor() {
        return LLVMGetNUW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNUW(LLVMValueRef ArithInst)
     * }
     */
    public static MethodHandle LLVMGetNUW$handle() {
        return LLVMGetNUW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNUW(LLVMValueRef ArithInst)
     * }
     */
    public static MemorySegment LLVMGetNUW$address() {
        return LLVMGetNUW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetNUW(LLVMValueRef ArithInst)
     * }
     */
    public static int LLVMGetNUW(MemorySegment ArithInst) {
        var mh$ = LLVMGetNUW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNUW", ArithInst);
            }
            return (int)mh$.invokeExact(ArithInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetNUW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetNUW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetNUW(LLVMValueRef ArithInst, LLVMBool HasNUW)
     * }
     */
    public static FunctionDescriptor LLVMSetNUW$descriptor() {
        return LLVMSetNUW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetNUW(LLVMValueRef ArithInst, LLVMBool HasNUW)
     * }
     */
    public static MethodHandle LLVMSetNUW$handle() {
        return LLVMSetNUW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetNUW(LLVMValueRef ArithInst, LLVMBool HasNUW)
     * }
     */
    public static MemorySegment LLVMSetNUW$address() {
        return LLVMSetNUW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetNUW(LLVMValueRef ArithInst, LLVMBool HasNUW)
     * }
     */
    public static void LLVMSetNUW(MemorySegment ArithInst, int HasNUW) {
        var mh$ = LLVMSetNUW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetNUW", ArithInst, HasNUW);
            }
            mh$.invokeExact(ArithInst, HasNUW);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNSW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNSW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNSW(LLVMValueRef ArithInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNSW$descriptor() {
        return LLVMGetNSW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNSW(LLVMValueRef ArithInst)
     * }
     */
    public static MethodHandle LLVMGetNSW$handle() {
        return LLVMGetNSW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNSW(LLVMValueRef ArithInst)
     * }
     */
    public static MemorySegment LLVMGetNSW$address() {
        return LLVMGetNSW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetNSW(LLVMValueRef ArithInst)
     * }
     */
    public static int LLVMGetNSW(MemorySegment ArithInst) {
        var mh$ = LLVMGetNSW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNSW", ArithInst);
            }
            return (int)mh$.invokeExact(ArithInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetNSW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetNSW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetNSW(LLVMValueRef ArithInst, LLVMBool HasNSW)
     * }
     */
    public static FunctionDescriptor LLVMSetNSW$descriptor() {
        return LLVMSetNSW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetNSW(LLVMValueRef ArithInst, LLVMBool HasNSW)
     * }
     */
    public static MethodHandle LLVMSetNSW$handle() {
        return LLVMSetNSW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetNSW(LLVMValueRef ArithInst, LLVMBool HasNSW)
     * }
     */
    public static MemorySegment LLVMSetNSW$address() {
        return LLVMSetNSW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetNSW(LLVMValueRef ArithInst, LLVMBool HasNSW)
     * }
     */
    public static void LLVMSetNSW(MemorySegment ArithInst, int HasNSW) {
        var mh$ = LLVMSetNSW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetNSW", ArithInst, HasNSW);
            }
            mh$.invokeExact(ArithInst, HasNSW);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetExact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetExact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetExact(LLVMValueRef DivOrShrInst)
     * }
     */
    public static FunctionDescriptor LLVMGetExact$descriptor() {
        return LLVMGetExact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetExact(LLVMValueRef DivOrShrInst)
     * }
     */
    public static MethodHandle LLVMGetExact$handle() {
        return LLVMGetExact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetExact(LLVMValueRef DivOrShrInst)
     * }
     */
    public static MemorySegment LLVMGetExact$address() {
        return LLVMGetExact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetExact(LLVMValueRef DivOrShrInst)
     * }
     */
    public static int LLVMGetExact(MemorySegment DivOrShrInst) {
        var mh$ = LLVMGetExact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetExact", DivOrShrInst);
            }
            return (int)mh$.invokeExact(DivOrShrInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetExact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetExact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetExact(LLVMValueRef DivOrShrInst, LLVMBool IsExact)
     * }
     */
    public static FunctionDescriptor LLVMSetExact$descriptor() {
        return LLVMSetExact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetExact(LLVMValueRef DivOrShrInst, LLVMBool IsExact)
     * }
     */
    public static MethodHandle LLVMSetExact$handle() {
        return LLVMSetExact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetExact(LLVMValueRef DivOrShrInst, LLVMBool IsExact)
     * }
     */
    public static MemorySegment LLVMSetExact$address() {
        return LLVMSetExact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetExact(LLVMValueRef DivOrShrInst, LLVMBool IsExact)
     * }
     */
    public static void LLVMSetExact(MemorySegment DivOrShrInst, int IsExact) {
        var mh$ = LLVMSetExact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetExact", DivOrShrInst, IsExact);
            }
            mh$.invokeExact(DivOrShrInst, IsExact);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNNeg(LLVMValueRef NonNegInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNNeg$descriptor() {
        return LLVMGetNNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNNeg(LLVMValueRef NonNegInst)
     * }
     */
    public static MethodHandle LLVMGetNNeg$handle() {
        return LLVMGetNNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetNNeg(LLVMValueRef NonNegInst)
     * }
     */
    public static MemorySegment LLVMGetNNeg$address() {
        return LLVMGetNNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetNNeg(LLVMValueRef NonNegInst)
     * }
     */
    public static int LLVMGetNNeg(MemorySegment NonNegInst) {
        var mh$ = LLVMGetNNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNNeg", NonNegInst);
            }
            return (int)mh$.invokeExact(NonNegInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetNNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetNNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetNNeg(LLVMValueRef NonNegInst, LLVMBool IsNonNeg)
     * }
     */
    public static FunctionDescriptor LLVMSetNNeg$descriptor() {
        return LLVMSetNNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetNNeg(LLVMValueRef NonNegInst, LLVMBool IsNonNeg)
     * }
     */
    public static MethodHandle LLVMSetNNeg$handle() {
        return LLVMSetNNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetNNeg(LLVMValueRef NonNegInst, LLVMBool IsNonNeg)
     * }
     */
    public static MemorySegment LLVMSetNNeg$address() {
        return LLVMSetNNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetNNeg(LLVMValueRef NonNegInst, LLVMBool IsNonNeg)
     * }
     */
    public static void LLVMSetNNeg(MemorySegment NonNegInst, int IsNonNeg) {
        var mh$ = LLVMSetNNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetNNeg", NonNegInst, IsNonNeg);
            }
            mh$.invokeExact(NonNegInst, IsNonNeg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetFastMathFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetFastMathFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMFastMathFlags LLVMGetFastMathFlags(LLVMValueRef FPMathInst)
     * }
     */
    public static FunctionDescriptor LLVMGetFastMathFlags$descriptor() {
        return LLVMGetFastMathFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMFastMathFlags LLVMGetFastMathFlags(LLVMValueRef FPMathInst)
     * }
     */
    public static MethodHandle LLVMGetFastMathFlags$handle() {
        return LLVMGetFastMathFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMFastMathFlags LLVMGetFastMathFlags(LLVMValueRef FPMathInst)
     * }
     */
    public static MemorySegment LLVMGetFastMathFlags$address() {
        return LLVMGetFastMathFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMFastMathFlags LLVMGetFastMathFlags(LLVMValueRef FPMathInst)
     * }
     */
    public static int LLVMGetFastMathFlags(MemorySegment FPMathInst) {
        var mh$ = LLVMGetFastMathFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetFastMathFlags", FPMathInst);
            }
            return (int)mh$.invokeExact(FPMathInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetFastMathFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetFastMathFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetFastMathFlags(LLVMValueRef FPMathInst, LLVMFastMathFlags FMF)
     * }
     */
    public static FunctionDescriptor LLVMSetFastMathFlags$descriptor() {
        return LLVMSetFastMathFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetFastMathFlags(LLVMValueRef FPMathInst, LLVMFastMathFlags FMF)
     * }
     */
    public static MethodHandle LLVMSetFastMathFlags$handle() {
        return LLVMSetFastMathFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetFastMathFlags(LLVMValueRef FPMathInst, LLVMFastMathFlags FMF)
     * }
     */
    public static MemorySegment LLVMSetFastMathFlags$address() {
        return LLVMSetFastMathFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetFastMathFlags(LLVMValueRef FPMathInst, LLVMFastMathFlags FMF)
     * }
     */
    public static void LLVMSetFastMathFlags(MemorySegment FPMathInst, int FMF) {
        var mh$ = LLVMSetFastMathFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetFastMathFlags", FPMathInst, FMF);
            }
            mh$.invokeExact(FPMathInst, FMF);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCanValueUseFastMathFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCanValueUseFastMathFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCanValueUseFastMathFlags(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMCanValueUseFastMathFlags$descriptor() {
        return LLVMCanValueUseFastMathFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCanValueUseFastMathFlags(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMCanValueUseFastMathFlags$handle() {
        return LLVMCanValueUseFastMathFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCanValueUseFastMathFlags(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMCanValueUseFastMathFlags$address() {
        return LLVMCanValueUseFastMathFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCanValueUseFastMathFlags(LLVMValueRef Inst)
     * }
     */
    public static int LLVMCanValueUseFastMathFlags(MemorySegment Inst) {
        var mh$ = LLVMCanValueUseFastMathFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCanValueUseFastMathFlags", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetIsDisjoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetIsDisjoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetIsDisjoint(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMGetIsDisjoint$descriptor() {
        return LLVMGetIsDisjoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetIsDisjoint(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMGetIsDisjoint$handle() {
        return LLVMGetIsDisjoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetIsDisjoint(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMGetIsDisjoint$address() {
        return LLVMGetIsDisjoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetIsDisjoint(LLVMValueRef Inst)
     * }
     */
    public static int LLVMGetIsDisjoint(MemorySegment Inst) {
        var mh$ = LLVMGetIsDisjoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetIsDisjoint", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetIsDisjoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetIsDisjoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetIsDisjoint(LLVMValueRef Inst, LLVMBool IsDisjoint)
     * }
     */
    public static FunctionDescriptor LLVMSetIsDisjoint$descriptor() {
        return LLVMSetIsDisjoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetIsDisjoint(LLVMValueRef Inst, LLVMBool IsDisjoint)
     * }
     */
    public static MethodHandle LLVMSetIsDisjoint$handle() {
        return LLVMSetIsDisjoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetIsDisjoint(LLVMValueRef Inst, LLVMBool IsDisjoint)
     * }
     */
    public static MemorySegment LLVMSetIsDisjoint$address() {
        return LLVMSetIsDisjoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetIsDisjoint(LLVMValueRef Inst, LLVMBool IsDisjoint)
     * }
     */
    public static void LLVMSetIsDisjoint(MemorySegment Inst, int IsDisjoint) {
        var mh$ = LLVMSetIsDisjoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetIsDisjoint", Inst, IsDisjoint);
            }
            mh$.invokeExact(Inst, IsDisjoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildMalloc$descriptor() {
        return LLVMBuildMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildMalloc$handle() {
        return LLVMBuildMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildMalloc$address() {
        return LLVMBuildMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildMalloc(MemorySegment x0, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMBuildMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMalloc", x0, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildArrayMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildArrayMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildArrayMalloc$descriptor() {
        return LLVMBuildArrayMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildArrayMalloc$handle() {
        return LLVMBuildArrayMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildArrayMalloc$address() {
        return LLVMBuildArrayMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildArrayMalloc(MemorySegment x0, MemorySegment Ty, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildArrayMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildArrayMalloc", x0, Ty, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMemSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMemSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemSet(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, unsigned int Align)
     * }
     */
    public static FunctionDescriptor LLVMBuildMemSet$descriptor() {
        return LLVMBuildMemSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemSet(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, unsigned int Align)
     * }
     */
    public static MethodHandle LLVMBuildMemSet$handle() {
        return LLVMBuildMemSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemSet(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, unsigned int Align)
     * }
     */
    public static MemorySegment LLVMBuildMemSet$address() {
        return LLVMBuildMemSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemSet(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Val, LLVMValueRef Len, unsigned int Align)
     * }
     */
    public static MemorySegment LLVMBuildMemSet(MemorySegment B, MemorySegment Ptr, MemorySegment Val, MemorySegment Len, int Align) {
        var mh$ = LLVMBuildMemSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMemSet", B, Ptr, Val, Len, Align);
            }
            return (MemorySegment)mh$.invokeExact(B, Ptr, Val, Len, Align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMemCpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMemCpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemCpy(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static FunctionDescriptor LLVMBuildMemCpy$descriptor() {
        return LLVMBuildMemCpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemCpy(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MethodHandle LLVMBuildMemCpy$handle() {
        return LLVMBuildMemCpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemCpy(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MemorySegment LLVMBuildMemCpy$address() {
        return LLVMBuildMemCpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemCpy(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MemorySegment LLVMBuildMemCpy(MemorySegment B, MemorySegment Dst, int DstAlign, MemorySegment Src, int SrcAlign, MemorySegment Size) {
        var mh$ = LLVMBuildMemCpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMemCpy", B, Dst, DstAlign, Src, SrcAlign, Size);
            }
            return (MemorySegment)mh$.invokeExact(B, Dst, DstAlign, Src, SrcAlign, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildMemMove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildMemMove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemMove(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static FunctionDescriptor LLVMBuildMemMove$descriptor() {
        return LLVMBuildMemMove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemMove(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MethodHandle LLVMBuildMemMove$handle() {
        return LLVMBuildMemMove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemMove(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MemorySegment LLVMBuildMemMove$address() {
        return LLVMBuildMemMove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildMemMove(LLVMBuilderRef B, LLVMValueRef Dst, unsigned int DstAlign, LLVMValueRef Src, unsigned int SrcAlign, LLVMValueRef Size)
     * }
     */
    public static MemorySegment LLVMBuildMemMove(MemorySegment B, MemorySegment Dst, int DstAlign, MemorySegment Src, int SrcAlign, MemorySegment Size) {
        var mh$ = LLVMBuildMemMove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildMemMove", B, Dst, DstAlign, Src, SrcAlign, Size);
            }
            return (MemorySegment)mh$.invokeExact(B, Dst, DstAlign, Src, SrcAlign, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAlloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAlloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAlloca$descriptor() {
        return LLVMBuildAlloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAlloca$handle() {
        return LLVMBuildAlloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAlloca$address() {
        return LLVMBuildAlloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAlloca(MemorySegment x0, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMBuildAlloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAlloca", x0, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildArrayAlloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildArrayAlloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildArrayAlloca$descriptor() {
        return LLVMBuildArrayAlloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildArrayAlloca$handle() {
        return LLVMBuildArrayAlloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildArrayAlloca$address() {
        return LLVMBuildArrayAlloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildArrayAlloca(MemorySegment x0, MemorySegment Ty, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildArrayAlloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildArrayAlloca", x0, Ty, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal)
     * }
     */
    public static FunctionDescriptor LLVMBuildFree$descriptor() {
        return LLVMBuildFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal)
     * }
     */
    public static MethodHandle LLVMBuildFree$handle() {
        return LLVMBuildFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal)
     * }
     */
    public static MemorySegment LLVMBuildFree$address() {
        return LLVMBuildFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef PointerVal)
     * }
     */
    public static MemorySegment LLVMBuildFree(MemorySegment x0, MemorySegment PointerVal) {
        var mh$ = LLVMBuildFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFree", x0, PointerVal);
            }
            return (MemorySegment)mh$.invokeExact(x0, PointerVal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildLoad2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildLoad2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLoad2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef PointerVal, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildLoad2$descriptor() {
        return LLVMBuildLoad2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLoad2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef PointerVal, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildLoad2$handle() {
        return LLVMBuildLoad2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLoad2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef PointerVal, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLoad2$address() {
        return LLVMBuildLoad2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildLoad2(LLVMBuilderRef, LLVMTypeRef Ty, LLVMValueRef PointerVal, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildLoad2(MemorySegment x0, MemorySegment Ty, MemorySegment PointerVal, MemorySegment Name) {
        var mh$ = LLVMBuildLoad2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildLoad2", x0, Ty, PointerVal, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, PointerVal, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr)
     * }
     */
    public static FunctionDescriptor LLVMBuildStore$descriptor() {
        return LLVMBuildStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr)
     * }
     */
    public static MethodHandle LLVMBuildStore$handle() {
        return LLVMBuildStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr)
     * }
     */
    public static MemorySegment LLVMBuildStore$address() {
        return LLVMBuildStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef Val, LLVMValueRef Ptr)
     * }
     */
    public static MemorySegment LLVMBuildStore(MemorySegment x0, MemorySegment Val, MemorySegment Ptr) {
        var mh$ = LLVMBuildStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildStore", x0, Val, Ptr);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildGEP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildGEP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildGEP2$descriptor() {
        return LLVMBuildGEP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildGEP2$handle() {
        return LLVMBuildGEP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGEP2$address() {
        return LLVMBuildGEP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGEP2(MemorySegment B, MemorySegment Ty, MemorySegment Pointer, MemorySegment Indices, int NumIndices, MemorySegment Name) {
        var mh$ = LLVMBuildGEP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildGEP2", B, Ty, Pointer, Indices, NumIndices, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Pointer, Indices, NumIndices, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInBoundsGEP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInBoundsGEP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInBoundsGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInBoundsGEP2$descriptor() {
        return LLVMBuildInBoundsGEP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInBoundsGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInBoundsGEP2$handle() {
        return LLVMBuildInBoundsGEP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInBoundsGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInBoundsGEP2$address() {
        return LLVMBuildInBoundsGEP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInBoundsGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInBoundsGEP2(MemorySegment B, MemorySegment Ty, MemorySegment Pointer, MemorySegment Indices, int NumIndices, MemorySegment Name) {
        var mh$ = LLVMBuildInBoundsGEP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInBoundsGEP2", B, Ty, Pointer, Indices, NumIndices, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Pointer, Indices, NumIndices, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildGEPWithNoWrapFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildGEPWithNoWrapFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEPWithNoWrapFlags(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static FunctionDescriptor LLVMBuildGEPWithNoWrapFlags$descriptor() {
        return LLVMBuildGEPWithNoWrapFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEPWithNoWrapFlags(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MethodHandle LLVMBuildGEPWithNoWrapFlags$handle() {
        return LLVMBuildGEPWithNoWrapFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEPWithNoWrapFlags(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MemorySegment LLVMBuildGEPWithNoWrapFlags$address() {
        return LLVMBuildGEPWithNoWrapFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGEPWithNoWrapFlags(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, LLVMValueRef *Indices, unsigned int NumIndices, const char *Name, LLVMGEPNoWrapFlags NoWrapFlags)
     * }
     */
    public static MemorySegment LLVMBuildGEPWithNoWrapFlags(MemorySegment B, MemorySegment Ty, MemorySegment Pointer, MemorySegment Indices, int NumIndices, MemorySegment Name, int NoWrapFlags) {
        var mh$ = LLVMBuildGEPWithNoWrapFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildGEPWithNoWrapFlags", B, Ty, Pointer, Indices, NumIndices, Name, NoWrapFlags);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Pointer, Indices, NumIndices, Name, NoWrapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildStructGEP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildStructGEP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStructGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, unsigned int Idx, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildStructGEP2$descriptor() {
        return LLVMBuildStructGEP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStructGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, unsigned int Idx, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildStructGEP2$handle() {
        return LLVMBuildStructGEP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStructGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, unsigned int Idx, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildStructGEP2$address() {
        return LLVMBuildStructGEP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildStructGEP2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Pointer, unsigned int Idx, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildStructGEP2(MemorySegment B, MemorySegment Ty, MemorySegment Pointer, int Idx, MemorySegment Name) {
        var mh$ = LLVMBuildStructGEP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildStructGEP2", B, Ty, Pointer, Idx, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Ty, Pointer, Idx, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildGlobalString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildGlobalString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildGlobalString$descriptor() {
        return LLVMBuildGlobalString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildGlobalString$handle() {
        return LLVMBuildGlobalString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGlobalString$address() {
        return LLVMBuildGlobalString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGlobalString(MemorySegment B, MemorySegment Str, MemorySegment Name) {
        var mh$ = LLVMBuildGlobalString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildGlobalString", B, Str, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Str, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildGlobalStringPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildGlobalStringPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildGlobalStringPtr$descriptor() {
        return LLVMBuildGlobalStringPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildGlobalStringPtr$handle() {
        return LLVMBuildGlobalStringPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGlobalStringPtr$address() {
        return LLVMBuildGlobalStringPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef B, const char *Str, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildGlobalStringPtr(MemorySegment B, MemorySegment Str, MemorySegment Name) {
        var mh$ = LLVMBuildGlobalStringPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildGlobalStringPtr", B, Str, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Str, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetVolatile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetVolatile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static FunctionDescriptor LLVMGetVolatile$descriptor() {
        return LLVMGetVolatile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static MethodHandle LLVMGetVolatile$handle() {
        return LLVMGetVolatile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static MemorySegment LLVMGetVolatile$address() {
        return LLVMGetVolatile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetVolatile(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static int LLVMGetVolatile(MemorySegment MemoryAccessInst) {
        var mh$ = LLVMGetVolatile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetVolatile", MemoryAccessInst);
            }
            return (int)mh$.invokeExact(MemoryAccessInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetVolatile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetVolatile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile)
     * }
     */
    public static FunctionDescriptor LLVMSetVolatile$descriptor() {
        return LLVMSetVolatile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile)
     * }
     */
    public static MethodHandle LLVMSetVolatile$handle() {
        return LLVMSetVolatile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile)
     * }
     */
    public static MemorySegment LLVMSetVolatile$address() {
        return LLVMSetVolatile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetVolatile(LLVMValueRef MemoryAccessInst, LLVMBool IsVolatile)
     * }
     */
    public static void LLVMSetVolatile(MemorySegment MemoryAccessInst, int IsVolatile) {
        var mh$ = LLVMSetVolatile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetVolatile", MemoryAccessInst, IsVolatile);
            }
            mh$.invokeExact(MemoryAccessInst, IsVolatile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetWeak(LLVMValueRef CmpXchgInst)
     * }
     */
    public static FunctionDescriptor LLVMGetWeak$descriptor() {
        return LLVMGetWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetWeak(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MethodHandle LLVMGetWeak$handle() {
        return LLVMGetWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMGetWeak(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MemorySegment LLVMGetWeak$address() {
        return LLVMGetWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMGetWeak(LLVMValueRef CmpXchgInst)
     * }
     */
    public static int LLVMGetWeak(MemorySegment CmpXchgInst) {
        var mh$ = LLVMGetWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetWeak", CmpXchgInst);
            }
            return (int)mh$.invokeExact(CmpXchgInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetWeak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetWeak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetWeak(LLVMValueRef CmpXchgInst, LLVMBool IsWeak)
     * }
     */
    public static FunctionDescriptor LLVMSetWeak$descriptor() {
        return LLVMSetWeak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetWeak(LLVMValueRef CmpXchgInst, LLVMBool IsWeak)
     * }
     */
    public static MethodHandle LLVMSetWeak$handle() {
        return LLVMSetWeak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetWeak(LLVMValueRef CmpXchgInst, LLVMBool IsWeak)
     * }
     */
    public static MemorySegment LLVMSetWeak$address() {
        return LLVMSetWeak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetWeak(LLVMValueRef CmpXchgInst, LLVMBool IsWeak)
     * }
     */
    public static void LLVMSetWeak(MemorySegment CmpXchgInst, int IsWeak) {
        var mh$ = LLVMSetWeak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetWeak", CmpXchgInst, IsWeak);
            }
            mh$.invokeExact(CmpXchgInst, IsWeak);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static FunctionDescriptor LLVMGetOrdering$descriptor() {
        return LLVMGetOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static MethodHandle LLVMGetOrdering$handle() {
        return LLVMGetOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static MemorySegment LLVMGetOrdering$address() {
        return LLVMGetOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetOrdering(LLVMValueRef MemoryAccessInst)
     * }
     */
    public static int LLVMGetOrdering(MemorySegment MemoryAccessInst) {
        var mh$ = LLVMGetOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetOrdering", MemoryAccessInst);
            }
            return (int)mh$.invokeExact(MemoryAccessInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static FunctionDescriptor LLVMSetOrdering$descriptor() {
        return LLVMSetOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MethodHandle LLVMSetOrdering$handle() {
        return LLVMSetOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MemorySegment LLVMSetOrdering$address() {
        return LLVMSetOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetOrdering(LLVMValueRef MemoryAccessInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static void LLVMSetOrdering(MemorySegment MemoryAccessInst, int Ordering) {
        var mh$ = LLVMSetOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetOrdering", MemoryAccessInst, Ordering);
            }
            mh$.invokeExact(MemoryAccessInst, Ordering);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAtomicRMWBinOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAtomicRMWBinOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAtomicRMWBinOp LLVMGetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst)
     * }
     */
    public static FunctionDescriptor LLVMGetAtomicRMWBinOp$descriptor() {
        return LLVMGetAtomicRMWBinOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAtomicRMWBinOp LLVMGetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst)
     * }
     */
    public static MethodHandle LLVMGetAtomicRMWBinOp$handle() {
        return LLVMGetAtomicRMWBinOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAtomicRMWBinOp LLVMGetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst)
     * }
     */
    public static MemorySegment LLVMGetAtomicRMWBinOp$address() {
        return LLVMGetAtomicRMWBinOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAtomicRMWBinOp LLVMGetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst)
     * }
     */
    public static int LLVMGetAtomicRMWBinOp(MemorySegment AtomicRMWInst) {
        var mh$ = LLVMGetAtomicRMWBinOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAtomicRMWBinOp", AtomicRMWInst);
            }
            return (int)mh$.invokeExact(AtomicRMWInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetAtomicRMWBinOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetAtomicRMWBinOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst, LLVMAtomicRMWBinOp BinOp)
     * }
     */
    public static FunctionDescriptor LLVMSetAtomicRMWBinOp$descriptor() {
        return LLVMSetAtomicRMWBinOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst, LLVMAtomicRMWBinOp BinOp)
     * }
     */
    public static MethodHandle LLVMSetAtomicRMWBinOp$handle() {
        return LLVMSetAtomicRMWBinOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst, LLVMAtomicRMWBinOp BinOp)
     * }
     */
    public static MemorySegment LLVMSetAtomicRMWBinOp$address() {
        return LLVMSetAtomicRMWBinOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetAtomicRMWBinOp(LLVMValueRef AtomicRMWInst, LLVMAtomicRMWBinOp BinOp)
     * }
     */
    public static void LLVMSetAtomicRMWBinOp(MemorySegment AtomicRMWInst, int BinOp) {
        var mh$ = LLVMSetAtomicRMWBinOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetAtomicRMWBinOp", AtomicRMWInst, BinOp);
            }
            mh$.invokeExact(AtomicRMWInst, BinOp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildTrunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildTrunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildTrunc$descriptor() {
        return LLVMBuildTrunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildTrunc$handle() {
        return LLVMBuildTrunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildTrunc$address() {
        return LLVMBuildTrunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildTrunc(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildTrunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildTrunc", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildZExt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildZExt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildZExt$descriptor() {
        return LLVMBuildZExt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildZExt$handle() {
        return LLVMBuildZExt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildZExt$address() {
        return LLVMBuildZExt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildZExt(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildZExt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildZExt", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSExt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSExt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSExt$descriptor() {
        return LLVMBuildSExt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSExt$handle() {
        return LLVMBuildSExt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSExt$address() {
        return LLVMBuildSExt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSExt(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildSExt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSExt", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPToUI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPToUI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPToUI$descriptor() {
        return LLVMBuildFPToUI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPToUI$handle() {
        return LLVMBuildFPToUI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPToUI$address() {
        return LLVMBuildFPToUI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPToUI(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPToUI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPToUI", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPToSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPToSI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPToSI$descriptor() {
        return LLVMBuildFPToSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPToSI$handle() {
        return LLVMBuildFPToSI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPToSI$address() {
        return LLVMBuildFPToSI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPToSI(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPToSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPToSI", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildUIToFP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildUIToFP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildUIToFP$descriptor() {
        return LLVMBuildUIToFP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildUIToFP$handle() {
        return LLVMBuildUIToFP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildUIToFP$address() {
        return LLVMBuildUIToFP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildUIToFP(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildUIToFP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildUIToFP", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSIToFP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSIToFP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSIToFP$descriptor() {
        return LLVMBuildSIToFP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSIToFP$handle() {
        return LLVMBuildSIToFP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSIToFP$address() {
        return LLVMBuildSIToFP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSIToFP(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildSIToFP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSIToFP", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPTrunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPTrunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPTrunc$descriptor() {
        return LLVMBuildFPTrunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPTrunc$handle() {
        return LLVMBuildFPTrunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPTrunc$address() {
        return LLVMBuildFPTrunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPTrunc(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPTrunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPTrunc", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPExt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPExt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPExt$descriptor() {
        return LLVMBuildFPExt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPExt$handle() {
        return LLVMBuildFPExt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPExt$address() {
        return LLVMBuildFPExt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPExt(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPExt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPExt", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildPtrToInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildPtrToInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildPtrToInt$descriptor() {
        return LLVMBuildPtrToInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildPtrToInt$handle() {
        return LLVMBuildPtrToInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPtrToInt$address() {
        return LLVMBuildPtrToInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPtrToInt(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildPtrToInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildPtrToInt", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIntToPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIntToPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIntToPtr$descriptor() {
        return LLVMBuildIntToPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIntToPtr$handle() {
        return LLVMBuildIntToPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntToPtr$address() {
        return LLVMBuildIntToPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntToPtr(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildIntToPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIntToPtr", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildBitCast$descriptor() {
        return LLVMBuildBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildBitCast$handle() {
        return LLVMBuildBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildBitCast$address() {
        return LLVMBuildBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildBitCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildBitCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAddrSpaceCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAddrSpaceCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildAddrSpaceCast$descriptor() {
        return LLVMBuildAddrSpaceCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildAddrSpaceCast$handle() {
        return LLVMBuildAddrSpaceCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAddrSpaceCast$address() {
        return LLVMBuildAddrSpaceCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAddrSpaceCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildAddrSpaceCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildAddrSpaceCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAddrSpaceCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildZExtOrBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildZExtOrBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildZExtOrBitCast$descriptor() {
        return LLVMBuildZExtOrBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildZExtOrBitCast$handle() {
        return LLVMBuildZExtOrBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildZExtOrBitCast$address() {
        return LLVMBuildZExtOrBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildZExtOrBitCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildZExtOrBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildZExtOrBitCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSExtOrBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSExtOrBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSExtOrBitCast$descriptor() {
        return LLVMBuildSExtOrBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSExtOrBitCast$handle() {
        return LLVMBuildSExtOrBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSExtOrBitCast$address() {
        return LLVMBuildSExtOrBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSExtOrBitCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildSExtOrBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSExtOrBitCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildTruncOrBitCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildTruncOrBitCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildTruncOrBitCast$descriptor() {
        return LLVMBuildTruncOrBitCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildTruncOrBitCast$handle() {
        return LLVMBuildTruncOrBitCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildTruncOrBitCast$address() {
        return LLVMBuildTruncOrBitCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildTruncOrBitCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildTruncOrBitCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildTruncOrBitCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCast$descriptor() {
        return LLVMBuildCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCast$handle() {
        return LLVMBuildCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCast$address() {
        return LLVMBuildCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCast(LLVMBuilderRef B, LLVMOpcode Op, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCast(MemorySegment B, int Op, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCast", B, Op, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, Op, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildPointerCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildPointerCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildPointerCast$descriptor() {
        return LLVMBuildPointerCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildPointerCast$handle() {
        return LLVMBuildPointerCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPointerCast$address() {
        return LLVMBuildPointerCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPointerCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildPointerCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildPointerCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIntCast2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIntCast2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast2(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, LLVMBool IsSigned, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIntCast2$descriptor() {
        return LLVMBuildIntCast2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast2(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, LLVMBool IsSigned, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIntCast2$handle() {
        return LLVMBuildIntCast2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast2(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, LLVMBool IsSigned, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntCast2$address() {
        return LLVMBuildIntCast2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast2(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, LLVMBool IsSigned, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntCast2(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, int IsSigned, MemorySegment Name) {
        var mh$ = LLVMBuildIntCast2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIntCast2", x0, Val, DestTy, IsSigned, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, IsSigned, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFPCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFPCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFPCast$descriptor() {
        return LLVMBuildFPCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFPCast$handle() {
        return LLVMBuildFPCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPCast$address() {
        return LLVMBuildFPCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFPCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildFPCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFPCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIntCast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIntCast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIntCast$descriptor() {
        return LLVMBuildIntCast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIntCast$handle() {
        return LLVMBuildIntCast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntCast$address() {
        return LLVMBuildIntCast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef Val, LLVMTypeRef DestTy, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIntCast(MemorySegment x0, MemorySegment Val, MemorySegment DestTy, MemorySegment Name) {
        var mh$ = LLVMBuildIntCast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIntCast", x0, Val, DestTy, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, DestTy, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCastOpcode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCastOpcode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetCastOpcode(LLVMValueRef Src, LLVMBool SrcIsSigned, LLVMTypeRef DestTy, LLVMBool DestIsSigned)
     * }
     */
    public static FunctionDescriptor LLVMGetCastOpcode$descriptor() {
        return LLVMGetCastOpcode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetCastOpcode(LLVMValueRef Src, LLVMBool SrcIsSigned, LLVMTypeRef DestTy, LLVMBool DestIsSigned)
     * }
     */
    public static MethodHandle LLVMGetCastOpcode$handle() {
        return LLVMGetCastOpcode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetCastOpcode(LLVMValueRef Src, LLVMBool SrcIsSigned, LLVMTypeRef DestTy, LLVMBool DestIsSigned)
     * }
     */
    public static MemorySegment LLVMGetCastOpcode$address() {
        return LLVMGetCastOpcode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMOpcode LLVMGetCastOpcode(LLVMValueRef Src, LLVMBool SrcIsSigned, LLVMTypeRef DestTy, LLVMBool DestIsSigned)
     * }
     */
    public static int LLVMGetCastOpcode(MemorySegment Src, int SrcIsSigned, MemorySegment DestTy, int DestIsSigned) {
        var mh$ = LLVMGetCastOpcode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCastOpcode", Src, SrcIsSigned, DestTy, DestIsSigned);
            }
            return (int)mh$.invokeExact(Src, SrcIsSigned, DestTy, DestIsSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildICmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildICmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildICmp$descriptor() {
        return LLVMBuildICmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildICmp$handle() {
        return LLVMBuildICmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildICmp$address() {
        return LLVMBuildICmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildICmp(MemorySegment x0, int Op, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildICmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildICmp", x0, Op, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Op, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFCmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFCmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFCmp$descriptor() {
        return LLVMBuildFCmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFCmp$handle() {
        return LLVMBuildFCmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFCmp$address() {
        return LLVMBuildFCmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate Op, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFCmp(MemorySegment x0, int Op, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildFCmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFCmp", x0, Op, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Op, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildPhi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildPhi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildPhi$descriptor() {
        return LLVMBuildPhi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildPhi$handle() {
        return LLVMBuildPhi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPhi$address() {
        return LLVMBuildPhi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPhi(MemorySegment x0, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMBuildPhi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildPhi", x0, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCall2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCall2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCall2(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCall2$descriptor() {
        return LLVMBuildCall2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCall2(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCall2$handle() {
        return LLVMBuildCall2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCall2(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCall2$address() {
        return LLVMBuildCall2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCall2(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCall2(MemorySegment x0, MemorySegment x1, MemorySegment Fn, MemorySegment Args, int NumArgs, MemorySegment Name) {
        var mh$ = LLVMBuildCall2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCall2", x0, x1, Fn, Args, NumArgs, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, Fn, Args, NumArgs, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildCallWithOperandBundles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildCallWithOperandBundles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallWithOperandBundles(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildCallWithOperandBundles$descriptor() {
        return LLVMBuildCallWithOperandBundles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallWithOperandBundles(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildCallWithOperandBundles$handle() {
        return LLVMBuildCallWithOperandBundles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallWithOperandBundles(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCallWithOperandBundles$address() {
        return LLVMBuildCallWithOperandBundles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildCallWithOperandBundles(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef Fn, LLVMValueRef *Args, unsigned int NumArgs, LLVMOperandBundleRef *Bundles, unsigned int NumBundles, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildCallWithOperandBundles(MemorySegment x0, MemorySegment x1, MemorySegment Fn, MemorySegment Args, int NumArgs, MemorySegment Bundles, int NumBundles, MemorySegment Name) {
        var mh$ = LLVMBuildCallWithOperandBundles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildCallWithOperandBundles", x0, x1, Fn, Args, NumArgs, Bundles, NumBundles, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, Fn, Args, NumArgs, Bundles, NumBundles, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildSelect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildSelect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildSelect$descriptor() {
        return LLVMBuildSelect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildSelect$handle() {
        return LLVMBuildSelect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSelect$address() {
        return LLVMBuildSelect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef If, LLVMValueRef Then, LLVMValueRef Else, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildSelect(MemorySegment x0, MemorySegment If, MemorySegment Then, MemorySegment Else, MemorySegment Name) {
        var mh$ = LLVMBuildSelect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildSelect", x0, If, Then, Else, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, If, Then, Else, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildVAArg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildVAArg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildVAArg$descriptor() {
        return LLVMBuildVAArg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildVAArg$handle() {
        return LLVMBuildVAArg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildVAArg$address() {
        return LLVMBuildVAArg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef List, LLVMTypeRef Ty, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildVAArg(MemorySegment x0, MemorySegment List, MemorySegment Ty, MemorySegment Name) {
        var mh$ = LLVMBuildVAArg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildVAArg", x0, List, Ty, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, List, Ty, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildExtractElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildExtractElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildExtractElement$descriptor() {
        return LLVMBuildExtractElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildExtractElement$handle() {
        return LLVMBuildExtractElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExtractElement$address() {
        return LLVMBuildExtractElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExtractElement(MemorySegment x0, MemorySegment VecVal, MemorySegment Index, MemorySegment Name) {
        var mh$ = LLVMBuildExtractElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildExtractElement", x0, VecVal, Index, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, VecVal, Index, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInsertElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInsertElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInsertElement$descriptor() {
        return LLVMBuildInsertElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInsertElement$handle() {
        return LLVMBuildInsertElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInsertElement$address() {
        return LLVMBuildInsertElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef VecVal, LLVMValueRef EltVal, LLVMValueRef Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInsertElement(MemorySegment x0, MemorySegment VecVal, MemorySegment EltVal, MemorySegment Index, MemorySegment Name) {
        var mh$ = LLVMBuildInsertElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInsertElement", x0, VecVal, EltVal, Index, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, VecVal, EltVal, Index, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildShuffleVector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildShuffleVector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildShuffleVector$descriptor() {
        return LLVMBuildShuffleVector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildShuffleVector$handle() {
        return LLVMBuildShuffleVector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildShuffleVector$address() {
        return LLVMBuildShuffleVector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef V1, LLVMValueRef V2, LLVMValueRef Mask, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildShuffleVector(MemorySegment x0, MemorySegment V1, MemorySegment V2, MemorySegment Mask, MemorySegment Name) {
        var mh$ = LLVMBuildShuffleVector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildShuffleVector", x0, V1, V2, Mask, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, V1, V2, Mask, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildExtractValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildExtractValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal, unsigned int Index, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildExtractValue$descriptor() {
        return LLVMBuildExtractValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal, unsigned int Index, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildExtractValue$handle() {
        return LLVMBuildExtractValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal, unsigned int Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExtractValue$address() {
        return LLVMBuildExtractValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef AggVal, unsigned int Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildExtractValue(MemorySegment x0, MemorySegment AggVal, int Index, MemorySegment Name) {
        var mh$ = LLVMBuildExtractValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildExtractValue", x0, AggVal, Index, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, AggVal, Index, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildInsertValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildInsertValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal, LLVMValueRef EltVal, unsigned int Index, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildInsertValue$descriptor() {
        return LLVMBuildInsertValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal, LLVMValueRef EltVal, unsigned int Index, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildInsertValue$handle() {
        return LLVMBuildInsertValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal, LLVMValueRef EltVal, unsigned int Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInsertValue$address() {
        return LLVMBuildInsertValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef AggVal, LLVMValueRef EltVal, unsigned int Index, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildInsertValue(MemorySegment x0, MemorySegment AggVal, MemorySegment EltVal, int Index, MemorySegment Name) {
        var mh$ = LLVMBuildInsertValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildInsertValue", x0, AggVal, EltVal, Index, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, AggVal, EltVal, Index, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFreeze {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFreeze");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFreeze(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFreeze$descriptor() {
        return LLVMBuildFreeze.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFreeze(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFreeze$handle() {
        return LLVMBuildFreeze.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFreeze(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFreeze$address() {
        return LLVMBuildFreeze.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFreeze(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFreeze(MemorySegment x0, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildFreeze.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFreeze", x0, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIsNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIsNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIsNull$descriptor() {
        return LLVMBuildIsNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIsNull$handle() {
        return LLVMBuildIsNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIsNull$address() {
        return LLVMBuildIsNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIsNull(MemorySegment x0, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildIsNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIsNull", x0, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildIsNotNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildIsNotNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildIsNotNull$descriptor() {
        return LLVMBuildIsNotNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildIsNotNull$handle() {
        return LLVMBuildIsNotNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIsNotNull$address() {
        return LLVMBuildIsNotNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef Val, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildIsNotNull(MemorySegment x0, MemorySegment Val, MemorySegment Name) {
        var mh$ = LLVMBuildIsNotNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildIsNotNull", x0, Val, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, Val, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildPtrDiff2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildPtrDiff2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrDiff2(LLVMBuilderRef, LLVMTypeRef ElemTy, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildPtrDiff2$descriptor() {
        return LLVMBuildPtrDiff2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrDiff2(LLVMBuilderRef, LLVMTypeRef ElemTy, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildPtrDiff2$handle() {
        return LLVMBuildPtrDiff2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrDiff2(LLVMBuilderRef, LLVMTypeRef ElemTy, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPtrDiff2$address() {
        return LLVMBuildPtrDiff2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildPtrDiff2(LLVMBuilderRef, LLVMTypeRef ElemTy, LLVMValueRef LHS, LLVMValueRef RHS, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildPtrDiff2(MemorySegment x0, MemorySegment ElemTy, MemorySegment LHS, MemorySegment RHS, MemorySegment Name) {
        var mh$ = LLVMBuildPtrDiff2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildPtrDiff2", x0, ElemTy, LHS, RHS, Name);
            }
            return (MemorySegment)mh$.invokeExact(x0, ElemTy, LHS, RHS, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering, LLVMBool singleThread, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFence$descriptor() {
        return LLVMBuildFence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering, LLVMBool singleThread, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFence$handle() {
        return LLVMBuildFence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering, LLVMBool singleThread, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFence$address() {
        return LLVMBuildFence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFence(LLVMBuilderRef B, LLVMAtomicOrdering ordering, LLVMBool singleThread, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFence(MemorySegment B, int ordering, int singleThread, MemorySegment Name) {
        var mh$ = LLVMBuildFence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFence", B, ordering, singleThread, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ordering, singleThread, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildFenceSyncScope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildFenceSyncScope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFenceSyncScope(LLVMBuilderRef B, LLVMAtomicOrdering ordering, unsigned int SSID, const char *Name)
     * }
     */
    public static FunctionDescriptor LLVMBuildFenceSyncScope$descriptor() {
        return LLVMBuildFenceSyncScope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFenceSyncScope(LLVMBuilderRef B, LLVMAtomicOrdering ordering, unsigned int SSID, const char *Name)
     * }
     */
    public static MethodHandle LLVMBuildFenceSyncScope$handle() {
        return LLVMBuildFenceSyncScope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFenceSyncScope(LLVMBuilderRef B, LLVMAtomicOrdering ordering, unsigned int SSID, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFenceSyncScope$address() {
        return LLVMBuildFenceSyncScope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildFenceSyncScope(LLVMBuilderRef B, LLVMAtomicOrdering ordering, unsigned int SSID, const char *Name)
     * }
     */
    public static MemorySegment LLVMBuildFenceSyncScope(MemorySegment B, int ordering, int SSID, MemorySegment Name) {
        var mh$ = LLVMBuildFenceSyncScope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildFenceSyncScope", B, ordering, SSID, Name);
            }
            return (MemorySegment)mh$.invokeExact(B, ordering, SSID, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAtomicRMW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAtomicRMW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, LLVMBool singleThread)
     * }
     */
    public static FunctionDescriptor LLVMBuildAtomicRMW$descriptor() {
        return LLVMBuildAtomicRMW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, LLVMBool singleThread)
     * }
     */
    public static MethodHandle LLVMBuildAtomicRMW$handle() {
        return LLVMBuildAtomicRMW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, LLVMBool singleThread)
     * }
     */
    public static MemorySegment LLVMBuildAtomicRMW$address() {
        return LLVMBuildAtomicRMW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, LLVMBool singleThread)
     * }
     */
    public static MemorySegment LLVMBuildAtomicRMW(MemorySegment B, int op, MemorySegment PTR, MemorySegment Val, int ordering, int singleThread) {
        var mh$ = LLVMBuildAtomicRMW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAtomicRMW", B, op, PTR, Val, ordering, singleThread);
            }
            return (MemorySegment)mh$.invokeExact(B, op, PTR, Val, ordering, singleThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAtomicRMWSyncScope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAtomicRMWSyncScope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMWSyncScope(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, unsigned int SSID)
     * }
     */
    public static FunctionDescriptor LLVMBuildAtomicRMWSyncScope$descriptor() {
        return LLVMBuildAtomicRMWSyncScope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMWSyncScope(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, unsigned int SSID)
     * }
     */
    public static MethodHandle LLVMBuildAtomicRMWSyncScope$handle() {
        return LLVMBuildAtomicRMWSyncScope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMWSyncScope(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMBuildAtomicRMWSyncScope$address() {
        return LLVMBuildAtomicRMWSyncScope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicRMWSyncScope(LLVMBuilderRef B, LLVMAtomicRMWBinOp op, LLVMValueRef PTR, LLVMValueRef Val, LLVMAtomicOrdering ordering, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMBuildAtomicRMWSyncScope(MemorySegment B, int op, MemorySegment PTR, MemorySegment Val, int ordering, int SSID) {
        var mh$ = LLVMBuildAtomicRMWSyncScope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAtomicRMWSyncScope", B, op, PTR, Val, ordering, SSID);
            }
            return (MemorySegment)mh$.invokeExact(B, op, PTR, Val, ordering, SSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAtomicCmpXchg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAtomicCmpXchg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, LLVMBool SingleThread)
     * }
     */
    public static FunctionDescriptor LLVMBuildAtomicCmpXchg$descriptor() {
        return LLVMBuildAtomicCmpXchg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, LLVMBool SingleThread)
     * }
     */
    public static MethodHandle LLVMBuildAtomicCmpXchg$handle() {
        return LLVMBuildAtomicCmpXchg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, LLVMBool SingleThread)
     * }
     */
    public static MemorySegment LLVMBuildAtomicCmpXchg$address() {
        return LLVMBuildAtomicCmpXchg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, LLVMBool SingleThread)
     * }
     */
    public static MemorySegment LLVMBuildAtomicCmpXchg(MemorySegment B, MemorySegment Ptr, MemorySegment Cmp, MemorySegment New, int SuccessOrdering, int FailureOrdering, int SingleThread) {
        var mh$ = LLVMBuildAtomicCmpXchg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAtomicCmpXchg", B, Ptr, Cmp, New, SuccessOrdering, FailureOrdering, SingleThread);
            }
            return (MemorySegment)mh$.invokeExact(B, Ptr, Cmp, New, SuccessOrdering, FailureOrdering, SingleThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMBuildAtomicCmpXchgSyncScope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_INT,
            LLVM.C_INT,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMBuildAtomicCmpXchgSyncScope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchgSyncScope(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, unsigned int SSID)
     * }
     */
    public static FunctionDescriptor LLVMBuildAtomicCmpXchgSyncScope$descriptor() {
        return LLVMBuildAtomicCmpXchgSyncScope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchgSyncScope(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, unsigned int SSID)
     * }
     */
    public static MethodHandle LLVMBuildAtomicCmpXchgSyncScope$handle() {
        return LLVMBuildAtomicCmpXchgSyncScope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchgSyncScope(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMBuildAtomicCmpXchgSyncScope$address() {
        return LLVMBuildAtomicCmpXchgSyncScope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMValueRef LLVMBuildAtomicCmpXchgSyncScope(LLVMBuilderRef B, LLVMValueRef Ptr, LLVMValueRef Cmp, LLVMValueRef New, LLVMAtomicOrdering SuccessOrdering, LLVMAtomicOrdering FailureOrdering, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMBuildAtomicCmpXchgSyncScope(MemorySegment B, MemorySegment Ptr, MemorySegment Cmp, MemorySegment New, int SuccessOrdering, int FailureOrdering, int SSID) {
        var mh$ = LLVMBuildAtomicCmpXchgSyncScope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMBuildAtomicCmpXchgSyncScope", B, Ptr, Cmp, New, SuccessOrdering, FailureOrdering, SSID);
            }
            return (MemorySegment)mh$.invokeExact(B, Ptr, Cmp, New, SuccessOrdering, FailureOrdering, SSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetNumMaskElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetNumMaskElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumMaskElements(LLVMValueRef ShuffleVectorInst)
     * }
     */
    public static FunctionDescriptor LLVMGetNumMaskElements$descriptor() {
        return LLVMGetNumMaskElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumMaskElements(LLVMValueRef ShuffleVectorInst)
     * }
     */
    public static MethodHandle LLVMGetNumMaskElements$handle() {
        return LLVMGetNumMaskElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetNumMaskElements(LLVMValueRef ShuffleVectorInst)
     * }
     */
    public static MemorySegment LLVMGetNumMaskElements$address() {
        return LLVMGetNumMaskElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetNumMaskElements(LLVMValueRef ShuffleVectorInst)
     * }
     */
    public static int LLVMGetNumMaskElements(MemorySegment ShuffleVectorInst) {
        var mh$ = LLVMGetNumMaskElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetNumMaskElements", ShuffleVectorInst);
            }
            return (int)mh$.invokeExact(ShuffleVectorInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetUndefMaskElem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetUndefMaskElem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LLVMGetUndefMaskElem()
     * }
     */
    public static FunctionDescriptor LLVMGetUndefMaskElem$descriptor() {
        return LLVMGetUndefMaskElem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LLVMGetUndefMaskElem()
     * }
     */
    public static MethodHandle LLVMGetUndefMaskElem$handle() {
        return LLVMGetUndefMaskElem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LLVMGetUndefMaskElem()
     * }
     */
    public static MemorySegment LLVMGetUndefMaskElem$address() {
        return LLVMGetUndefMaskElem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LLVMGetUndefMaskElem()
     * }
     */
    public static int LLVMGetUndefMaskElem() {
        var mh$ = LLVMGetUndefMaskElem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetUndefMaskElem");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetMaskValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetMaskValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LLVMGetMaskValue(LLVMValueRef ShuffleVectorInst, unsigned int Elt)
     * }
     */
    public static FunctionDescriptor LLVMGetMaskValue$descriptor() {
        return LLVMGetMaskValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LLVMGetMaskValue(LLVMValueRef ShuffleVectorInst, unsigned int Elt)
     * }
     */
    public static MethodHandle LLVMGetMaskValue$handle() {
        return LLVMGetMaskValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LLVMGetMaskValue(LLVMValueRef ShuffleVectorInst, unsigned int Elt)
     * }
     */
    public static MemorySegment LLVMGetMaskValue$address() {
        return LLVMGetMaskValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LLVMGetMaskValue(LLVMValueRef ShuffleVectorInst, unsigned int Elt)
     * }
     */
    public static int LLVMGetMaskValue(MemorySegment ShuffleVectorInst, int Elt) {
        var mh$ = LLVMGetMaskValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetMaskValue", ShuffleVectorInst, Elt);
            }
            return (int)mh$.invokeExact(ShuffleVectorInst, Elt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAtomicSingleThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAtomicSingleThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst)
     * }
     */
    public static FunctionDescriptor LLVMIsAtomicSingleThread$descriptor() {
        return LLVMIsAtomicSingleThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst)
     * }
     */
    public static MethodHandle LLVMIsAtomicSingleThread$handle() {
        return LLVMIsAtomicSingleThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst)
     * }
     */
    public static MemorySegment LLVMIsAtomicSingleThread$address() {
        return LLVMIsAtomicSingleThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomicSingleThread(LLVMValueRef AtomicInst)
     * }
     */
    public static int LLVMIsAtomicSingleThread(MemorySegment AtomicInst) {
        var mh$ = LLVMIsAtomicSingleThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAtomicSingleThread", AtomicInst);
            }
            return (int)mh$.invokeExact(AtomicInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetAtomicSingleThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetAtomicSingleThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread)
     * }
     */
    public static FunctionDescriptor LLVMSetAtomicSingleThread$descriptor() {
        return LLVMSetAtomicSingleThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread)
     * }
     */
    public static MethodHandle LLVMSetAtomicSingleThread$handle() {
        return LLVMSetAtomicSingleThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread)
     * }
     */
    public static MemorySegment LLVMSetAtomicSingleThread$address() {
        return LLVMSetAtomicSingleThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetAtomicSingleThread(LLVMValueRef AtomicInst, LLVMBool SingleThread)
     * }
     */
    public static void LLVMSetAtomicSingleThread(MemorySegment AtomicInst, int SingleThread) {
        var mh$ = LLVMSetAtomicSingleThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetAtomicSingleThread", AtomicInst, SingleThread);
            }
            mh$.invokeExact(AtomicInst, SingleThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsAtomic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsAtomic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomic(LLVMValueRef Inst)
     * }
     */
    public static FunctionDescriptor LLVMIsAtomic$descriptor() {
        return LLVMIsAtomic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomic(LLVMValueRef Inst)
     * }
     */
    public static MethodHandle LLVMIsAtomic$handle() {
        return LLVMIsAtomic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomic(LLVMValueRef Inst)
     * }
     */
    public static MemorySegment LLVMIsAtomic$address() {
        return LLVMIsAtomic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsAtomic(LLVMValueRef Inst)
     * }
     */
    public static int LLVMIsAtomic(MemorySegment Inst) {
        var mh$ = LLVMIsAtomic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsAtomic", Inst);
            }
            return (int)mh$.invokeExact(Inst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetAtomicSyncScopeID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetAtomicSyncScopeID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAtomicSyncScopeID(LLVMValueRef AtomicInst)
     * }
     */
    public static FunctionDescriptor LLVMGetAtomicSyncScopeID$descriptor() {
        return LLVMGetAtomicSyncScopeID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAtomicSyncScopeID(LLVMValueRef AtomicInst)
     * }
     */
    public static MethodHandle LLVMGetAtomicSyncScopeID$handle() {
        return LLVMGetAtomicSyncScopeID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int LLVMGetAtomicSyncScopeID(LLVMValueRef AtomicInst)
     * }
     */
    public static MemorySegment LLVMGetAtomicSyncScopeID$address() {
        return LLVMGetAtomicSyncScopeID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int LLVMGetAtomicSyncScopeID(LLVMValueRef AtomicInst)
     * }
     */
    public static int LLVMGetAtomicSyncScopeID(MemorySegment AtomicInst) {
        var mh$ = LLVMGetAtomicSyncScopeID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetAtomicSyncScopeID", AtomicInst);
            }
            return (int)mh$.invokeExact(AtomicInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetAtomicSyncScopeID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetAtomicSyncScopeID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSyncScopeID(LLVMValueRef AtomicInst, unsigned int SSID)
     * }
     */
    public static FunctionDescriptor LLVMSetAtomicSyncScopeID$descriptor() {
        return LLVMSetAtomicSyncScopeID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSyncScopeID(LLVMValueRef AtomicInst, unsigned int SSID)
     * }
     */
    public static MethodHandle LLVMSetAtomicSyncScopeID$handle() {
        return LLVMSetAtomicSyncScopeID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetAtomicSyncScopeID(LLVMValueRef AtomicInst, unsigned int SSID)
     * }
     */
    public static MemorySegment LLVMSetAtomicSyncScopeID$address() {
        return LLVMSetAtomicSyncScopeID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetAtomicSyncScopeID(LLVMValueRef AtomicInst, unsigned int SSID)
     * }
     */
    public static void LLVMSetAtomicSyncScopeID(MemorySegment AtomicInst, int SSID) {
        var mh$ = LLVMSetAtomicSyncScopeID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetAtomicSyncScopeID", AtomicInst, SSID);
            }
            mh$.invokeExact(AtomicInst, SSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCmpXchgSuccessOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCmpXchgSuccessOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static FunctionDescriptor LLVMGetCmpXchgSuccessOrdering$descriptor() {
        return LLVMGetCmpXchgSuccessOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MethodHandle LLVMGetCmpXchgSuccessOrdering$handle() {
        return LLVMGetCmpXchgSuccessOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MemorySegment LLVMGetCmpXchgSuccessOrdering$address() {
        return LLVMGetCmpXchgSuccessOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static int LLVMGetCmpXchgSuccessOrdering(MemorySegment CmpXchgInst) {
        var mh$ = LLVMGetCmpXchgSuccessOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCmpXchgSuccessOrdering", CmpXchgInst);
            }
            return (int)mh$.invokeExact(CmpXchgInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCmpXchgSuccessOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCmpXchgSuccessOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static FunctionDescriptor LLVMSetCmpXchgSuccessOrdering$descriptor() {
        return LLVMSetCmpXchgSuccessOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MethodHandle LLVMSetCmpXchgSuccessOrdering$handle() {
        return LLVMSetCmpXchgSuccessOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MemorySegment LLVMSetCmpXchgSuccessOrdering$address() {
        return LLVMSetCmpXchgSuccessOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCmpXchgSuccessOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static void LLVMSetCmpXchgSuccessOrdering(MemorySegment CmpXchgInst, int Ordering) {
        var mh$ = LLVMSetCmpXchgSuccessOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCmpXchgSuccessOrdering", CmpXchgInst, Ordering);
            }
            mh$.invokeExact(CmpXchgInst, Ordering);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetCmpXchgFailureOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetCmpXchgFailureOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static FunctionDescriptor LLVMGetCmpXchgFailureOrdering$descriptor() {
        return LLVMGetCmpXchgFailureOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MethodHandle LLVMGetCmpXchgFailureOrdering$handle() {
        return LLVMGetCmpXchgFailureOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static MemorySegment LLVMGetCmpXchgFailureOrdering$address() {
        return LLVMGetCmpXchgFailureOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMAtomicOrdering LLVMGetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst)
     * }
     */
    public static int LLVMGetCmpXchgFailureOrdering(MemorySegment CmpXchgInst) {
        var mh$ = LLVMGetCmpXchgFailureOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetCmpXchgFailureOrdering", CmpXchgInst);
            }
            return (int)mh$.invokeExact(CmpXchgInst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMSetCmpXchgFailureOrdering {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMSetCmpXchgFailureOrdering");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static FunctionDescriptor LLVMSetCmpXchgFailureOrdering$descriptor() {
        return LLVMSetCmpXchgFailureOrdering.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MethodHandle LLVMSetCmpXchgFailureOrdering$handle() {
        return LLVMSetCmpXchgFailureOrdering.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static MemorySegment LLVMSetCmpXchgFailureOrdering$address() {
        return LLVMSetCmpXchgFailureOrdering.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMSetCmpXchgFailureOrdering(LLVMValueRef CmpXchgInst, LLVMAtomicOrdering Ordering)
     * }
     */
    public static void LLVMSetCmpXchgFailureOrdering(MemorySegment CmpXchgInst, int Ordering) {
        var mh$ = LLVMSetCmpXchgFailureOrdering.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMSetCmpXchgFailureOrdering", CmpXchgInst, Ordering);
            }
            mh$.invokeExact(CmpXchgInst, Ordering);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateModuleProviderForExistingModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateModuleProviderForExistingModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMCreateModuleProviderForExistingModule$descriptor() {
        return LLVMCreateModuleProviderForExistingModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMCreateModuleProviderForExistingModule$handle() {
        return LLVMCreateModuleProviderForExistingModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCreateModuleProviderForExistingModule$address() {
        return LLVMCreateModuleProviderForExistingModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCreateModuleProviderForExistingModule(MemorySegment M) {
        var mh$ = LLVMCreateModuleProviderForExistingModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateModuleProviderForExistingModule", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeModuleProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeModuleProvider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleProvider(LLVMModuleProviderRef M)
     * }
     */
    public static FunctionDescriptor LLVMDisposeModuleProvider$descriptor() {
        return LLVMDisposeModuleProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleProvider(LLVMModuleProviderRef M)
     * }
     */
    public static MethodHandle LLVMDisposeModuleProvider$handle() {
        return LLVMDisposeModuleProvider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeModuleProvider(LLVMModuleProviderRef M)
     * }
     */
    public static MemorySegment LLVMDisposeModuleProvider$address() {
        return LLVMDisposeModuleProvider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeModuleProvider(LLVMModuleProviderRef M)
     * }
     */
    public static void LLVMDisposeModuleProvider(MemorySegment M) {
        var mh$ = LLVMDisposeModuleProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeModuleProvider", M);
            }
            mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMemoryBufferWithContentsOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMemoryBufferWithContentsOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path, LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static FunctionDescriptor LLVMCreateMemoryBufferWithContentsOfFile$descriptor() {
        return LLVMCreateMemoryBufferWithContentsOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path, LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static MethodHandle LLVMCreateMemoryBufferWithContentsOfFile$handle() {
        return LLVMCreateMemoryBufferWithContentsOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path, LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithContentsOfFile$address() {
        return LLVMCreateMemoryBufferWithContentsOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char *Path, LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static int LLVMCreateMemoryBufferWithContentsOfFile(MemorySegment Path, MemorySegment OutMemBuf, MemorySegment OutMessage) {
        var mh$ = LLVMCreateMemoryBufferWithContentsOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMemoryBufferWithContentsOfFile", Path, OutMemBuf, OutMessage);
            }
            return (int)mh$.invokeExact(Path, OutMemBuf, OutMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMemoryBufferWithSTDIN {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMemoryBufferWithSTDIN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static FunctionDescriptor LLVMCreateMemoryBufferWithSTDIN$descriptor() {
        return LLVMCreateMemoryBufferWithSTDIN.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static MethodHandle LLVMCreateMemoryBufferWithSTDIN$handle() {
        return LLVMCreateMemoryBufferWithSTDIN.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithSTDIN$address() {
        return LLVMCreateMemoryBufferWithSTDIN.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef *OutMemBuf, char **OutMessage)
     * }
     */
    public static int LLVMCreateMemoryBufferWithSTDIN(MemorySegment OutMemBuf, MemorySegment OutMessage) {
        var mh$ = LLVMCreateMemoryBufferWithSTDIN.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMemoryBufferWithSTDIN", OutMemBuf, OutMessage);
            }
            return (int)mh$.invokeExact(OutMemBuf, OutMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMemoryBufferWithMemoryRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER,
            LLVM.C_INT
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMemoryBufferWithMemoryRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData, size_t InputDataLength, const char *BufferName, LLVMBool RequiresNullTerminator)
     * }
     */
    public static FunctionDescriptor LLVMCreateMemoryBufferWithMemoryRange$descriptor() {
        return LLVMCreateMemoryBufferWithMemoryRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData, size_t InputDataLength, const char *BufferName, LLVMBool RequiresNullTerminator)
     * }
     */
    public static MethodHandle LLVMCreateMemoryBufferWithMemoryRange$handle() {
        return LLVMCreateMemoryBufferWithMemoryRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData, size_t InputDataLength, const char *BufferName, LLVMBool RequiresNullTerminator)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithMemoryRange$address() {
        return LLVMCreateMemoryBufferWithMemoryRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char *InputData, size_t InputDataLength, const char *BufferName, LLVMBool RequiresNullTerminator)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithMemoryRange(MemorySegment InputData, long InputDataLength, MemorySegment BufferName, int RequiresNullTerminator) {
        var mh$ = LLVMCreateMemoryBufferWithMemoryRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMemoryBufferWithMemoryRange", InputData, InputDataLength, BufferName, RequiresNullTerminator);
            }
            return (MemorySegment)mh$.invokeExact(InputData, InputDataLength, BufferName, RequiresNullTerminator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateMemoryBufferWithMemoryRangeCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER,
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateMemoryBufferWithMemoryRangeCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData, size_t InputDataLength, const char *BufferName)
     * }
     */
    public static FunctionDescriptor LLVMCreateMemoryBufferWithMemoryRangeCopy$descriptor() {
        return LLVMCreateMemoryBufferWithMemoryRangeCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData, size_t InputDataLength, const char *BufferName)
     * }
     */
    public static MethodHandle LLVMCreateMemoryBufferWithMemoryRangeCopy$handle() {
        return LLVMCreateMemoryBufferWithMemoryRangeCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData, size_t InputDataLength, const char *BufferName)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithMemoryRangeCopy$address() {
        return LLVMCreateMemoryBufferWithMemoryRangeCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char *InputData, size_t InputDataLength, const char *BufferName)
     * }
     */
    public static MemorySegment LLVMCreateMemoryBufferWithMemoryRangeCopy(MemorySegment InputData, long InputDataLength, MemorySegment BufferName) {
        var mh$ = LLVMCreateMemoryBufferWithMemoryRangeCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateMemoryBufferWithMemoryRangeCopy", InputData, InputDataLength, BufferName);
            }
            return (MemorySegment)mh$.invokeExact(InputData, InputDataLength, BufferName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBufferStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBufferStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static FunctionDescriptor LLVMGetBufferStart$descriptor() {
        return LLVMGetBufferStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MethodHandle LLVMGetBufferStart$handle() {
        return LLVMGetBufferStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MemorySegment LLVMGetBufferStart$address() {
        return LLVMGetBufferStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *LLVMGetBufferStart(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MemorySegment LLVMGetBufferStart(MemorySegment MemBuf) {
        var mh$ = LLVMGetBufferStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBufferStart", MemBuf);
            }
            return (MemorySegment)mh$.invokeExact(MemBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMGetBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_LONG,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMGetBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static FunctionDescriptor LLVMGetBufferSize$descriptor() {
        return LLVMGetBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MethodHandle LLVMGetBufferSize$handle() {
        return LLVMGetBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MemorySegment LLVMGetBufferSize$address() {
        return LLVMGetBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t LLVMGetBufferSize(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static long LLVMGetBufferSize(MemorySegment MemBuf) {
        var mh$ = LLVMGetBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMGetBufferSize", MemBuf);
            }
            return (long)mh$.invokeExact(MemBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposeMemoryBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposeMemoryBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static FunctionDescriptor LLVMDisposeMemoryBuffer$descriptor() {
        return LLVMDisposeMemoryBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MethodHandle LLVMDisposeMemoryBuffer$handle() {
        return LLVMDisposeMemoryBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static MemorySegment LLVMDisposeMemoryBuffer$address() {
        return LLVMDisposeMemoryBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef MemBuf)
     * }
     */
    public static void LLVMDisposeMemoryBuffer(MemorySegment MemBuf) {
        var mh$ = LLVMDisposeMemoryBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposeMemoryBuffer", MemBuf);
            }
            mh$.invokeExact(MemBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreatePassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreatePassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreatePassManager()
     * }
     */
    public static FunctionDescriptor LLVMCreatePassManager$descriptor() {
        return LLVMCreatePassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreatePassManager()
     * }
     */
    public static MethodHandle LLVMCreatePassManager$handle() {
        return LLVMCreatePassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreatePassManager()
     * }
     */
    public static MemorySegment LLVMCreatePassManager$address() {
        return LLVMCreatePassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreatePassManager()
     * }
     */
    public static MemorySegment LLVMCreatePassManager() {
        var mh$ = LLVMCreatePassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreatePassManager");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateFunctionPassManagerForModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateFunctionPassManagerForModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMCreateFunctionPassManagerForModule$descriptor() {
        return LLVMCreateFunctionPassManagerForModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMCreateFunctionPassManagerForModule$handle() {
        return LLVMCreateFunctionPassManagerForModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCreateFunctionPassManagerForModule$address() {
        return LLVMCreateFunctionPassManagerForModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMCreateFunctionPassManagerForModule(MemorySegment M) {
        var mh$ = LLVMCreateFunctionPassManagerForModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateFunctionPassManagerForModule", M);
            }
            return (MemorySegment)mh$.invokeExact(M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMCreateFunctionPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMCreateFunctionPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP)
     * }
     */
    public static FunctionDescriptor LLVMCreateFunctionPassManager$descriptor() {
        return LLVMCreateFunctionPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP)
     * }
     */
    public static MethodHandle LLVMCreateFunctionPassManager$handle() {
        return LLVMCreateFunctionPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP)
     * }
     */
    public static MemorySegment LLVMCreateFunctionPassManager$address() {
        return LLVMCreateFunctionPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef MP)
     * }
     */
    public static MemorySegment LLVMCreateFunctionPassManager(MemorySegment MP) {
        var mh$ = LLVMCreateFunctionPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMCreateFunctionPassManager", MP);
            }
            return (MemorySegment)mh$.invokeExact(MP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRunPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRunPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M)
     * }
     */
    public static FunctionDescriptor LLVMRunPassManager$descriptor() {
        return LLVMRunPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M)
     * }
     */
    public static MethodHandle LLVMRunPassManager$handle() {
        return LLVMRunPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M)
     * }
     */
    public static MemorySegment LLVMRunPassManager$address() {
        return LLVMRunPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMRunPassManager(LLVMPassManagerRef PM, LLVMModuleRef M)
     * }
     */
    public static int LLVMRunPassManager(MemorySegment PM, MemorySegment M) {
        var mh$ = LLVMRunPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRunPassManager", PM, M);
            }
            return (int)mh$.invokeExact(PM, M);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMInitializeFunctionPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMInitializeFunctionPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static FunctionDescriptor LLVMInitializeFunctionPassManager$descriptor() {
        return LLVMInitializeFunctionPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static MethodHandle LLVMInitializeFunctionPassManager$handle() {
        return LLVMInitializeFunctionPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static MemorySegment LLVMInitializeFunctionPassManager$address() {
        return LLVMInitializeFunctionPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static int LLVMInitializeFunctionPassManager(MemorySegment FPM) {
        var mh$ = LLVMInitializeFunctionPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMInitializeFunctionPassManager", FPM);
            }
            return (int)mh$.invokeExact(FPM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMRunFunctionPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMRunFunctionPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F)
     * }
     */
    public static FunctionDescriptor LLVMRunFunctionPassManager$descriptor() {
        return LLVMRunFunctionPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F)
     * }
     */
    public static MethodHandle LLVMRunFunctionPassManager$handle() {
        return LLVMRunFunctionPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F)
     * }
     */
    public static MemorySegment LLVMRunFunctionPassManager$address() {
        return LLVMRunFunctionPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef FPM, LLVMValueRef F)
     * }
     */
    public static int LLVMRunFunctionPassManager(MemorySegment FPM, MemorySegment F) {
        var mh$ = LLVMRunFunctionPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMRunFunctionPassManager", FPM, F);
            }
            return (int)mh$.invokeExact(FPM, F);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMFinalizeFunctionPassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT,
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMFinalizeFunctionPassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static FunctionDescriptor LLVMFinalizeFunctionPassManager$descriptor() {
        return LLVMFinalizeFunctionPassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static MethodHandle LLVMFinalizeFunctionPassManager$handle() {
        return LLVMFinalizeFunctionPassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static MemorySegment LLVMFinalizeFunctionPassManager$address() {
        return LLVMFinalizeFunctionPassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef FPM)
     * }
     */
    public static int LLVMFinalizeFunctionPassManager(MemorySegment FPM) {
        var mh$ = LLVMFinalizeFunctionPassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMFinalizeFunctionPassManager", FPM);
            }
            return (int)mh$.invokeExact(FPM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMDisposePassManager {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            LLVM.C_POINTER
        );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMDisposePassManager");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMDisposePassManager(LLVMPassManagerRef PM)
     * }
     */
    public static FunctionDescriptor LLVMDisposePassManager$descriptor() {
        return LLVMDisposePassManager.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMDisposePassManager(LLVMPassManagerRef PM)
     * }
     */
    public static MethodHandle LLVMDisposePassManager$handle() {
        return LLVMDisposePassManager.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMDisposePassManager(LLVMPassManagerRef PM)
     * }
     */
    public static MemorySegment LLVMDisposePassManager$address() {
        return LLVMDisposePassManager.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMDisposePassManager(LLVMPassManagerRef PM)
     * }
     */
    public static void LLVMDisposePassManager(MemorySegment PM) {
        var mh$ = LLVMDisposePassManager.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMDisposePassManager", PM);
            }
            mh$.invokeExact(PM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStartMultithreaded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStartMultithreaded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMStartMultithreaded()
     * }
     */
    public static FunctionDescriptor LLVMStartMultithreaded$descriptor() {
        return LLVMStartMultithreaded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMStartMultithreaded()
     * }
     */
    public static MethodHandle LLVMStartMultithreaded$handle() {
        return LLVMStartMultithreaded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMStartMultithreaded()
     * }
     */
    public static MemorySegment LLVMStartMultithreaded$address() {
        return LLVMStartMultithreaded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMStartMultithreaded()
     * }
     */
    public static int LLVMStartMultithreaded() {
        var mh$ = LLVMStartMultithreaded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStartMultithreaded");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMStopMultithreaded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMStopMultithreaded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LLVMStopMultithreaded()
     * }
     */
    public static FunctionDescriptor LLVMStopMultithreaded$descriptor() {
        return LLVMStopMultithreaded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LLVMStopMultithreaded()
     * }
     */
    public static MethodHandle LLVMStopMultithreaded$handle() {
        return LLVMStopMultithreaded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LLVMStopMultithreaded()
     * }
     */
    public static MemorySegment LLVMStopMultithreaded$address() {
        return LLVMStopMultithreaded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LLVMStopMultithreaded()
     * }
     */
    public static void LLVMStopMultithreaded() {
        var mh$ = LLVMStopMultithreaded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMStopMultithreaded");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LLVMIsMultithreaded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            LLVM.C_INT    );

        public static final MemorySegment ADDR = LLVM.findOrThrow("LLVMIsMultithreaded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsMultithreaded()
     * }
     */
    public static FunctionDescriptor LLVMIsMultithreaded$descriptor() {
        return LLVMIsMultithreaded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsMultithreaded()
     * }
     */
    public static MethodHandle LLVMIsMultithreaded$handle() {
        return LLVMIsMultithreaded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LLVMBool LLVMIsMultithreaded()
     * }
     */
    public static MemorySegment LLVMIsMultithreaded$address() {
        return LLVMIsMultithreaded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LLVMBool LLVMIsMultithreaded()
     * }
     */
    public static int LLVMIsMultithreaded() {
        var mh$ = LLVMIsMultithreaded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LLVMIsMultithreaded");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI64_PREFIX "l"
     * }
     */
    public static MemorySegment __PRI64_PREFIX() {
        class Holder {
            static final MemorySegment __PRI64_PREFIX
                = LLVM.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRI64_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRIPTR_PREFIX "l"
     * }
     */
    public static MemorySegment __PRIPTR_PREFIX() {
        class Holder {
            static final MemorySegment __PRIPTR_PREFIX
                = LLVM.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRIPTR_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "d"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "d"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "ld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "d"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "d"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "ld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "d"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "ld"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "ld"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "ld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "i"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "i"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi32 "i"
     * }
     */
    public static MemorySegment PRIi32() {
        class Holder {
            static final MemorySegment PRIi32
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi64 "li"
     * }
     */
    public static MemorySegment PRIi64() {
        class Holder {
            static final MemorySegment PRIi64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIi64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST8 "i"
     * }
     */
    public static MemorySegment PRIiLEAST8() {
        class Holder {
            static final MemorySegment PRIiLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST16 "i"
     * }
     */
    public static MemorySegment PRIiLEAST16() {
        class Holder {
            static final MemorySegment PRIiLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST32 "i"
     * }
     */
    public static MemorySegment PRIiLEAST32() {
        class Holder {
            static final MemorySegment PRIiLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST64 "li"
     * }
     */
    public static MemorySegment PRIiLEAST64() {
        class Holder {
            static final MemorySegment PRIiLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST8 "i"
     * }
     */
    public static MemorySegment PRIiFAST8() {
        class Holder {
            static final MemorySegment PRIiFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST16 "li"
     * }
     */
    public static MemorySegment PRIiFAST16() {
        class Holder {
            static final MemorySegment PRIiFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST32 "li"
     * }
     */
    public static MemorySegment PRIiFAST32() {
        class Holder {
            static final MemorySegment PRIiFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST64 "li"
     * }
     */
    public static MemorySegment PRIiFAST64() {
        class Holder {
            static final MemorySegment PRIiFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo8 "o"
     * }
     */
    public static MemorySegment PRIo8() {
        class Holder {
            static final MemorySegment PRIo8
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo16 "o"
     * }
     */
    public static MemorySegment PRIo16() {
        class Holder {
            static final MemorySegment PRIo16
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo32 "o"
     * }
     */
    public static MemorySegment PRIo32() {
        class Holder {
            static final MemorySegment PRIo32
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo64 "lo"
     * }
     */
    public static MemorySegment PRIo64() {
        class Holder {
            static final MemorySegment PRIo64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIo64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST8 "o"
     * }
     */
    public static MemorySegment PRIoLEAST8() {
        class Holder {
            static final MemorySegment PRIoLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST16 "o"
     * }
     */
    public static MemorySegment PRIoLEAST16() {
        class Holder {
            static final MemorySegment PRIoLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST32 "o"
     * }
     */
    public static MemorySegment PRIoLEAST32() {
        class Holder {
            static final MemorySegment PRIoLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST64 "lo"
     * }
     */
    public static MemorySegment PRIoLEAST64() {
        class Holder {
            static final MemorySegment PRIoLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST8 "o"
     * }
     */
    public static MemorySegment PRIoFAST8() {
        class Holder {
            static final MemorySegment PRIoFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST16 "lo"
     * }
     */
    public static MemorySegment PRIoFAST16() {
        class Holder {
            static final MemorySegment PRIoFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST32 "lo"
     * }
     */
    public static MemorySegment PRIoFAST32() {
        class Holder {
            static final MemorySegment PRIoFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST64 "lo"
     * }
     */
    public static MemorySegment PRIoFAST64() {
        class Holder {
            static final MemorySegment PRIoFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu8 "u"
     * }
     */
    public static MemorySegment PRIu8() {
        class Holder {
            static final MemorySegment PRIu8
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu16 "u"
     * }
     */
    public static MemorySegment PRIu16() {
        class Holder {
            static final MemorySegment PRIu16
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu32 "u"
     * }
     */
    public static MemorySegment PRIu32() {
        class Holder {
            static final MemorySegment PRIu32
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu64 "lu"
     * }
     */
    public static MemorySegment PRIu64() {
        class Holder {
            static final MemorySegment PRIu64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIu64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST8 "u"
     * }
     */
    public static MemorySegment PRIuLEAST8() {
        class Holder {
            static final MemorySegment PRIuLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST16 "u"
     * }
     */
    public static MemorySegment PRIuLEAST16() {
        class Holder {
            static final MemorySegment PRIuLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST32 "u"
     * }
     */
    public static MemorySegment PRIuLEAST32() {
        class Holder {
            static final MemorySegment PRIuLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST64 "lu"
     * }
     */
    public static MemorySegment PRIuLEAST64() {
        class Holder {
            static final MemorySegment PRIuLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST8 "u"
     * }
     */
    public static MemorySegment PRIuFAST8() {
        class Holder {
            static final MemorySegment PRIuFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST16 "lu"
     * }
     */
    public static MemorySegment PRIuFAST16() {
        class Holder {
            static final MemorySegment PRIuFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST32 "lu"
     * }
     */
    public static MemorySegment PRIuFAST32() {
        class Holder {
            static final MemorySegment PRIuFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST64 "lu"
     * }
     */
    public static MemorySegment PRIuFAST64() {
        class Holder {
            static final MemorySegment PRIuFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx8 "x"
     * }
     */
    public static MemorySegment PRIx8() {
        class Holder {
            static final MemorySegment PRIx8
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx16 "x"
     * }
     */
    public static MemorySegment PRIx16() {
        class Holder {
            static final MemorySegment PRIx16
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx32 "x"
     * }
     */
    public static MemorySegment PRIx32() {
        class Holder {
            static final MemorySegment PRIx32
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx64 "lx"
     * }
     */
    public static MemorySegment PRIx64() {
        class Holder {
            static final MemorySegment PRIx64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIx64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST8 "x"
     * }
     */
    public static MemorySegment PRIxLEAST8() {
        class Holder {
            static final MemorySegment PRIxLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST16 "x"
     * }
     */
    public static MemorySegment PRIxLEAST16() {
        class Holder {
            static final MemorySegment PRIxLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST32 "x"
     * }
     */
    public static MemorySegment PRIxLEAST32() {
        class Holder {
            static final MemorySegment PRIxLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST64 "lx"
     * }
     */
    public static MemorySegment PRIxLEAST64() {
        class Holder {
            static final MemorySegment PRIxLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST8 "x"
     * }
     */
    public static MemorySegment PRIxFAST8() {
        class Holder {
            static final MemorySegment PRIxFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST16 "lx"
     * }
     */
    public static MemorySegment PRIxFAST16() {
        class Holder {
            static final MemorySegment PRIxFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST32 "lx"
     * }
     */
    public static MemorySegment PRIxFAST32() {
        class Holder {
            static final MemorySegment PRIxFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST64 "lx"
     * }
     */
    public static MemorySegment PRIxFAST64() {
        class Holder {
            static final MemorySegment PRIxFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX8 "X"
     * }
     */
    public static MemorySegment PRIX8() {
        class Holder {
            static final MemorySegment PRIX8
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX16 "X"
     * }
     */
    public static MemorySegment PRIX16() {
        class Holder {
            static final MemorySegment PRIX16
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX32 "X"
     * }
     */
    public static MemorySegment PRIX32() {
        class Holder {
            static final MemorySegment PRIX32
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX64 "lX"
     * }
     */
    public static MemorySegment PRIX64() {
        class Holder {
            static final MemorySegment PRIX64
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIX64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST8 "X"
     * }
     */
    public static MemorySegment PRIXLEAST8() {
        class Holder {
            static final MemorySegment PRIXLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST16 "X"
     * }
     */
    public static MemorySegment PRIXLEAST16() {
        class Holder {
            static final MemorySegment PRIXLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST32 "X"
     * }
     */
    public static MemorySegment PRIXLEAST32() {
        class Holder {
            static final MemorySegment PRIXLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST64 "lX"
     * }
     */
    public static MemorySegment PRIXLEAST64() {
        class Holder {
            static final MemorySegment PRIXLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST8 "X"
     * }
     */
    public static MemorySegment PRIXFAST8() {
        class Holder {
            static final MemorySegment PRIXFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST16 "lX"
     * }
     */
    public static MemorySegment PRIXFAST16() {
        class Holder {
            static final MemorySegment PRIXFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST32 "lX"
     * }
     */
    public static MemorySegment PRIXFAST32() {
        class Holder {
            static final MemorySegment PRIXFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST64 "lX"
     * }
     */
    public static MemorySegment PRIXFAST64() {
        class Holder {
            static final MemorySegment PRIXFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdMAX "ld"
     * }
     */
    public static MemorySegment PRIdMAX() {
        class Holder {
            static final MemorySegment PRIdMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiMAX "li"
     * }
     */
    public static MemorySegment PRIiMAX() {
        class Holder {
            static final MemorySegment PRIiMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoMAX "lo"
     * }
     */
    public static MemorySegment PRIoMAX() {
        class Holder {
            static final MemorySegment PRIoMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuMAX "lu"
     * }
     */
    public static MemorySegment PRIuMAX() {
        class Holder {
            static final MemorySegment PRIuMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxMAX "lx"
     * }
     */
    public static MemorySegment PRIxMAX() {
        class Holder {
            static final MemorySegment PRIxMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXMAX "lX"
     * }
     */
    public static MemorySegment PRIXMAX() {
        class Holder {
            static final MemorySegment PRIXMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdPTR "ld"
     * }
     */
    public static MemorySegment PRIdPTR() {
        class Holder {
            static final MemorySegment PRIdPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiPTR "li"
     * }
     */
    public static MemorySegment PRIiPTR() {
        class Holder {
            static final MemorySegment PRIiPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoPTR "lo"
     * }
     */
    public static MemorySegment PRIoPTR() {
        class Holder {
            static final MemorySegment PRIoPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuPTR "lu"
     * }
     */
    public static MemorySegment PRIuPTR() {
        class Holder {
            static final MemorySegment PRIuPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxPTR "lx"
     * }
     */
    public static MemorySegment PRIxPTR() {
        class Holder {
            static final MemorySegment PRIxPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXPTR "lX"
     * }
     */
    public static MemorySegment PRIXPTR() {
        class Holder {
            static final MemorySegment PRIXPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd8 "hhd"
     * }
     */
    public static MemorySegment SCNd8() {
        class Holder {
            static final MemorySegment SCNd8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNd8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd16 "hd"
     * }
     */
    public static MemorySegment SCNd16() {
        class Holder {
            static final MemorySegment SCNd16
                = LLVM.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNd16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd32 "d"
     * }
     */
    public static MemorySegment SCNd32() {
        class Holder {
            static final MemorySegment SCNd32
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNd32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd64 "ld"
     * }
     */
    public static MemorySegment SCNd64() {
        class Holder {
            static final MemorySegment SCNd64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNd64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdLEAST8() {
        class Holder {
            static final MemorySegment SCNdLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST16 "hd"
     * }
     */
    public static MemorySegment SCNdLEAST16() {
        class Holder {
            static final MemorySegment SCNdLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST32 "d"
     * }
     */
    public static MemorySegment SCNdLEAST32() {
        class Holder {
            static final MemorySegment SCNdLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST64 "ld"
     * }
     */
    public static MemorySegment SCNdLEAST64() {
        class Holder {
            static final MemorySegment SCNdLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdFAST8() {
        class Holder {
            static final MemorySegment SCNdFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST16 "ld"
     * }
     */
    public static MemorySegment SCNdFAST16() {
        class Holder {
            static final MemorySegment SCNdFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST32 "ld"
     * }
     */
    public static MemorySegment SCNdFAST32() {
        class Holder {
            static final MemorySegment SCNdFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST64 "ld"
     * }
     */
    public static MemorySegment SCNdFAST64() {
        class Holder {
            static final MemorySegment SCNdFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi8 "hhi"
     * }
     */
    public static MemorySegment SCNi8() {
        class Holder {
            static final MemorySegment SCNi8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNi8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi16 "hi"
     * }
     */
    public static MemorySegment SCNi16() {
        class Holder {
            static final MemorySegment SCNi16
                = LLVM.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNi16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi32 "i"
     * }
     */
    public static MemorySegment SCNi32() {
        class Holder {
            static final MemorySegment SCNi32
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNi32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi64 "li"
     * }
     */
    public static MemorySegment SCNi64() {
        class Holder {
            static final MemorySegment SCNi64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNi64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiLEAST8() {
        class Holder {
            static final MemorySegment SCNiLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST16 "hi"
     * }
     */
    public static MemorySegment SCNiLEAST16() {
        class Holder {
            static final MemorySegment SCNiLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST32 "i"
     * }
     */
    public static MemorySegment SCNiLEAST32() {
        class Holder {
            static final MemorySegment SCNiLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST64 "li"
     * }
     */
    public static MemorySegment SCNiLEAST64() {
        class Holder {
            static final MemorySegment SCNiLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiFAST8() {
        class Holder {
            static final MemorySegment SCNiFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST16 "li"
     * }
     */
    public static MemorySegment SCNiFAST16() {
        class Holder {
            static final MemorySegment SCNiFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST32 "li"
     * }
     */
    public static MemorySegment SCNiFAST32() {
        class Holder {
            static final MemorySegment SCNiFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST64 "li"
     * }
     */
    public static MemorySegment SCNiFAST64() {
        class Holder {
            static final MemorySegment SCNiFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu8 "hhu"
     * }
     */
    public static MemorySegment SCNu8() {
        class Holder {
            static final MemorySegment SCNu8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNu8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu16 "hu"
     * }
     */
    public static MemorySegment SCNu16() {
        class Holder {
            static final MemorySegment SCNu16
                = LLVM.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNu16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu32 "u"
     * }
     */
    public static MemorySegment SCNu32() {
        class Holder {
            static final MemorySegment SCNu32
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNu32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu64 "lu"
     * }
     */
    public static MemorySegment SCNu64() {
        class Holder {
            static final MemorySegment SCNu64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNu64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuLEAST8() {
        class Holder {
            static final MemorySegment SCNuLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST16 "hu"
     * }
     */
    public static MemorySegment SCNuLEAST16() {
        class Holder {
            static final MemorySegment SCNuLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST32 "u"
     * }
     */
    public static MemorySegment SCNuLEAST32() {
        class Holder {
            static final MemorySegment SCNuLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST64 "lu"
     * }
     */
    public static MemorySegment SCNuLEAST64() {
        class Holder {
            static final MemorySegment SCNuLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuFAST8() {
        class Holder {
            static final MemorySegment SCNuFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST16 "lu"
     * }
     */
    public static MemorySegment SCNuFAST16() {
        class Holder {
            static final MemorySegment SCNuFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST32 "lu"
     * }
     */
    public static MemorySegment SCNuFAST32() {
        class Holder {
            static final MemorySegment SCNuFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST64 "lu"
     * }
     */
    public static MemorySegment SCNuFAST64() {
        class Holder {
            static final MemorySegment SCNuFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo8 "hho"
     * }
     */
    public static MemorySegment SCNo8() {
        class Holder {
            static final MemorySegment SCNo8
                = LLVM.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNo8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo16 "ho"
     * }
     */
    public static MemorySegment SCNo16() {
        class Holder {
            static final MemorySegment SCNo16
                = LLVM.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNo16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo32 "o"
     * }
     */
    public static MemorySegment SCNo32() {
        class Holder {
            static final MemorySegment SCNo32
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNo32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo64 "lo"
     * }
     */
    public static MemorySegment SCNo64() {
        class Holder {
            static final MemorySegment SCNo64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNo64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST8 "hho"
     * }
     */
    public static MemorySegment SCNoLEAST8() {
        class Holder {
            static final MemorySegment SCNoLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST16 "ho"
     * }
     */
    public static MemorySegment SCNoLEAST16() {
        class Holder {
            static final MemorySegment SCNoLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST32 "o"
     * }
     */
    public static MemorySegment SCNoLEAST32() {
        class Holder {
            static final MemorySegment SCNoLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST64 "lo"
     * }
     */
    public static MemorySegment SCNoLEAST64() {
        class Holder {
            static final MemorySegment SCNoLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST8 "hho"
     * }
     */
    public static MemorySegment SCNoFAST8() {
        class Holder {
            static final MemorySegment SCNoFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST16 "lo"
     * }
     */
    public static MemorySegment SCNoFAST16() {
        class Holder {
            static final MemorySegment SCNoFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST32 "lo"
     * }
     */
    public static MemorySegment SCNoFAST32() {
        class Holder {
            static final MemorySegment SCNoFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST64 "lo"
     * }
     */
    public static MemorySegment SCNoFAST64() {
        class Holder {
            static final MemorySegment SCNoFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx8 "hhx"
     * }
     */
    public static MemorySegment SCNx8() {
        class Holder {
            static final MemorySegment SCNx8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNx8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx16 "hx"
     * }
     */
    public static MemorySegment SCNx16() {
        class Holder {
            static final MemorySegment SCNx16
                = LLVM.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNx16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx32 "x"
     * }
     */
    public static MemorySegment SCNx32() {
        class Holder {
            static final MemorySegment SCNx32
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNx32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx64 "lx"
     * }
     */
    public static MemorySegment SCNx64() {
        class Holder {
            static final MemorySegment SCNx64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNx64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxLEAST8() {
        class Holder {
            static final MemorySegment SCNxLEAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST16 "hx"
     * }
     */
    public static MemorySegment SCNxLEAST16() {
        class Holder {
            static final MemorySegment SCNxLEAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST32 "x"
     * }
     */
    public static MemorySegment SCNxLEAST32() {
        class Holder {
            static final MemorySegment SCNxLEAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST64 "lx"
     * }
     */
    public static MemorySegment SCNxLEAST64() {
        class Holder {
            static final MemorySegment SCNxLEAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxFAST8() {
        class Holder {
            static final MemorySegment SCNxFAST8
                = LLVM.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST16 "lx"
     * }
     */
    public static MemorySegment SCNxFAST16() {
        class Holder {
            static final MemorySegment SCNxFAST16
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST32 "lx"
     * }
     */
    public static MemorySegment SCNxFAST32() {
        class Holder {
            static final MemorySegment SCNxFAST32
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST64 "lx"
     * }
     */
    public static MemorySegment SCNxFAST64() {
        class Holder {
            static final MemorySegment SCNxFAST64
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdMAX "ld"
     * }
     */
    public static MemorySegment SCNdMAX() {
        class Holder {
            static final MemorySegment SCNdMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiMAX "li"
     * }
     */
    public static MemorySegment SCNiMAX() {
        class Holder {
            static final MemorySegment SCNiMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoMAX "lo"
     * }
     */
    public static MemorySegment SCNoMAX() {
        class Holder {
            static final MemorySegment SCNoMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuMAX "lu"
     * }
     */
    public static MemorySegment SCNuMAX() {
        class Holder {
            static final MemorySegment SCNuMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxMAX "lx"
     * }
     */
    public static MemorySegment SCNxMAX() {
        class Holder {
            static final MemorySegment SCNxMAX
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdPTR "ld"
     * }
     */
    public static MemorySegment SCNdPTR() {
        class Holder {
            static final MemorySegment SCNdPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiPTR "li"
     * }
     */
    public static MemorySegment SCNiPTR() {
        class Holder {
            static final MemorySegment SCNiPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoPTR "lo"
     * }
     */
    public static MemorySegment SCNoPTR() {
        class Holder {
            static final MemorySegment SCNoPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuPTR "lu"
     * }
     */
    public static MemorySegment SCNuPTR() {
        class Holder {
            static final MemorySegment SCNuPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxPTR "lx"
     * }
     */
    public static MemorySegment SCNxPTR() {
        class Holder {
            static final MemorySegment SCNxPTR
                = LLVM.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxPTR;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
}

